// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package kafka

import (
	"fmt"

	"github.com/savaki/kafka/protocol"
	"github.com/savaki/kafka/protocol/apikey"
	"github.com/savaki/kafka/sizeof"
)

// apiVersion contains the negotiated versions for each api key
type apiVersion struct {
	Produce                     int16
	Fetch                       int16
	ListOffset                  int16
	Metadata                    int16
	LeaderAndIsr                int16
	StopReplica                 int16
	UpdateMetadata              int16
	ControlledShutdown          int16
	OffsetCommit                int16
	OffsetFetch                 int16
	FindCoordinator             int16
	JoinGroup                   int16
	Heartbeat                   int16
	LeaveGroup                  int16
	SyncGroup                   int16
	DescribeGroups              int16
	ListGroups                  int16
	SaslHandshake               int16
	ApiVersions                 int16
	CreateTopics                int16
	DeleteTopics                int16
	DeleteRecords               int16
	InitProducerId              int16
	OffsetForLeaderEpoch        int16
	AddPartitionsToTxn          int16
	AddOffsetsToTxn             int16
	EndTxn                      int16
	WriteTxnMarkers             int16
	TxnOffsetCommit             int16
	DescribeAcls                int16
	CreateAcls                  int16
	DeleteAcls                  int16
	DescribeConfigs             int16
	AlterConfigs                int16
	AlterReplicaLogDirs         int16
	DescribeLogDirs             int16
	SaslAuthenticate            int16
	CreatePartitions            int16
	CreateDelegationToken       int16
	RenewDelegationToken        int16
	ExpireDelegationToken       int16
	DescribeDelegationToken     int16
	DeleteGroups                int16
	ElectLeaders                int16
	IncrementalAlterConfigs     int16
	AlterPartitionReassignments int16
	ListPartitionReassignments  int16
	OffsetDelete                int16
}

// ProduceRequest; ApiKey: 0, Versions: 0-8
type ProduceRequest struct {
	TransactionalId string              // The transactional ID, or null if the producer is not transactional. Versions: 0-8
	Acks            int16               // The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR. Versions: 0-8
	TimeoutMs       int32               // The timeout to await a response in miliseconds. Versions: 0-8
	Topics          []TopicProduceData0 // Each topic to produce to. Versions: 0-8
}

// size of ProduceRequest; Versions: 0-8
func (t ProduceRequest) Size(version int16) int32 {
	var sz int32
	if version >= 3 {
		sz += sizeof.String(t.TransactionalId) // TransactionalId
	}
	sz += sizeof.Int16       // Acks
	sz += sizeof.Int32       // TimeoutMs
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode ProduceRequest; Versions: 0-8
func (t ProduceRequest) Encode(e *protocol.Encoder, version int16) {
	if version >= 3 {
		e.PutString(t.TransactionalId) // TransactionalId
	}
	e.PutInt16(t.Acks)      // Acks
	e.PutInt32(t.TimeoutMs) // TimeoutMs
	// Topics
	len3 := len(t.Topics)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode ProduceRequest; Versions: 0-8
func (t *ProduceRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 3 {
		t.TransactionalId, err = d.String()
		if err != nil {
			return err
		}
	}
	t.Acks, err = d.Int16()
	if err != nil {
		return err
	}
	t.TimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]TopicProduceData0, n)
		for i := 0; i < n; i++ {
			var item TopicProduceData0
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type TopicProduceData0 struct {
	Name       string                  // The topic name. Versions: 0-8
	Partitions []PartitionProduceData0 // Each partition to produce to. Versions: 0-8
}

// size of TopicProduceData0; Versions: 0-8
func (t TopicProduceData0) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode TopicProduceData0; Versions: 0-8
func (t TopicProduceData0) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode TopicProduceData0; Versions: 0-8
func (t *TopicProduceData0) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]PartitionProduceData0, n)
		for i := 0; i < n; i++ {
			var item PartitionProduceData0
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type PartitionProduceData0 struct {
	PartitionIndex int32  // The partition index. Versions: 0-8
	Records        []byte // The record data to be produced. Versions: 0-8
}

// size of PartitionProduceData0; Versions: 0-8
func (t PartitionProduceData0) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32            // PartitionIndex
	sz += sizeof.Bytes(t.Records) // Records
	return sz
}

// encode PartitionProduceData0; Versions: 0-8
func (t PartitionProduceData0) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutBytes(t.Records)        // Records
}

// decode PartitionProduceData0; Versions: 0-8
func (t *PartitionProduceData0) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.Records, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

// ProduceResponse; ApiKey: 0, Versions: 0-8
type ProduceResponse struct {
	Responses      []TopicProduceResponse0 // Each produce response Versions: 0-8
	ThrottleTimeMs int32                   // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-8
}

// size of ProduceResponse; Versions: 0-8
func (t ProduceResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Responses
	for i := len(t.Responses) - 1; i >= 0; i-- {
		sz += t.Responses[i].Size(version)
	}
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	return sz
}

// encode ProduceResponse; Versions: 0-8
func (t ProduceResponse) Encode(e *protocol.Encoder, version int16) {
	// Responses
	len0 := len(t.Responses)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Responses[i].Encode(e, version)
	}
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
}

// decode ProduceResponse; Versions: 0-8
func (t *ProduceResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Responses
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Responses = make([]TopicProduceResponse0, n)
		for i := 0; i < n; i++ {
			var item TopicProduceResponse0
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Responses[i] = item
		}
	}
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}

type TopicProduceResponse0 struct {
	Name       string                      // The topic name Versions: 0-8
	Partitions []PartitionProduceResponse0 // Each partition that we produced to within the topic. Versions: 0-8
}

// size of TopicProduceResponse0; Versions: 0-8
func (t TopicProduceResponse0) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode TopicProduceResponse0; Versions: 0-8
func (t TopicProduceResponse0) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode TopicProduceResponse0; Versions: 0-8
func (t *TopicProduceResponse0) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]PartitionProduceResponse0, n)
		for i := 0; i < n; i++ {
			var item PartitionProduceResponse0
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type PartitionProduceResponse0 struct {
	PartitionIndex  int32                        // The partition index. Versions: 0-8
	ErrorCode       int16                        // The error code, or 0 if there was no error. Versions: 0-8
	BaseOffset      int64                        // The base offset. Versions: 0-8
	LogAppendTimeMs int64                        // The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1.  If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended. Versions: 0-8
	LogStartOffset  int64                        // The log start offset. Versions: 0-8
	RecordErrors    []BatchIndexAndErrorMessage0 // The batch indices of records that caused the batch to be dropped Versions: 0-8
	ErrorMessage    string                       // The global error message summarizing the common root cause of the records that caused the batch to be dropped Versions: 0-8
}

// size of PartitionProduceResponse0; Versions: 0-8
func (t PartitionProduceResponse0) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	sz += sizeof.Int64 // BaseOffset
	if version >= 2 {
		sz += sizeof.Int64 // LogAppendTimeMs
	}
	if version >= 5 {
		sz += sizeof.Int64 // LogStartOffset
	}
	if version >= 8 {
		sz += sizeof.ArrayLength // RecordErrors
		for i := len(t.RecordErrors) - 1; i >= 0; i-- {
			sz += t.RecordErrors[i].Size(version)
		}
	}
	if version >= 8 {
		sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	}
	return sz
}

// encode PartitionProduceResponse0; Versions: 0-8
func (t PartitionProduceResponse0) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutInt64(t.BaseOffset)     // BaseOffset
	if version >= 2 {
		e.PutInt64(t.LogAppendTimeMs) // LogAppendTimeMs
	}
	if version >= 5 {
		e.PutInt64(t.LogStartOffset) // LogStartOffset
	}
	if version >= 8 {
		// RecordErrors
		len5 := len(t.RecordErrors)
		e.PutArrayLength(len5)
		for i := 0; i < len5; i++ {
			t.RecordErrors[i].Encode(e, version)
		}
	}
	if version >= 8 {
		e.PutString(t.ErrorMessage) // ErrorMessage
	}
}

// decode PartitionProduceResponse0; Versions: 0-8
func (t *PartitionProduceResponse0) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.BaseOffset, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 2 {
		t.LogAppendTimeMs, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.LogStartOffset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 8 {
		// RecordErrors
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.RecordErrors = make([]BatchIndexAndErrorMessage0, n)
			for i := 0; i < n; i++ {
				var item BatchIndexAndErrorMessage0
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.RecordErrors[i] = item
			}
		}
	}
	if version >= 8 {
		t.ErrorMessage, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

type BatchIndexAndErrorMessage0 struct {
	BatchIndex             int32  // The batch index of the record that cause the batch to be dropped Versions: 0-8
	BatchIndexErrorMessage string // The error message of the record that caused the batch to be dropped Versions: 0-8
}

// size of BatchIndexAndErrorMessage0; Versions: 0-8
func (t BatchIndexAndErrorMessage0) Size(version int16) int32 {
	var sz int32
	if version >= 8 {
		sz += sizeof.Int32 // BatchIndex
	}
	if version >= 8 {
		sz += sizeof.String(t.BatchIndexErrorMessage) // BatchIndexErrorMessage
	}
	return sz
}

// encode BatchIndexAndErrorMessage0; Versions: 0-8
func (t BatchIndexAndErrorMessage0) Encode(e *protocol.Encoder, version int16) {
	if version >= 8 {
		e.PutInt32(t.BatchIndex) // BatchIndex
	}
	if version >= 8 {
		e.PutString(t.BatchIndexErrorMessage) // BatchIndexErrorMessage
	}
}

// decode BatchIndexAndErrorMessage0; Versions: 0-8
func (t *BatchIndexAndErrorMessage0) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 8 {
		t.BatchIndex, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 8 {
		t.BatchIndexErrorMessage, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

// RequestHeader; ApiKey: 0, Versions: 0-2
type RequestHeader struct {
	RequestApiKey     int16  // The API key of this request. Versions: 0-2
	RequestApiVersion int16  // The API version of this request. Versions: 0-2
	CorrelationId     int32  // The correlation ID of this request. Versions: 0-2
	ClientId          string // The client ID string. Versions: 0-2
}

// size of RequestHeader; Versions: 0-2
func (t RequestHeader) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16 // RequestApiKey
	sz += sizeof.Int16 // RequestApiVersion
	sz += sizeof.Int32 // CorrelationId
	if version >= 1 {
		sz += sizeof.String(t.ClientId) // ClientId
	}
	return sz
}

// encode RequestHeader; Versions: 0-2
func (t RequestHeader) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.RequestApiKey)     // RequestApiKey
	e.PutInt16(t.RequestApiVersion) // RequestApiVersion
	e.PutInt32(t.CorrelationId)     // CorrelationId
	if version >= 1 {
		e.PutString(t.ClientId) // ClientId
	}
}

// decode RequestHeader; Versions: 0-2
func (t *RequestHeader) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.RequestApiKey, err = d.Int16()
	if err != nil {
		return err
	}
	t.RequestApiVersion, err = d.Int16()
	if err != nil {
		return err
	}
	t.CorrelationId, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.ClientId, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

// ResponseHeader; ApiKey: 0, Versions: 0-1
type ResponseHeader struct {
	CorrelationId int32 // The correlation ID of this response. Versions: 0-1
}

// size of ResponseHeader; Versions: 0-1
func (t ResponseHeader) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // CorrelationId
	return sz
}

// encode ResponseHeader; Versions: 0-1
func (t ResponseHeader) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.CorrelationId) // CorrelationId
}

// decode ResponseHeader; Versions: 0-1
func (t *ResponseHeader) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.CorrelationId, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// FetchRequest; ApiKey: 1, Versions: 0-11
type FetchRequest struct {
	ReplicaId      int32             // The broker ID of the follower, of -1 if this request is from a consumer. Versions: 0-11
	MaxWait        int32             // The maximum time in milliseconds to wait for the response. Versions: 0-11
	MinBytes       int32             // The minimum bytes to accumulate in the response. Versions: 0-11
	MaxBytes       int32             // The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored. Versions: 0-11
	IsolationLevel int8              // This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records Versions: 0-11
	SessionId      int32             // The fetch session ID. Versions: 0-11
	Epoch          int32             // The fetch session ID. Versions: 0-11
	Topics         []FetchableTopic1 // The topics to fetch. Versions: 0-11
	Forgotten      []ForgottenTopic1 // In an incremental fetch request, the partitions to remove. Versions: 0-11
	RackId         string            // Rack ID of the consumer making this request Versions: 0-11
}

// size of FetchRequest; Versions: 0-11
func (t FetchRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ReplicaId
	sz += sizeof.Int32 // MaxWait
	sz += sizeof.Int32 // MinBytes
	if version >= 3 {
		sz += sizeof.Int32 // MaxBytes
	}
	if version >= 4 {
		sz += sizeof.Int8 // IsolationLevel
	}
	if version >= 7 {
		sz += sizeof.Int32 // SessionId
	}
	if version >= 7 {
		sz += sizeof.Int32 // Epoch
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	if version >= 7 {
		sz += sizeof.ArrayLength // Forgotten
		for i := len(t.Forgotten) - 1; i >= 0; i-- {
			sz += t.Forgotten[i].Size(version)
		}
	}
	if version >= 11 {
		sz += sizeof.String(t.RackId) // RackId
	}
	return sz
}

// encode FetchRequest; Versions: 0-11
func (t FetchRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ReplicaId) // ReplicaId
	e.PutInt32(t.MaxWait)   // MaxWait
	e.PutInt32(t.MinBytes)  // MinBytes
	if version >= 3 {
		e.PutInt32(t.MaxBytes) // MaxBytes
	}
	if version >= 4 {
		e.PutInt8(t.IsolationLevel) // IsolationLevel
	}
	if version >= 7 {
		e.PutInt32(t.SessionId) // SessionId
	}
	if version >= 7 {
		e.PutInt32(t.Epoch) // Epoch
	}
	// Topics
	len7 := len(t.Topics)
	e.PutArrayLength(len7)
	for i := 0; i < len7; i++ {
		t.Topics[i].Encode(e, version)
	}
	if version >= 7 {
		// Forgotten
		len8 := len(t.Forgotten)
		e.PutArrayLength(len8)
		for i := 0; i < len8; i++ {
			t.Forgotten[i].Encode(e, version)
		}
	}
	if version >= 11 {
		e.PutString(t.RackId) // RackId
	}
}

// decode FetchRequest; Versions: 0-11
func (t *FetchRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ReplicaId, err = d.Int32()
	if err != nil {
		return err
	}
	t.MaxWait, err = d.Int32()
	if err != nil {
		return err
	}
	t.MinBytes, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 3 {
		t.MaxBytes, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 4 {
		t.IsolationLevel, err = d.Int8()
		if err != nil {
			return err
		}
	}
	if version >= 7 {
		t.SessionId, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 7 {
		t.Epoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]FetchableTopic1, n)
		for i := 0; i < n; i++ {
			var item FetchableTopic1
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	if version >= 7 {
		// Forgotten
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Forgotten = make([]ForgottenTopic1, n)
			for i := 0; i < n; i++ {
				var item ForgottenTopic1
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.Forgotten[i] = item
			}
		}
	}
	if version >= 11 {
		t.RackId, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

type FetchableTopic1 struct {
	Name            string            // The name of the topic to fetch. Versions: 0-11
	FetchPartitions []FetchPartition1 // The partitions to fetch. Versions: 0-11
}

// size of FetchableTopic1; Versions: 0-11
func (t FetchableTopic1) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // FetchPartitions
	for i := len(t.FetchPartitions) - 1; i >= 0; i-- {
		sz += t.FetchPartitions[i].Size(version)
	}
	return sz
}

// encode FetchableTopic1; Versions: 0-11
func (t FetchableTopic1) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// FetchPartitions
	len1 := len(t.FetchPartitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.FetchPartitions[i].Encode(e, version)
	}
}

// decode FetchableTopic1; Versions: 0-11
func (t *FetchableTopic1) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// FetchPartitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.FetchPartitions = make([]FetchPartition1, n)
		for i := 0; i < n; i++ {
			var item FetchPartition1
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.FetchPartitions[i] = item
		}
	}
	return err
}

type FetchPartition1 struct {
	PartitionIndex     int32 // The partition index. Versions: 0-11
	CurrentLeaderEpoch int32 // The current leader epoch of the partition. Versions: 0-11
	FetchOffset        int64 // The message offset. Versions: 0-11
	LogStartOffset     int64 // The earliest available offset of the follower replica.  The field is only used when the request is sent by the follower. Versions: 0-11
	MaxBytes           int32 // The maximum bytes to fetch from this partition.  See KIP-74 for cases where this limit may not be honored. Versions: 0-11
}

// size of FetchPartition1; Versions: 0-11
func (t FetchPartition1) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	if version >= 9 {
		sz += sizeof.Int32 // CurrentLeaderEpoch
	}
	sz += sizeof.Int64 // FetchOffset
	if version >= 5 {
		sz += sizeof.Int64 // LogStartOffset
	}
	sz += sizeof.Int32 // MaxBytes
	return sz
}

// encode FetchPartition1; Versions: 0-11
func (t FetchPartition1) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	if version >= 9 {
		e.PutInt32(t.CurrentLeaderEpoch) // CurrentLeaderEpoch
	}
	e.PutInt64(t.FetchOffset) // FetchOffset
	if version >= 5 {
		e.PutInt64(t.LogStartOffset) // LogStartOffset
	}
	e.PutInt32(t.MaxBytes) // MaxBytes
}

// decode FetchPartition1; Versions: 0-11
func (t *FetchPartition1) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 9 {
		t.CurrentLeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.FetchOffset, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 5 {
		t.LogStartOffset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	t.MaxBytes, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

type ForgottenTopic1 struct {
	Name                      string  // The partition name. Versions: 0-11
	ForgottenPartitionIndexes []int32 // The partitions indexes to forget. Versions: 0-11
}

// size of ForgottenTopic1; Versions: 0-11
func (t ForgottenTopic1) Size(version int16) int32 {
	var sz int32
	if version >= 7 {
		sz += sizeof.String(t.Name) // Name
	}
	if version >= 7 {
		sz += sizeof.Int32Array(t.ForgottenPartitionIndexes) // ForgottenPartitionIndexes
	}
	return sz
}

// encode ForgottenTopic1; Versions: 0-11
func (t ForgottenTopic1) Encode(e *protocol.Encoder, version int16) {
	if version >= 7 {
		e.PutString(t.Name) // Name
	}
	if version >= 7 {
		e.PutInt32Array(t.ForgottenPartitionIndexes) // ForgottenPartitionIndexes
	}
}

// decode ForgottenTopic1; Versions: 0-11
func (t *ForgottenTopic1) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 7 {
		t.Name, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 7 {
		t.ForgottenPartitionIndexes, err = d.Int32Array()
		if err != nil {
			return err
		}
	}
	return err
}

// FetchResponse; ApiKey: 1, Versions: 0-11
type FetchResponse struct {
	ThrottleTimeMs int32                     // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-11
	ErrorCode      int16                     // The top level response error code. Versions: 0-11
	SessionId      int32                     // The fetch session ID, or 0 if this is not part of a fetch session. Versions: 0-11
	Topics         []FetchableTopicResponse1 // The response topics. Versions: 0-11
}

// size of FetchResponse; Versions: 0-11
func (t FetchResponse) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	if version >= 7 {
		sz += sizeof.Int16 // ErrorCode
	}
	if version >= 7 {
		sz += sizeof.Int32 // SessionId
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode FetchResponse; Versions: 0-11
func (t FetchResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	if version >= 7 {
		e.PutInt16(t.ErrorCode) // ErrorCode
	}
	if version >= 7 {
		e.PutInt32(t.SessionId) // SessionId
	}
	// Topics
	len3 := len(t.Topics)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode FetchResponse; Versions: 0-11
func (t *FetchResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 7 {
		t.ErrorCode, err = d.Int16()
		if err != nil {
			return err
		}
	}
	if version >= 7 {
		t.SessionId, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]FetchableTopicResponse1, n)
		for i := 0; i < n; i++ {
			var item FetchableTopicResponse1
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type FetchableTopicResponse1 struct {
	Name       string                        // The topic name. Versions: 0-11
	Partitions []FetchablePartitionResponse1 // The topic partitions. Versions: 0-11
}

// size of FetchableTopicResponse1; Versions: 0-11
func (t FetchableTopicResponse1) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode FetchableTopicResponse1; Versions: 0-11
func (t FetchableTopicResponse1) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode FetchableTopicResponse1; Versions: 0-11
func (t *FetchableTopicResponse1) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]FetchablePartitionResponse1, n)
		for i := 0; i < n; i++ {
			var item FetchablePartitionResponse1
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type FetchablePartitionResponse1 struct {
	PartitionIndex       int32                 // The partiiton index. Versions: 0-11
	ErrorCode            int16                 // The error code, or 0 if there was no fetch error. Versions: 0-11
	HighWatermark        int64                 // The current high water mark. Versions: 0-11
	LastStableOffset     int64                 // The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED) Versions: 0-11
	LogStartOffset       int64                 // The current log start offset. Versions: 0-11
	Aborted              []AbortedTransaction1 // The aborted transactions. Versions: 0-11
	PreferredReadReplica int32                 // The preferred read replica for the consumer to use on its next fetch request Versions: 0-11
	Records              []byte                // The record data. Versions: 0-11
}

// size of FetchablePartitionResponse1; Versions: 0-11
func (t FetchablePartitionResponse1) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	sz += sizeof.Int64 // HighWatermark
	if version >= 4 {
		sz += sizeof.Int64 // LastStableOffset
	}
	if version >= 5 {
		sz += sizeof.Int64 // LogStartOffset
	}
	if version >= 4 {
		sz += sizeof.ArrayLength // Aborted
		for i := len(t.Aborted) - 1; i >= 0; i-- {
			sz += t.Aborted[i].Size(version)
		}
	}
	if version >= 11 {
		sz += sizeof.Int32 // PreferredReadReplica
	}
	sz += sizeof.Bytes(t.Records) // Records
	return sz
}

// encode FetchablePartitionResponse1; Versions: 0-11
func (t FetchablePartitionResponse1) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutInt64(t.HighWatermark)  // HighWatermark
	if version >= 4 {
		e.PutInt64(t.LastStableOffset) // LastStableOffset
	}
	if version >= 5 {
		e.PutInt64(t.LogStartOffset) // LogStartOffset
	}
	if version >= 4 {
		// Aborted
		len5 := len(t.Aborted)
		e.PutArrayLength(len5)
		for i := 0; i < len5; i++ {
			t.Aborted[i].Encode(e, version)
		}
	}
	if version >= 11 {
		e.PutInt32(t.PreferredReadReplica) // PreferredReadReplica
	}
	e.PutBytes(t.Records) // Records
}

// decode FetchablePartitionResponse1; Versions: 0-11
func (t *FetchablePartitionResponse1) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.HighWatermark, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 4 {
		t.LastStableOffset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.LogStartOffset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 4 {
		// Aborted
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Aborted = make([]AbortedTransaction1, n)
			for i := 0; i < n; i++ {
				var item AbortedTransaction1
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.Aborted[i] = item
			}
		}
	}
	if version >= 11 {
		t.PreferredReadReplica, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.Records, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

type AbortedTransaction1 struct {
	ProducerId  int64 // The producer id associated with the aborted transaction. Versions: 0-11
	FirstOffset int64 // The first offset in the aborted transaction. Versions: 0-11
}

// size of AbortedTransaction1; Versions: 0-11
func (t AbortedTransaction1) Size(version int16) int32 {
	var sz int32
	if version >= 4 {
		sz += sizeof.Int64 // ProducerId
	}
	if version >= 4 {
		sz += sizeof.Int64 // FirstOffset
	}
	return sz
}

// encode AbortedTransaction1; Versions: 0-11
func (t AbortedTransaction1) Encode(e *protocol.Encoder, version int16) {
	if version >= 4 {
		e.PutInt64(t.ProducerId) // ProducerId
	}
	if version >= 4 {
		e.PutInt64(t.FirstOffset) // FirstOffset
	}
}

// decode AbortedTransaction1; Versions: 0-11
func (t *AbortedTransaction1) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 4 {
		t.ProducerId, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 4 {
		t.FirstOffset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	return err
}

// ListOffsetRequest; ApiKey: 2, Versions: 0-5
type ListOffsetRequest struct {
	ReplicaId      int32              // The broker ID of the requestor, or -1 if this request is being made by a normal consumer. Versions: 0-5
	IsolationLevel int8               // This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records Versions: 0-5
	Topics         []ListOffsetTopic2 // Each topic in the request. Versions: 0-5
}

// size of ListOffsetRequest; Versions: 0-5
func (t ListOffsetRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ReplicaId
	if version >= 2 {
		sz += sizeof.Int8 // IsolationLevel
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode ListOffsetRequest; Versions: 0-5
func (t ListOffsetRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ReplicaId) // ReplicaId
	if version >= 2 {
		e.PutInt8(t.IsolationLevel) // IsolationLevel
	}
	// Topics
	len2 := len(t.Topics)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode ListOffsetRequest; Versions: 0-5
func (t *ListOffsetRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ReplicaId, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 2 {
		t.IsolationLevel, err = d.Int8()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]ListOffsetTopic2, n)
		for i := 0; i < n; i++ {
			var item ListOffsetTopic2
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type ListOffsetTopic2 struct {
	Name       string                 // The topic name. Versions: 0-5
	Partitions []ListOffsetPartition2 // Each partition in the request. Versions: 0-5
}

// size of ListOffsetTopic2; Versions: 0-5
func (t ListOffsetTopic2) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode ListOffsetTopic2; Versions: 0-5
func (t ListOffsetTopic2) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode ListOffsetTopic2; Versions: 0-5
func (t *ListOffsetTopic2) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]ListOffsetPartition2, n)
		for i := 0; i < n; i++ {
			var item ListOffsetPartition2
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type ListOffsetPartition2 struct {
	PartitionIndex     int32 // The partition index. Versions: 0-5
	CurrentLeaderEpoch int32 // The current leader epoch. Versions: 0-5
	Timestamp          int64 // The current timestamp. Versions: 0-5
	MaxNumOffsets      int32 // The maximum number of offsets to report. Versions: 0-5
}

// size of ListOffsetPartition2; Versions: 0-5
func (t ListOffsetPartition2) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	if version >= 4 {
		sz += sizeof.Int32 // CurrentLeaderEpoch
	}
	sz += sizeof.Int64 // Timestamp
	if version >= 0 && version <= 0 {
		sz += sizeof.Int32 // MaxNumOffsets
	}
	return sz
}

// encode ListOffsetPartition2; Versions: 0-5
func (t ListOffsetPartition2) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	if version >= 4 {
		e.PutInt32(t.CurrentLeaderEpoch) // CurrentLeaderEpoch
	}
	e.PutInt64(t.Timestamp) // Timestamp
	if version >= 0 && version <= 0 {
		e.PutInt32(t.MaxNumOffsets) // MaxNumOffsets
	}
}

// decode ListOffsetPartition2; Versions: 0-5
func (t *ListOffsetPartition2) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 4 {
		t.CurrentLeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.Timestamp, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 0 && version <= 0 {
		t.MaxNumOffsets, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}

// ListOffsetResponse; ApiKey: 2, Versions: 0-5
type ListOffsetResponse struct {
	ThrottleTimeMs int32                      // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-5
	Topics         []ListOffsetTopicResponse2 // Each topic in the response. Versions: 0-5
}

// size of ListOffsetResponse; Versions: 0-5
func (t ListOffsetResponse) Size(version int16) int32 {
	var sz int32
	if version >= 2 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode ListOffsetResponse; Versions: 0-5
func (t ListOffsetResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 2 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode ListOffsetResponse; Versions: 0-5
func (t *ListOffsetResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 2 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]ListOffsetTopicResponse2, n)
		for i := 0; i < n; i++ {
			var item ListOffsetTopicResponse2
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type ListOffsetTopicResponse2 struct {
	Name       string                         // The topic name Versions: 0-5
	Partitions []ListOffsetPartitionResponse2 // Each partition in the response. Versions: 0-5
}

// size of ListOffsetTopicResponse2; Versions: 0-5
func (t ListOffsetTopicResponse2) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode ListOffsetTopicResponse2; Versions: 0-5
func (t ListOffsetTopicResponse2) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode ListOffsetTopicResponse2; Versions: 0-5
func (t *ListOffsetTopicResponse2) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]ListOffsetPartitionResponse2, n)
		for i := 0; i < n; i++ {
			var item ListOffsetPartitionResponse2
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type ListOffsetPartitionResponse2 struct {
	PartitionIndex  int32   // The partition index. Versions: 0-5
	ErrorCode       int16   // The partition error code, or 0 if there was no error. Versions: 0-5
	OldStyleOffsets []int64 // The result offsets. Versions: 0-5
	Timestamp       int64   // The timestamp associated with the returned offset. Versions: 0-5
	Offset          int64   // The returned offset. Versions: 0-5
	LeaderEpoch     int32   // Versions: 0-5
}

// size of ListOffsetPartitionResponse2; Versions: 0-5
func (t ListOffsetPartitionResponse2) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	if version >= 0 && version <= 0 {
		sz += sizeof.Int64Array(t.OldStyleOffsets) // OldStyleOffsets
	}
	if version >= 1 {
		sz += sizeof.Int64 // Timestamp
	}
	if version >= 1 {
		sz += sizeof.Int64 // Offset
	}
	if version >= 4 {
		sz += sizeof.Int32 // LeaderEpoch
	}
	return sz
}

// encode ListOffsetPartitionResponse2; Versions: 0-5
func (t ListOffsetPartitionResponse2) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
	if version >= 0 && version <= 0 {
		e.PutInt64Array(t.OldStyleOffsets) // OldStyleOffsets
	}
	if version >= 1 {
		e.PutInt64(t.Timestamp) // Timestamp
	}
	if version >= 1 {
		e.PutInt64(t.Offset) // Offset
	}
	if version >= 4 {
		e.PutInt32(t.LeaderEpoch) // LeaderEpoch
	}
}

// decode ListOffsetPartitionResponse2; Versions: 0-5
func (t *ListOffsetPartitionResponse2) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	if version >= 0 && version <= 0 {
		t.OldStyleOffsets, err = d.Int64Array()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.Timestamp, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.Offset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 4 {
		t.LeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}

// MetadataRequest; ApiKey: 3, Versions: 0-9
type MetadataRequest struct {
	Topics                             []MetadataRequestTopic3 // The topics to fetch metadata for. Versions: 0-9
	AllowAutoTopicCreation             bool                    // If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so. Versions: 0-9
	IncludeClusterAuthorizedOperations bool                    // Whether to include cluster authorized operations. Versions: 0-9
	IncludeTopicAuthorizedOperations   bool                    // Whether to include topic authorized operations. Versions: 0-9
}

// size of MetadataRequest; Versions: 0-9
func (t MetadataRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	if version >= 4 {
		sz += sizeof.Bool // AllowAutoTopicCreation
	}
	if version >= 8 {
		sz += sizeof.Bool // IncludeClusterAuthorizedOperations
	}
	if version >= 8 {
		sz += sizeof.Bool // IncludeTopicAuthorizedOperations
	}
	return sz
}

// encode MetadataRequest; Versions: 0-9
func (t MetadataRequest) Encode(e *protocol.Encoder, version int16) {
	// Topics
	len0 := len(t.Topics)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Topics[i].Encode(e, version)
	}
	if version >= 4 {
		e.PutBool(t.AllowAutoTopicCreation) // AllowAutoTopicCreation
	}
	if version >= 8 {
		e.PutBool(t.IncludeClusterAuthorizedOperations) // IncludeClusterAuthorizedOperations
	}
	if version >= 8 {
		e.PutBool(t.IncludeTopicAuthorizedOperations) // IncludeTopicAuthorizedOperations
	}
}

// decode MetadataRequest; Versions: 0-9
func (t *MetadataRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]MetadataRequestTopic3, n)
		for i := 0; i < n; i++ {
			var item MetadataRequestTopic3
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	if version >= 4 {
		t.AllowAutoTopicCreation, err = d.Bool()
		if err != nil {
			return err
		}
	}
	if version >= 8 {
		t.IncludeClusterAuthorizedOperations, err = d.Bool()
		if err != nil {
			return err
		}
	}
	if version >= 8 {
		t.IncludeTopicAuthorizedOperations, err = d.Bool()
		if err != nil {
			return err
		}
	}
	return err
}

type MetadataRequestTopic3 struct {
	Name string // The topic name. Versions: 0-9
}

// size of MetadataRequestTopic3; Versions: 0-9
func (t MetadataRequestTopic3) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	return sz
}

// encode MetadataRequestTopic3; Versions: 0-9
func (t MetadataRequestTopic3) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
}

// decode MetadataRequestTopic3; Versions: 0-9
func (t *MetadataRequestTopic3) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// MetadataResponse; ApiKey: 3, Versions: 0-9
type MetadataResponse struct {
	ThrottleTimeMs              int32                     // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-9
	Brokers                     []MetadataResponseBroker3 // Each broker in the response. Versions: 0-9
	ClusterId                   string                    // The cluster ID that responding broker belongs to. Versions: 0-9
	ControllerId                int32                     // The ID of the controller broker. Versions: 0-9
	Topics                      []MetadataResponseTopic3  // Each topic in the response. Versions: 0-9
	ClusterAuthorizedOperations int32                     // 32-bit bitfield to represent authorized operations for this cluster. Versions: 0-9
}

// size of MetadataResponse; Versions: 0-9
func (t MetadataResponse) Size(version int16) int32 {
	var sz int32
	if version >= 3 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.ArrayLength // Brokers
	for i := len(t.Brokers) - 1; i >= 0; i-- {
		sz += t.Brokers[i].Size(version)
	}
	if version >= 2 {
		sz += sizeof.String(t.ClusterId) // ClusterId
	}
	if version >= 1 {
		sz += sizeof.Int32 // ControllerId
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	if version >= 8 {
		sz += sizeof.Int32 // ClusterAuthorizedOperations
	}
	return sz
}

// encode MetadataResponse; Versions: 0-9
func (t MetadataResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 3 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	// Brokers
	len1 := len(t.Brokers)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Brokers[i].Encode(e, version)
	}
	if version >= 2 {
		e.PutString(t.ClusterId) // ClusterId
	}
	if version >= 1 {
		e.PutInt32(t.ControllerId) // ControllerId
	}
	// Topics
	len4 := len(t.Topics)
	e.PutArrayLength(len4)
	for i := 0; i < len4; i++ {
		t.Topics[i].Encode(e, version)
	}
	if version >= 8 {
		e.PutInt32(t.ClusterAuthorizedOperations) // ClusterAuthorizedOperations
	}
}

// decode MetadataResponse; Versions: 0-9
func (t *MetadataResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 3 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Brokers
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Brokers = make([]MetadataResponseBroker3, n)
		for i := 0; i < n; i++ {
			var item MetadataResponseBroker3
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Brokers[i] = item
		}
	}
	if version >= 2 {
		t.ClusterId, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.ControllerId, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]MetadataResponseTopic3, n)
		for i := 0; i < n; i++ {
			var item MetadataResponseTopic3
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	if version >= 8 {
		t.ClusterAuthorizedOperations, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}

type MetadataResponseBroker3 struct {
	NodeId int32  // The broker ID. Versions: 0-9
	Host   string // The broker hostname. Versions: 0-9
	Port   int32  // The broker port. Versions: 0-9
	Rack   string // The rack of the broker, or null if it has not been assigned to a rack. Versions: 0-9
}

// size of MetadataResponseBroker3; Versions: 0-9
func (t MetadataResponseBroker3) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32          // NodeId
	sz += sizeof.String(t.Host) // Host
	sz += sizeof.Int32          // Port
	if version >= 1 {
		sz += sizeof.String(t.Rack) // Rack
	}
	return sz
}

// encode MetadataResponseBroker3; Versions: 0-9
func (t MetadataResponseBroker3) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.NodeId) // NodeId
	e.PutString(t.Host)  // Host
	e.PutInt32(t.Port)   // Port
	if version >= 1 {
		e.PutString(t.Rack) // Rack
	}
}

// decode MetadataResponseBroker3; Versions: 0-9
func (t *MetadataResponseBroker3) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.NodeId, err = d.Int32()
	if err != nil {
		return err
	}
	t.Host, err = d.String()
	if err != nil {
		return err
	}
	t.Port, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.Rack, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

type MetadataResponseTopic3 struct {
	ErrorCode                 int16                        // The topic error, or 0 if there was no error. Versions: 0-9
	Name                      string                       // The topic name. Versions: 0-9
	IsInternal                bool                         // True if the topic is internal. Versions: 0-9
	Partitions                []MetadataResponsePartition3 // Each partition in the topic. Versions: 0-9
	TopicAuthorizedOperations int32                        // 32-bit bitfield to represent authorized operations for this topic. Versions: 0-9
}

// size of MetadataResponseTopic3; Versions: 0-9
func (t MetadataResponseTopic3) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16          // ErrorCode
	sz += sizeof.String(t.Name) // Name
	if version >= 1 {
		sz += sizeof.Bool // IsInternal
	}
	sz += sizeof.ArrayLength // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	if version >= 8 {
		sz += sizeof.Int32 // TopicAuthorizedOperations
	}
	return sz
}

// encode MetadataResponseTopic3; Versions: 0-9
func (t MetadataResponseTopic3) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
	e.PutString(t.Name)     // Name
	if version >= 1 {
		e.PutBool(t.IsInternal) // IsInternal
	}
	// Partitions
	len3 := len(t.Partitions)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Partitions[i].Encode(e, version)
	}
	if version >= 8 {
		e.PutInt32(t.TopicAuthorizedOperations) // TopicAuthorizedOperations
	}
}

// decode MetadataResponseTopic3; Versions: 0-9
func (t *MetadataResponseTopic3) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.IsInternal, err = d.Bool()
		if err != nil {
			return err
		}
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]MetadataResponsePartition3, n)
		for i := 0; i < n; i++ {
			var item MetadataResponsePartition3
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	if version >= 8 {
		t.TopicAuthorizedOperations, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}

type MetadataResponsePartition3 struct {
	ErrorCode       int16   // The partition error, or 0 if there was no error. Versions: 0-9
	PartitionIndex  int32   // The partition index. Versions: 0-9
	LeaderId        int32   // The ID of the leader broker. Versions: 0-9
	LeaderEpoch     int32   // The leader epoch of this partition. Versions: 0-9
	ReplicaNodes    []int32 // The set of all nodes that host this partition. Versions: 0-9
	IsrNodes        []int32 // The set of nodes that are in sync with the leader for this partition. Versions: 0-9
	OfflineReplicas []int32 // The set of offline replicas of this partition. Versions: 0-9
}

// size of MetadataResponsePartition3; Versions: 0-9
func (t MetadataResponsePartition3) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16 // ErrorCode
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int32 // LeaderId
	if version >= 7 {
		sz += sizeof.Int32 // LeaderEpoch
	}
	sz += sizeof.Int32Array(t.ReplicaNodes) // ReplicaNodes
	sz += sizeof.Int32Array(t.IsrNodes)     // IsrNodes
	if version >= 5 {
		sz += sizeof.Int32Array(t.OfflineReplicas) // OfflineReplicas
	}
	return sz
}

// encode MetadataResponsePartition3; Versions: 0-9
func (t MetadataResponsePartition3) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt32(t.LeaderId)       // LeaderId
	if version >= 7 {
		e.PutInt32(t.LeaderEpoch) // LeaderEpoch
	}
	e.PutInt32Array(t.ReplicaNodes) // ReplicaNodes
	e.PutInt32Array(t.IsrNodes)     // IsrNodes
	if version >= 5 {
		e.PutInt32Array(t.OfflineReplicas) // OfflineReplicas
	}
}

// decode MetadataResponsePartition3; Versions: 0-9
func (t *MetadataResponsePartition3) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.LeaderId, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 7 {
		t.LeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.ReplicaNodes, err = d.Int32Array()
	if err != nil {
		return err
	}
	t.IsrNodes, err = d.Int32Array()
	if err != nil {
		return err
	}
	if version >= 5 {
		t.OfflineReplicas, err = d.Int32Array()
		if err != nil {
			return err
		}
	}
	return err
}

// LeaderAndIsrRequest; ApiKey: 4, Versions: 0-4
type LeaderAndIsrRequest struct {
	ControllerId             int32                         // The current controller ID. Versions: 0-4
	ControllerEpoch          int32                         // The current controller epoch. Versions: 0-4
	BrokerEpoch              int64                         // The current broker epoch. Versions: 0-4
	UngroupedPartitionStates []LeaderAndIsrPartitionState4 // The state of each partition, in a v0 or v1 message. Versions: 0-4
	TopicStates              []LeaderAndIsrTopicState4     // Each topic. Versions: 0-4
	LiveLeaders              []LeaderAndIsrLiveLeader4     // The current live leaders. Versions: 0-4
}

// size of LeaderAndIsrRequest; Versions: 0-4
func (t LeaderAndIsrRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ControllerId
	sz += sizeof.Int32 // ControllerEpoch
	if version >= 2 {
		sz += sizeof.Int64 // BrokerEpoch
	}
	if version >= 0 && version <= 1 {
		sz += sizeof.ArrayLength // UngroupedPartitionStates
		for i := len(t.UngroupedPartitionStates) - 1; i >= 0; i-- {
			sz += t.UngroupedPartitionStates[i].Size(version)
		}
	}
	if version >= 2 {
		sz += sizeof.ArrayLength // TopicStates
		for i := len(t.TopicStates) - 1; i >= 0; i-- {
			sz += t.TopicStates[i].Size(version)
		}
	}
	sz += sizeof.ArrayLength // LiveLeaders
	for i := len(t.LiveLeaders) - 1; i >= 0; i-- {
		sz += t.LiveLeaders[i].Size(version)
	}
	return sz
}

// encode LeaderAndIsrRequest; Versions: 0-4
func (t LeaderAndIsrRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ControllerId)    // ControllerId
	e.PutInt32(t.ControllerEpoch) // ControllerEpoch
	if version >= 2 {
		e.PutInt64(t.BrokerEpoch) // BrokerEpoch
	}
	if version >= 0 && version <= 1 {
		// UngroupedPartitionStates
		len3 := len(t.UngroupedPartitionStates)
		e.PutArrayLength(len3)
		for i := 0; i < len3; i++ {
			t.UngroupedPartitionStates[i].Encode(e, version)
		}
	}
	if version >= 2 {
		// TopicStates
		len4 := len(t.TopicStates)
		e.PutArrayLength(len4)
		for i := 0; i < len4; i++ {
			t.TopicStates[i].Encode(e, version)
		}
	}
	// LiveLeaders
	len5 := len(t.LiveLeaders)
	e.PutArrayLength(len5)
	for i := 0; i < len5; i++ {
		t.LiveLeaders[i].Encode(e, version)
	}
}

// decode LeaderAndIsrRequest; Versions: 0-4
func (t *LeaderAndIsrRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ControllerId, err = d.Int32()
	if err != nil {
		return err
	}
	t.ControllerEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 2 {
		t.BrokerEpoch, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 0 && version <= 1 {
		// UngroupedPartitionStates
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.UngroupedPartitionStates = make([]LeaderAndIsrPartitionState4, n)
			for i := 0; i < n; i++ {
				var item LeaderAndIsrPartitionState4
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.UngroupedPartitionStates[i] = item
			}
		}
	}
	if version >= 2 {
		// TopicStates
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.TopicStates = make([]LeaderAndIsrTopicState4, n)
			for i := 0; i < n; i++ {
				var item LeaderAndIsrTopicState4
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.TopicStates[i] = item
			}
		}
	}
	// LiveLeaders
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.LiveLeaders = make([]LeaderAndIsrLiveLeader4, n)
		for i := 0; i < n; i++ {
			var item LeaderAndIsrLiveLeader4
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.LiveLeaders[i] = item
		}
	}
	return err
}

type LeaderAndIsrTopicState4 struct {
	TopicName       string                        // The topic name. Versions: 0-4
	PartitionStates []LeaderAndIsrPartitionState4 // The state of each partition Versions: 0-4
}

// size of LeaderAndIsrTopicState4; Versions: 0-4
func (t LeaderAndIsrTopicState4) Size(version int16) int32 {
	var sz int32
	if version >= 2 {
		sz += sizeof.String(t.TopicName) // TopicName
	}
	if version >= 2 {
		sz += sizeof.ArrayLength // PartitionStates
		for i := len(t.PartitionStates) - 1; i >= 0; i-- {
			sz += t.PartitionStates[i].Size(version)
		}
	}
	return sz
}

// encode LeaderAndIsrTopicState4; Versions: 0-4
func (t LeaderAndIsrTopicState4) Encode(e *protocol.Encoder, version int16) {
	if version >= 2 {
		e.PutString(t.TopicName) // TopicName
	}
	if version >= 2 {
		// PartitionStates
		len1 := len(t.PartitionStates)
		e.PutArrayLength(len1)
		for i := 0; i < len1; i++ {
			t.PartitionStates[i].Encode(e, version)
		}
	}
}

// decode LeaderAndIsrTopicState4; Versions: 0-4
func (t *LeaderAndIsrTopicState4) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 2 {
		t.TopicName, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 2 {
		// PartitionStates
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.PartitionStates = make([]LeaderAndIsrPartitionState4, n)
			for i := 0; i < n; i++ {
				var item LeaderAndIsrPartitionState4
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.PartitionStates[i] = item
			}
		}
	}
	return err
}

type LeaderAndIsrLiveLeader4 struct {
	BrokerId int32  // The leader's broker ID. Versions: 0-4
	HostName string // The leader's hostname. Versions: 0-4
	Port     int32  // The leader's port. Versions: 0-4
}

// size of LeaderAndIsrLiveLeader4; Versions: 0-4
func (t LeaderAndIsrLiveLeader4) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32              // BrokerId
	sz += sizeof.String(t.HostName) // HostName
	sz += sizeof.Int32              // Port
	return sz
}

// encode LeaderAndIsrLiveLeader4; Versions: 0-4
func (t LeaderAndIsrLiveLeader4) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.BrokerId)  // BrokerId
	e.PutString(t.HostName) // HostName
	e.PutInt32(t.Port)      // Port
}

// decode LeaderAndIsrLiveLeader4; Versions: 0-4
func (t *LeaderAndIsrLiveLeader4) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.BrokerId, err = d.Int32()
	if err != nil {
		return err
	}
	t.HostName, err = d.String()
	if err != nil {
		return err
	}
	t.Port, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

type LeaderAndIsrPartitionState4 struct {
	TopicName        string  // The topic name.  This is only present in v0 or v1. Versions: 0-4
	PartitionIndex   int32   // The partition index. Versions: 0-4
	ControllerEpoch  int32   // The controller epoch. Versions: 0-4
	Leader           int32   // The broker ID of the leader. Versions: 0-4
	LeaderEpoch      int32   // The leader epoch. Versions: 0-4
	Isr              []int32 // The in-sync replica IDs. Versions: 0-4
	ZkVersion        int32   // The ZooKeeper version. Versions: 0-4
	Replicas         []int32 // The replica IDs. Versions: 0-4
	AddingReplicas   []int32 // The replica IDs that we are adding this partition to, or null if no replicas are being added. Versions: 0-4
	RemovingReplicas []int32 // The replica IDs that we are removing this partition from, or null if no replicas are being removed. Versions: 0-4
	IsNew            bool    // Whether the replica should have existed on the broker or not. Versions: 0-4
}

// size of LeaderAndIsrPartitionState4; Versions: 0-4
func (t LeaderAndIsrPartitionState4) Size(version int16) int32 {
	var sz int32
	if version >= 0 && version <= 1 {
		sz += sizeof.String(t.TopicName) // TopicName
	}
	sz += sizeof.Int32                  // PartitionIndex
	sz += sizeof.Int32                  // ControllerEpoch
	sz += sizeof.Int32                  // Leader
	sz += sizeof.Int32                  // LeaderEpoch
	sz += sizeof.Int32Array(t.Isr)      // Isr
	sz += sizeof.Int32                  // ZkVersion
	sz += sizeof.Int32Array(t.Replicas) // Replicas
	if version >= 3 {
		sz += sizeof.Int32Array(t.AddingReplicas) // AddingReplicas
	}
	if version >= 3 {
		sz += sizeof.Int32Array(t.RemovingReplicas) // RemovingReplicas
	}
	if version >= 1 {
		sz += sizeof.Bool // IsNew
	}
	return sz
}

// encode LeaderAndIsrPartitionState4; Versions: 0-4
func (t LeaderAndIsrPartitionState4) Encode(e *protocol.Encoder, version int16) {
	if version >= 0 && version <= 1 {
		e.PutString(t.TopicName) // TopicName
	}
	e.PutInt32(t.PartitionIndex)  // PartitionIndex
	e.PutInt32(t.ControllerEpoch) // ControllerEpoch
	e.PutInt32(t.Leader)          // Leader
	e.PutInt32(t.LeaderEpoch)     // LeaderEpoch
	e.PutInt32Array(t.Isr)        // Isr
	e.PutInt32(t.ZkVersion)       // ZkVersion
	e.PutInt32Array(t.Replicas)   // Replicas
	if version >= 3 {
		e.PutInt32Array(t.AddingReplicas) // AddingReplicas
	}
	if version >= 3 {
		e.PutInt32Array(t.RemovingReplicas) // RemovingReplicas
	}
	if version >= 1 {
		e.PutBool(t.IsNew) // IsNew
	}
}

// decode LeaderAndIsrPartitionState4; Versions: 0-4
func (t *LeaderAndIsrPartitionState4) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 0 && version <= 1 {
		t.TopicName, err = d.String()
		if err != nil {
			return err
		}
	}
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ControllerEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	t.Leader, err = d.Int32()
	if err != nil {
		return err
	}
	t.LeaderEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	t.Isr, err = d.Int32Array()
	if err != nil {
		return err
	}
	t.ZkVersion, err = d.Int32()
	if err != nil {
		return err
	}
	t.Replicas, err = d.Int32Array()
	if err != nil {
		return err
	}
	if version >= 3 {
		t.AddingReplicas, err = d.Int32Array()
		if err != nil {
			return err
		}
	}
	if version >= 3 {
		t.RemovingReplicas, err = d.Int32Array()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.IsNew, err = d.Bool()
		if err != nil {
			return err
		}
	}
	return err
}

// LeaderAndIsrResponse; ApiKey: 4, Versions: 0-4
type LeaderAndIsrResponse struct {
	ErrorCode       int16                         // The error code, or 0 if there was no error. Versions: 0-4
	PartitionErrors []LeaderAndIsrPartitionError4 // Each partition. Versions: 0-4
}

// size of LeaderAndIsrResponse; Versions: 0-4
func (t LeaderAndIsrResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16       // ErrorCode
	sz += sizeof.ArrayLength // PartitionErrors
	for i := len(t.PartitionErrors) - 1; i >= 0; i-- {
		sz += t.PartitionErrors[i].Size(version)
	}
	return sz
}

// encode LeaderAndIsrResponse; Versions: 0-4
func (t LeaderAndIsrResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
	// PartitionErrors
	len1 := len(t.PartitionErrors)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.PartitionErrors[i].Encode(e, version)
	}
}

// decode LeaderAndIsrResponse; Versions: 0-4
func (t *LeaderAndIsrResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	// PartitionErrors
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.PartitionErrors = make([]LeaderAndIsrPartitionError4, n)
		for i := 0; i < n; i++ {
			var item LeaderAndIsrPartitionError4
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.PartitionErrors[i] = item
		}
	}
	return err
}

type LeaderAndIsrPartitionError4 struct {
	TopicName      string // The topic name. Versions: 0-4
	PartitionIndex int32  // The partition index. Versions: 0-4
	ErrorCode      int16  // The partition error code, or 0 if there was no error. Versions: 0-4
}

// size of LeaderAndIsrPartitionError4; Versions: 0-4
func (t LeaderAndIsrPartitionError4) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TopicName) // TopicName
	sz += sizeof.Int32               // PartitionIndex
	sz += sizeof.Int16               // ErrorCode
	return sz
}

// encode LeaderAndIsrPartitionError4; Versions: 0-4
func (t LeaderAndIsrPartitionError4) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TopicName)     // TopicName
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode LeaderAndIsrPartitionError4; Versions: 0-4
func (t *LeaderAndIsrPartitionError4) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TopicName, err = d.String()
	if err != nil {
		return err
	}
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// StopReplicaRequest; ApiKey: 5, Versions: 0-2
type StopReplicaRequest struct {
	ControllerId        int32                     // The controller id. Versions: 0-2
	ControllerEpoch     int32                     // The controller epoch. Versions: 0-2
	BrokerEpoch         int64                     // The broker epoch. Versions: 0-2
	DeletePartitions    bool                      // Whether these partitions should be deleted. Versions: 0-2
	UngroupedPartitions []StopReplicaPartitionV05 // The partitions to stop. Versions: 0-2
	Topics              []StopReplicaTopic5       // The topics to stop. Versions: 0-2
}

// size of StopReplicaRequest; Versions: 0-2
func (t StopReplicaRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ControllerId
	sz += sizeof.Int32 // ControllerEpoch
	if version >= 1 {
		sz += sizeof.Int64 // BrokerEpoch
	}
	sz += sizeof.Bool // DeletePartitions
	if version >= 0 && version <= 0 {
		sz += sizeof.ArrayLength // UngroupedPartitions
		for i := len(t.UngroupedPartitions) - 1; i >= 0; i-- {
			sz += t.UngroupedPartitions[i].Size(version)
		}
	}
	if version >= 1 {
		sz += sizeof.ArrayLength // Topics
		for i := len(t.Topics) - 1; i >= 0; i-- {
			sz += t.Topics[i].Size(version)
		}
	}
	return sz
}

// encode StopReplicaRequest; Versions: 0-2
func (t StopReplicaRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ControllerId)    // ControllerId
	e.PutInt32(t.ControllerEpoch) // ControllerEpoch
	if version >= 1 {
		e.PutInt64(t.BrokerEpoch) // BrokerEpoch
	}
	e.PutBool(t.DeletePartitions) // DeletePartitions
	if version >= 0 && version <= 0 {
		// UngroupedPartitions
		len4 := len(t.UngroupedPartitions)
		e.PutArrayLength(len4)
		for i := 0; i < len4; i++ {
			t.UngroupedPartitions[i].Encode(e, version)
		}
	}
	if version >= 1 {
		// Topics
		len5 := len(t.Topics)
		e.PutArrayLength(len5)
		for i := 0; i < len5; i++ {
			t.Topics[i].Encode(e, version)
		}
	}
}

// decode StopReplicaRequest; Versions: 0-2
func (t *StopReplicaRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ControllerId, err = d.Int32()
	if err != nil {
		return err
	}
	t.ControllerEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.BrokerEpoch, err = d.Int64()
		if err != nil {
			return err
		}
	}
	t.DeletePartitions, err = d.Bool()
	if err != nil {
		return err
	}
	if version >= 0 && version <= 0 {
		// UngroupedPartitions
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.UngroupedPartitions = make([]StopReplicaPartitionV05, n)
			for i := 0; i < n; i++ {
				var item StopReplicaPartitionV05
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.UngroupedPartitions[i] = item
			}
		}
	}
	if version >= 1 {
		// Topics
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Topics = make([]StopReplicaTopic5, n)
			for i := 0; i < n; i++ {
				var item StopReplicaTopic5
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.Topics[i] = item
			}
		}
	}
	return err
}

type StopReplicaPartitionV05 struct {
	TopicName      string // The topic name. Versions: 0-2
	PartitionIndex int32  // The partition index. Versions: 0-2
}

// size of StopReplicaPartitionV05; Versions: 0-2
func (t StopReplicaPartitionV05) Size(version int16) int32 {
	var sz int32
	if version >= 0 && version <= 0 {
		sz += sizeof.String(t.TopicName) // TopicName
	}
	if version >= 0 && version <= 0 {
		sz += sizeof.Int32 // PartitionIndex
	}
	return sz
}

// encode StopReplicaPartitionV05; Versions: 0-2
func (t StopReplicaPartitionV05) Encode(e *protocol.Encoder, version int16) {
	if version >= 0 && version <= 0 {
		e.PutString(t.TopicName) // TopicName
	}
	if version >= 0 && version <= 0 {
		e.PutInt32(t.PartitionIndex) // PartitionIndex
	}
}

// decode StopReplicaPartitionV05; Versions: 0-2
func (t *StopReplicaPartitionV05) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 0 && version <= 0 {
		t.TopicName, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 0 && version <= 0 {
		t.PartitionIndex, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}

type StopReplicaTopic5 struct {
	Name             string  // The topic name. Versions: 0-2
	PartitionIndexes []int32 // The partition indexes. Versions: 0-2
}

// size of StopReplicaTopic5; Versions: 0-2
func (t StopReplicaTopic5) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.String(t.Name) // Name
	}
	if version >= 1 {
		sz += sizeof.Int32Array(t.PartitionIndexes) // PartitionIndexes
	}
	return sz
}

// encode StopReplicaTopic5; Versions: 0-2
func (t StopReplicaTopic5) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutString(t.Name) // Name
	}
	if version >= 1 {
		e.PutInt32Array(t.PartitionIndexes) // PartitionIndexes
	}
}

// decode StopReplicaTopic5; Versions: 0-2
func (t *StopReplicaTopic5) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.Name, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.PartitionIndexes, err = d.Int32Array()
		if err != nil {
			return err
		}
	}
	return err
}

// StopReplicaResponse; ApiKey: 5, Versions: 0-2
type StopReplicaResponse struct {
	ErrorCode       int16                        // The top-level error code, or 0 if there was no top-level error. Versions: 0-2
	PartitionErrors []StopReplicaPartitionError5 // The responses for each partition. Versions: 0-2
}

// size of StopReplicaResponse; Versions: 0-2
func (t StopReplicaResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16       // ErrorCode
	sz += sizeof.ArrayLength // PartitionErrors
	for i := len(t.PartitionErrors) - 1; i >= 0; i-- {
		sz += t.PartitionErrors[i].Size(version)
	}
	return sz
}

// encode StopReplicaResponse; Versions: 0-2
func (t StopReplicaResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
	// PartitionErrors
	len1 := len(t.PartitionErrors)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.PartitionErrors[i].Encode(e, version)
	}
}

// decode StopReplicaResponse; Versions: 0-2
func (t *StopReplicaResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	// PartitionErrors
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.PartitionErrors = make([]StopReplicaPartitionError5, n)
		for i := 0; i < n; i++ {
			var item StopReplicaPartitionError5
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.PartitionErrors[i] = item
		}
	}
	return err
}

type StopReplicaPartitionError5 struct {
	TopicName      string // The topic name. Versions: 0-2
	PartitionIndex int32  // The partition index. Versions: 0-2
	ErrorCode      int16  // The partition error code, or 0 if there was no partition error. Versions: 0-2
}

// size of StopReplicaPartitionError5; Versions: 0-2
func (t StopReplicaPartitionError5) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TopicName) // TopicName
	sz += sizeof.Int32               // PartitionIndex
	sz += sizeof.Int16               // ErrorCode
	return sz
}

// encode StopReplicaPartitionError5; Versions: 0-2
func (t StopReplicaPartitionError5) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TopicName)     // TopicName
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode StopReplicaPartitionError5; Versions: 0-2
func (t *StopReplicaPartitionError5) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TopicName, err = d.String()
	if err != nil {
		return err
	}
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// UpdateMetadataRequest; ApiKey: 6, Versions: 0-6
type UpdateMetadataRequest struct {
	ControllerId             int32                           // The controller id. Versions: 0-6
	ControllerEpoch          int32                           // The controller epoch. Versions: 0-6
	BrokerEpoch              int64                           // The broker epoch. Versions: 0-6
	UngroupedPartitionStates []UpdateMetadataPartitionState6 // In older versions of this RPC, each partition that we would like to update. Versions: 0-6
	TopicStates              []UpdateMetadataTopicState6     // In newer versions of this RPC, each topic that we would like to update. Versions: 0-6
	LiveBrokers              []UpdateMetadataBroker6         // Versions: 0-6
}

// size of UpdateMetadataRequest; Versions: 0-6
func (t UpdateMetadataRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ControllerId
	sz += sizeof.Int32 // ControllerEpoch
	if version >= 5 {
		sz += sizeof.Int64 // BrokerEpoch
	}
	if version >= 0 && version <= 4 {
		sz += sizeof.ArrayLength // UngroupedPartitionStates
		for i := len(t.UngroupedPartitionStates) - 1; i >= 0; i-- {
			sz += t.UngroupedPartitionStates[i].Size(version)
		}
	}
	if version >= 5 {
		sz += sizeof.ArrayLength // TopicStates
		for i := len(t.TopicStates) - 1; i >= 0; i-- {
			sz += t.TopicStates[i].Size(version)
		}
	}
	sz += sizeof.ArrayLength // LiveBrokers
	for i := len(t.LiveBrokers) - 1; i >= 0; i-- {
		sz += t.LiveBrokers[i].Size(version)
	}
	return sz
}

// encode UpdateMetadataRequest; Versions: 0-6
func (t UpdateMetadataRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ControllerId)    // ControllerId
	e.PutInt32(t.ControllerEpoch) // ControllerEpoch
	if version >= 5 {
		e.PutInt64(t.BrokerEpoch) // BrokerEpoch
	}
	if version >= 0 && version <= 4 {
		// UngroupedPartitionStates
		len3 := len(t.UngroupedPartitionStates)
		e.PutArrayLength(len3)
		for i := 0; i < len3; i++ {
			t.UngroupedPartitionStates[i].Encode(e, version)
		}
	}
	if version >= 5 {
		// TopicStates
		len4 := len(t.TopicStates)
		e.PutArrayLength(len4)
		for i := 0; i < len4; i++ {
			t.TopicStates[i].Encode(e, version)
		}
	}
	// LiveBrokers
	len5 := len(t.LiveBrokers)
	e.PutArrayLength(len5)
	for i := 0; i < len5; i++ {
		t.LiveBrokers[i].Encode(e, version)
	}
}

// decode UpdateMetadataRequest; Versions: 0-6
func (t *UpdateMetadataRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ControllerId, err = d.Int32()
	if err != nil {
		return err
	}
	t.ControllerEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 5 {
		t.BrokerEpoch, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 0 && version <= 4 {
		// UngroupedPartitionStates
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.UngroupedPartitionStates = make([]UpdateMetadataPartitionState6, n)
			for i := 0; i < n; i++ {
				var item UpdateMetadataPartitionState6
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.UngroupedPartitionStates[i] = item
			}
		}
	}
	if version >= 5 {
		// TopicStates
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.TopicStates = make([]UpdateMetadataTopicState6, n)
			for i := 0; i < n; i++ {
				var item UpdateMetadataTopicState6
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.TopicStates[i] = item
			}
		}
	}
	// LiveBrokers
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.LiveBrokers = make([]UpdateMetadataBroker6, n)
		for i := 0; i < n; i++ {
			var item UpdateMetadataBroker6
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.LiveBrokers[i] = item
		}
	}
	return err
}

type UpdateMetadataTopicState6 struct {
	TopicName       string                          // The topic name. Versions: 0-6
	PartitionStates []UpdateMetadataPartitionState6 // The partition that we would like to update. Versions: 0-6
}

// size of UpdateMetadataTopicState6; Versions: 0-6
func (t UpdateMetadataTopicState6) Size(version int16) int32 {
	var sz int32
	if version >= 5 {
		sz += sizeof.String(t.TopicName) // TopicName
	}
	if version >= 5 {
		sz += sizeof.ArrayLength // PartitionStates
		for i := len(t.PartitionStates) - 1; i >= 0; i-- {
			sz += t.PartitionStates[i].Size(version)
		}
	}
	return sz
}

// encode UpdateMetadataTopicState6; Versions: 0-6
func (t UpdateMetadataTopicState6) Encode(e *protocol.Encoder, version int16) {
	if version >= 5 {
		e.PutString(t.TopicName) // TopicName
	}
	if version >= 5 {
		// PartitionStates
		len1 := len(t.PartitionStates)
		e.PutArrayLength(len1)
		for i := 0; i < len1; i++ {
			t.PartitionStates[i].Encode(e, version)
		}
	}
}

// decode UpdateMetadataTopicState6; Versions: 0-6
func (t *UpdateMetadataTopicState6) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 5 {
		t.TopicName, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		// PartitionStates
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.PartitionStates = make([]UpdateMetadataPartitionState6, n)
			for i := 0; i < n; i++ {
				var item UpdateMetadataPartitionState6
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.PartitionStates[i] = item
			}
		}
	}
	return err
}

type UpdateMetadataBroker6 struct {
	Id        int32                     // The broker id. Versions: 0-6
	V0Host    string                    // The broker hostname. Versions: 0-6
	V0Port    int32                     // The broker port. Versions: 0-6
	Endpoints []UpdateMetadataEndpoint6 // The broker endpoints. Versions: 0-6
	Rack      string                    // The rack which this broker belongs to. Versions: 0-6
}

// size of UpdateMetadataBroker6; Versions: 0-6
func (t UpdateMetadataBroker6) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // Id
	if version >= 0 && version <= 0 {
		sz += sizeof.String(t.V0Host) // V0Host
	}
	if version >= 0 && version <= 0 {
		sz += sizeof.Int32 // V0Port
	}
	if version >= 1 {
		sz += sizeof.ArrayLength // Endpoints
		for i := len(t.Endpoints) - 1; i >= 0; i-- {
			sz += t.Endpoints[i].Size(version)
		}
	}
	if version >= 2 {
		sz += sizeof.String(t.Rack) // Rack
	}
	return sz
}

// encode UpdateMetadataBroker6; Versions: 0-6
func (t UpdateMetadataBroker6) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.Id) // Id
	if version >= 0 && version <= 0 {
		e.PutString(t.V0Host) // V0Host
	}
	if version >= 0 && version <= 0 {
		e.PutInt32(t.V0Port) // V0Port
	}
	if version >= 1 {
		// Endpoints
		len3 := len(t.Endpoints)
		e.PutArrayLength(len3)
		for i := 0; i < len3; i++ {
			t.Endpoints[i].Encode(e, version)
		}
	}
	if version >= 2 {
		e.PutString(t.Rack) // Rack
	}
}

// decode UpdateMetadataBroker6; Versions: 0-6
func (t *UpdateMetadataBroker6) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Id, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 0 && version <= 0 {
		t.V0Host, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 0 && version <= 0 {
		t.V0Port, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		// Endpoints
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Endpoints = make([]UpdateMetadataEndpoint6, n)
			for i := 0; i < n; i++ {
				var item UpdateMetadataEndpoint6
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.Endpoints[i] = item
			}
		}
	}
	if version >= 2 {
		t.Rack, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

type UpdateMetadataEndpoint6 struct {
	Port             int32  // The port of this endpoint Versions: 0-6
	Host             string // The hostname of this endpoint Versions: 0-6
	Listener         string // The listener name. Versions: 0-6
	SecurityProtocol int16  // The security protocol type. Versions: 0-6
}

// size of UpdateMetadataEndpoint6; Versions: 0-6
func (t UpdateMetadataEndpoint6) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // Port
	}
	if version >= 1 {
		sz += sizeof.String(t.Host) // Host
	}
	if version >= 3 {
		sz += sizeof.String(t.Listener) // Listener
	}
	if version >= 1 {
		sz += sizeof.Int16 // SecurityProtocol
	}
	return sz
}

// encode UpdateMetadataEndpoint6; Versions: 0-6
func (t UpdateMetadataEndpoint6) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.Port) // Port
	}
	if version >= 1 {
		e.PutString(t.Host) // Host
	}
	if version >= 3 {
		e.PutString(t.Listener) // Listener
	}
	if version >= 1 {
		e.PutInt16(t.SecurityProtocol) // SecurityProtocol
	}
}

// decode UpdateMetadataEndpoint6; Versions: 0-6
func (t *UpdateMetadataEndpoint6) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.Port, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.Host, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 3 {
		t.Listener, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.SecurityProtocol, err = d.Int16()
		if err != nil {
			return err
		}
	}
	return err
}

type UpdateMetadataPartitionState6 struct {
	TopicName       string  // In older versions of this RPC, the topic name. Versions: 0-6
	PartitionIndex  int32   // The partition index. Versions: 0-6
	ControllerEpoch int32   // The controller epoch. Versions: 0-6
	Leader          int32   // The ID of the broker which is the current partition leader. Versions: 0-6
	LeaderEpoch     int32   // The leader epoch of this partition. Versions: 0-6
	Isr             []int32 // The brokers which are in the ISR for this partition. Versions: 0-6
	ZkVersion       int32   // The Zookeeper version. Versions: 0-6
	Replicas        []int32 // All the replicas of this partition. Versions: 0-6
	OfflineReplicas []int32 // The replicas of this partition which are offline. Versions: 0-6
}

// size of UpdateMetadataPartitionState6; Versions: 0-6
func (t UpdateMetadataPartitionState6) Size(version int16) int32 {
	var sz int32
	if version >= 0 && version <= 4 {
		sz += sizeof.String(t.TopicName) // TopicName
	}
	sz += sizeof.Int32                  // PartitionIndex
	sz += sizeof.Int32                  // ControllerEpoch
	sz += sizeof.Int32                  // Leader
	sz += sizeof.Int32                  // LeaderEpoch
	sz += sizeof.Int32Array(t.Isr)      // Isr
	sz += sizeof.Int32                  // ZkVersion
	sz += sizeof.Int32Array(t.Replicas) // Replicas
	if version >= 4 {
		sz += sizeof.Int32Array(t.OfflineReplicas) // OfflineReplicas
	}
	return sz
}

// encode UpdateMetadataPartitionState6; Versions: 0-6
func (t UpdateMetadataPartitionState6) Encode(e *protocol.Encoder, version int16) {
	if version >= 0 && version <= 4 {
		e.PutString(t.TopicName) // TopicName
	}
	e.PutInt32(t.PartitionIndex)  // PartitionIndex
	e.PutInt32(t.ControllerEpoch) // ControllerEpoch
	e.PutInt32(t.Leader)          // Leader
	e.PutInt32(t.LeaderEpoch)     // LeaderEpoch
	e.PutInt32Array(t.Isr)        // Isr
	e.PutInt32(t.ZkVersion)       // ZkVersion
	e.PutInt32Array(t.Replicas)   // Replicas
	if version >= 4 {
		e.PutInt32Array(t.OfflineReplicas) // OfflineReplicas
	}
}

// decode UpdateMetadataPartitionState6; Versions: 0-6
func (t *UpdateMetadataPartitionState6) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 0 && version <= 4 {
		t.TopicName, err = d.String()
		if err != nil {
			return err
		}
	}
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ControllerEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	t.Leader, err = d.Int32()
	if err != nil {
		return err
	}
	t.LeaderEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	t.Isr, err = d.Int32Array()
	if err != nil {
		return err
	}
	t.ZkVersion, err = d.Int32()
	if err != nil {
		return err
	}
	t.Replicas, err = d.Int32Array()
	if err != nil {
		return err
	}
	if version >= 4 {
		t.OfflineReplicas, err = d.Int32Array()
		if err != nil {
			return err
		}
	}
	return err
}

// UpdateMetadataResponse; ApiKey: 6, Versions: 0-6
type UpdateMetadataResponse struct {
	ErrorCode int16 // The error code, or 0 if there was no error. Versions: 0-6
}

// size of UpdateMetadataResponse; Versions: 0-6
func (t UpdateMetadataResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode UpdateMetadataResponse; Versions: 0-6
func (t UpdateMetadataResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
}

// decode UpdateMetadataResponse; Versions: 0-6
func (t *UpdateMetadataResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// ControlledShutdownRequest; ApiKey: 7, Versions: 0-3
type ControlledShutdownRequest struct {
	BrokerId    int32 // The id of the broker for which controlled shutdown has been requested. Versions: 0-3
	BrokerEpoch int64 // The broker epoch. Versions: 0-3
}

// size of ControlledShutdownRequest; Versions: 0-3
func (t ControlledShutdownRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // BrokerId
	if version >= 2 {
		sz += sizeof.Int64 // BrokerEpoch
	}
	return sz
}

// encode ControlledShutdownRequest; Versions: 0-3
func (t ControlledShutdownRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.BrokerId) // BrokerId
	if version >= 2 {
		e.PutInt64(t.BrokerEpoch) // BrokerEpoch
	}
}

// decode ControlledShutdownRequest; Versions: 0-3
func (t *ControlledShutdownRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.BrokerId, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 2 {
		t.BrokerEpoch, err = d.Int64()
		if err != nil {
			return err
		}
	}
	return err
}

// ControlledShutdownResponse; ApiKey: 7, Versions: 0-3
type ControlledShutdownResponse struct {
	ErrorCode           int16                 // The top-level error code. Versions: 0-3
	RemainingPartitions []RemainingPartition7 // The partitions that the broker still leads. Versions: 0-3
}

// size of ControlledShutdownResponse; Versions: 0-3
func (t ControlledShutdownResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16       // ErrorCode
	sz += sizeof.ArrayLength // RemainingPartitions
	for i := len(t.RemainingPartitions) - 1; i >= 0; i-- {
		sz += t.RemainingPartitions[i].Size(version)
	}
	return sz
}

// encode ControlledShutdownResponse; Versions: 0-3
func (t ControlledShutdownResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
	// RemainingPartitions
	len1 := len(t.RemainingPartitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.RemainingPartitions[i].Encode(e, version)
	}
}

// decode ControlledShutdownResponse; Versions: 0-3
func (t *ControlledShutdownResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	// RemainingPartitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.RemainingPartitions = make([]RemainingPartition7, n)
		for i := 0; i < n; i++ {
			var item RemainingPartition7
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.RemainingPartitions[i] = item
		}
	}
	return err
}

type RemainingPartition7 struct {
	TopicName      string // The name of the topic. Versions: 0-3
	PartitionIndex int32  // The index of the partition. Versions: 0-3
}

// size of RemainingPartition7; Versions: 0-3
func (t RemainingPartition7) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TopicName) // TopicName
	sz += sizeof.Int32               // PartitionIndex
	return sz
}

// encode RemainingPartition7; Versions: 0-3
func (t RemainingPartition7) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TopicName)     // TopicName
	e.PutInt32(t.PartitionIndex) // PartitionIndex
}

// decode RemainingPartition7; Versions: 0-3
func (t *RemainingPartition7) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TopicName, err = d.String()
	if err != nil {
		return err
	}
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// OffsetCommitRequest; ApiKey: 8, Versions: 0-8
type OffsetCommitRequest struct {
	GroupId         string                      // The unique group identifier. Versions: 0-8
	GenerationId    int32                       // The generation of the group. Versions: 0-8
	MemberId        string                      // The member ID assigned by the group coordinator. Versions: 0-8
	GroupInstanceId string                      // The unique identifier of the consumer instance provided by end user. Versions: 0-8
	RetentionTimeMs int64                       // The time period in ms to retain the offset. Versions: 0-8
	Topics          []OffsetCommitRequestTopic8 // The topics to commit offsets for. Versions: 0-8
}

// size of OffsetCommitRequest; Versions: 0-8
func (t OffsetCommitRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId) // GroupId
	if version >= 1 {
		sz += sizeof.Int32 // GenerationId
	}
	if version >= 1 {
		sz += sizeof.String(t.MemberId) // MemberId
	}
	if version >= 7 {
		sz += sizeof.String(t.GroupInstanceId) // GroupInstanceId
	}
	if version >= 2 && version <= 4 {
		sz += sizeof.Int64 // RetentionTimeMs
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode OffsetCommitRequest; Versions: 0-8
func (t OffsetCommitRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId) // GroupId
	if version >= 1 {
		e.PutInt32(t.GenerationId) // GenerationId
	}
	if version >= 1 {
		e.PutString(t.MemberId) // MemberId
	}
	if version >= 7 {
		e.PutString(t.GroupInstanceId) // GroupInstanceId
	}
	if version >= 2 && version <= 4 {
		e.PutInt64(t.RetentionTimeMs) // RetentionTimeMs
	}
	// Topics
	len5 := len(t.Topics)
	e.PutArrayLength(len5)
	for i := 0; i < len5; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode OffsetCommitRequest; Versions: 0-8
func (t *OffsetCommitRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.GenerationId, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.MemberId, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 7 {
		t.GroupInstanceId, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 2 && version <= 4 {
		t.RetentionTimeMs, err = d.Int64()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OffsetCommitRequestTopic8, n)
		for i := 0; i < n; i++ {
			var item OffsetCommitRequestTopic8
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type OffsetCommitRequestTopic8 struct {
	Name       string                          // The topic name. Versions: 0-8
	Partitions []OffsetCommitRequestPartition8 // Each partition to commit offsets for. Versions: 0-8
}

// size of OffsetCommitRequestTopic8; Versions: 0-8
func (t OffsetCommitRequestTopic8) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode OffsetCommitRequestTopic8; Versions: 0-8
func (t OffsetCommitRequestTopic8) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode OffsetCommitRequestTopic8; Versions: 0-8
func (t *OffsetCommitRequestTopic8) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]OffsetCommitRequestPartition8, n)
		for i := 0; i < n; i++ {
			var item OffsetCommitRequestPartition8
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type OffsetCommitRequestPartition8 struct {
	PartitionIndex       int32  // The partition index. Versions: 0-8
	CommittedOffset      int64  // The message offset to be committed. Versions: 0-8
	CommittedLeaderEpoch int32  // The leader epoch of this partition. Versions: 0-8
	CommittedMetadata    string // Any associated metadata the client wants to keep. Versions: 0-8
}

// size of OffsetCommitRequestPartition8; Versions: 0-8
func (t OffsetCommitRequestPartition8) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int64 // CommittedOffset
	if version >= 6 {
		sz += sizeof.Int32 // CommittedLeaderEpoch
	}
	sz += sizeof.String(t.CommittedMetadata) // CommittedMetadata
	return sz
}

// encode OffsetCommitRequestPartition8; Versions: 0-8
func (t OffsetCommitRequestPartition8) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex)  // PartitionIndex
	e.PutInt64(t.CommittedOffset) // CommittedOffset
	if version >= 6 {
		e.PutInt32(t.CommittedLeaderEpoch) // CommittedLeaderEpoch
	}
	e.PutString(t.CommittedMetadata) // CommittedMetadata
}

// decode OffsetCommitRequestPartition8; Versions: 0-8
func (t *OffsetCommitRequestPartition8) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.CommittedOffset, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 6 {
		t.CommittedLeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.CommittedMetadata, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// OffsetCommitResponse; ApiKey: 8, Versions: 0-8
type OffsetCommitResponse struct {
	ThrottleTimeMs int32                        // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-8
	Topics         []OffsetCommitResponseTopic8 // The responses for each topic. Versions: 0-8
}

// size of OffsetCommitResponse; Versions: 0-8
func (t OffsetCommitResponse) Size(version int16) int32 {
	var sz int32
	if version >= 3 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode OffsetCommitResponse; Versions: 0-8
func (t OffsetCommitResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 3 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode OffsetCommitResponse; Versions: 0-8
func (t *OffsetCommitResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 3 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OffsetCommitResponseTopic8, n)
		for i := 0; i < n; i++ {
			var item OffsetCommitResponseTopic8
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type OffsetCommitResponseTopic8 struct {
	Name       string                           // The topic name. Versions: 0-8
	Partitions []OffsetCommitResponsePartition8 // The responses for each partition in the topic. Versions: 0-8
}

// size of OffsetCommitResponseTopic8; Versions: 0-8
func (t OffsetCommitResponseTopic8) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode OffsetCommitResponseTopic8; Versions: 0-8
func (t OffsetCommitResponseTopic8) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode OffsetCommitResponseTopic8; Versions: 0-8
func (t *OffsetCommitResponseTopic8) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]OffsetCommitResponsePartition8, n)
		for i := 0; i < n; i++ {
			var item OffsetCommitResponsePartition8
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type OffsetCommitResponsePartition8 struct {
	PartitionIndex int32 // The partition index. Versions: 0-8
	ErrorCode      int16 // The error code, or 0 if there was no error. Versions: 0-8
}

// size of OffsetCommitResponsePartition8; Versions: 0-8
func (t OffsetCommitResponsePartition8) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode OffsetCommitResponsePartition8; Versions: 0-8
func (t OffsetCommitResponsePartition8) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode OffsetCommitResponsePartition8; Versions: 0-8
func (t *OffsetCommitResponsePartition8) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// OffsetFetchRequest; ApiKey: 9, Versions: 0-6
type OffsetFetchRequest struct {
	GroupId string                     // The group to fetch offsets for. Versions: 0-6
	Topics  []OffsetFetchRequestTopic9 // Each topic we would like to fetch offsets for, or null to fetch offsets for all topics. Versions: 0-6
}

// size of OffsetFetchRequest; Versions: 0-6
func (t OffsetFetchRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId) // GroupId
	sz += sizeof.ArrayLength       // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode OffsetFetchRequest; Versions: 0-6
func (t OffsetFetchRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId) // GroupId
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode OffsetFetchRequest; Versions: 0-6
func (t *OffsetFetchRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OffsetFetchRequestTopic9, n)
		for i := 0; i < n; i++ {
			var item OffsetFetchRequestTopic9
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type OffsetFetchRequestTopic9 struct {
	Name             string  // The topic name. Versions: 0-6
	PartitionIndexes []int32 // The partition indexes we would like to fetch offsets for. Versions: 0-6
}

// size of OffsetFetchRequestTopic9; Versions: 0-6
func (t OffsetFetchRequestTopic9) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)                 // Name
	sz += sizeof.Int32Array(t.PartitionIndexes) // PartitionIndexes
	return sz
}

// encode OffsetFetchRequestTopic9; Versions: 0-6
func (t OffsetFetchRequestTopic9) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)                 // Name
	e.PutInt32Array(t.PartitionIndexes) // PartitionIndexes
}

// decode OffsetFetchRequestTopic9; Versions: 0-6
func (t *OffsetFetchRequestTopic9) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.PartitionIndexes, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// OffsetFetchResponse; ApiKey: 9, Versions: 0-6
type OffsetFetchResponse struct {
	ThrottleTimeMs int32                       // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-6
	Topics         []OffsetFetchResponseTopic9 // The responses per topic. Versions: 0-6
	ErrorCode      int16                       // The top-level error code, or 0 if there was no error. Versions: 0-6
}

// size of OffsetFetchResponse; Versions: 0-6
func (t OffsetFetchResponse) Size(version int16) int32 {
	var sz int32
	if version >= 3 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	if version >= 2 {
		sz += sizeof.Int16 // ErrorCode
	}
	return sz
}

// encode OffsetFetchResponse; Versions: 0-6
func (t OffsetFetchResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 3 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
	if version >= 2 {
		e.PutInt16(t.ErrorCode) // ErrorCode
	}
}

// decode OffsetFetchResponse; Versions: 0-6
func (t *OffsetFetchResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 3 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OffsetFetchResponseTopic9, n)
		for i := 0; i < n; i++ {
			var item OffsetFetchResponseTopic9
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	if version >= 2 {
		t.ErrorCode, err = d.Int16()
		if err != nil {
			return err
		}
	}
	return err
}

type OffsetFetchResponseTopic9 struct {
	Name       string                          // The topic name. Versions: 0-6
	Partitions []OffsetFetchResponsePartition9 // The responses per partition Versions: 0-6
}

// size of OffsetFetchResponseTopic9; Versions: 0-6
func (t OffsetFetchResponseTopic9) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode OffsetFetchResponseTopic9; Versions: 0-6
func (t OffsetFetchResponseTopic9) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode OffsetFetchResponseTopic9; Versions: 0-6
func (t *OffsetFetchResponseTopic9) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]OffsetFetchResponsePartition9, n)
		for i := 0; i < n; i++ {
			var item OffsetFetchResponsePartition9
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type OffsetFetchResponsePartition9 struct {
	PartitionIndex       int32  // The partition index. Versions: 0-6
	CommittedOffset      int64  // The committed message offset. Versions: 0-6
	CommittedLeaderEpoch int32  // The leader epoch. Versions: 0-6
	Metadata             string // The partition metadata. Versions: 0-6
	ErrorCode            int16  // The error code, or 0 if there was no error. Versions: 0-6
}

// size of OffsetFetchResponsePartition9; Versions: 0-6
func (t OffsetFetchResponsePartition9) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int64 // CommittedOffset
	if version >= 5 {
		sz += sizeof.Int32 // CommittedLeaderEpoch
	}
	sz += sizeof.String(t.Metadata) // Metadata
	sz += sizeof.Int16              // ErrorCode
	return sz
}

// encode OffsetFetchResponsePartition9; Versions: 0-6
func (t OffsetFetchResponsePartition9) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex)  // PartitionIndex
	e.PutInt64(t.CommittedOffset) // CommittedOffset
	if version >= 5 {
		e.PutInt32(t.CommittedLeaderEpoch) // CommittedLeaderEpoch
	}
	e.PutString(t.Metadata) // Metadata
	e.PutInt16(t.ErrorCode) // ErrorCode
}

// decode OffsetFetchResponsePartition9; Versions: 0-6
func (t *OffsetFetchResponsePartition9) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.CommittedOffset, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 5 {
		t.CommittedLeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.Metadata, err = d.String()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// FindCoordinatorRequest; ApiKey: 10, Versions: 0-3
type FindCoordinatorRequest struct {
	Key     string // The coordinator key. Versions: 0-3
	KeyType int8   // The coordinator key type.  (Group, transaction, etc.) Versions: 0-3
}

// size of FindCoordinatorRequest; Versions: 0-3
func (t FindCoordinatorRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Key) // Key
	if version >= 1 {
		sz += sizeof.Int8 // KeyType
	}
	return sz
}

// encode FindCoordinatorRequest; Versions: 0-3
func (t FindCoordinatorRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Key) // Key
	if version >= 1 {
		e.PutInt8(t.KeyType) // KeyType
	}
}

// decode FindCoordinatorRequest; Versions: 0-3
func (t *FindCoordinatorRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Key, err = d.String()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.KeyType, err = d.Int8()
		if err != nil {
			return err
		}
	}
	return err
}

// FindCoordinatorResponse; ApiKey: 10, Versions: 0-3
type FindCoordinatorResponse struct {
	ThrottleTimeMs int32  // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-3
	ErrorCode      int16  // The error code, or 0 if there was no error. Versions: 0-3
	ErrorMessage   string // The error message, or null if there was no error. Versions: 0-3
	NodeId         int32  // The node id. Versions: 0-3
	Host           string // The host name. Versions: 0-3
	Port           int32  // The port. Versions: 0-3
}

// size of FindCoordinatorResponse; Versions: 0-3
func (t FindCoordinatorResponse) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.Int16 // ErrorCode
	if version >= 1 {
		sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	}
	sz += sizeof.Int32          // NodeId
	sz += sizeof.String(t.Host) // Host
	sz += sizeof.Int32          // Port
	return sz
}

// encode FindCoordinatorResponse; Versions: 0-3
func (t FindCoordinatorResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	e.PutInt16(t.ErrorCode) // ErrorCode
	if version >= 1 {
		e.PutString(t.ErrorMessage) // ErrorMessage
	}
	e.PutInt32(t.NodeId) // NodeId
	e.PutString(t.Host)  // Host
	e.PutInt32(t.Port)   // Port
}

// decode FindCoordinatorResponse; Versions: 0-3
func (t *FindCoordinatorResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.ErrorMessage, err = d.String()
		if err != nil {
			return err
		}
	}
	t.NodeId, err = d.Int32()
	if err != nil {
		return err
	}
	t.Host, err = d.String()
	if err != nil {
		return err
	}
	t.Port, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// JoinGroupRequest; ApiKey: 11, Versions: 0-6
type JoinGroupRequest struct {
	GroupId            string                       // The group identifier. Versions: 0-6
	SessionTimeoutMs   int32                        // The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds. Versions: 0-6
	RebalanceTimeoutMs int32                        // The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group. Versions: 0-6
	MemberId           string                       // The member id assigned by the group coordinator. Versions: 0-6
	GroupInstanceId    string                       // The unique identifier of the consumer instance provided by end user. Versions: 0-6
	ProtocolType       string                       // The unique name the for class of protocols implemented by the group we want to join. Versions: 0-6
	Protocols          []JoinGroupRequestProtocol11 // The list of protocols that the member supports. Versions: 0-6
}

// size of JoinGroupRequest; Versions: 0-6
func (t JoinGroupRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId) // GroupId
	sz += sizeof.Int32             // SessionTimeoutMs
	if version >= 1 {
		sz += sizeof.Int32 // RebalanceTimeoutMs
	}
	sz += sizeof.String(t.MemberId) // MemberId
	if version >= 5 {
		sz += sizeof.String(t.GroupInstanceId) // GroupInstanceId
	}
	sz += sizeof.String(t.ProtocolType) // ProtocolType
	sz += sizeof.ArrayLength            // Protocols
	for i := len(t.Protocols) - 1; i >= 0; i-- {
		sz += t.Protocols[i].Size(version)
	}
	return sz
}

// encode JoinGroupRequest; Versions: 0-6
func (t JoinGroupRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId)         // GroupId
	e.PutInt32(t.SessionTimeoutMs) // SessionTimeoutMs
	if version >= 1 {
		e.PutInt32(t.RebalanceTimeoutMs) // RebalanceTimeoutMs
	}
	e.PutString(t.MemberId) // MemberId
	if version >= 5 {
		e.PutString(t.GroupInstanceId) // GroupInstanceId
	}
	e.PutString(t.ProtocolType) // ProtocolType
	// Protocols
	len6 := len(t.Protocols)
	e.PutArrayLength(len6)
	for i := 0; i < len6; i++ {
		t.Protocols[i].Encode(e, version)
	}
}

// decode JoinGroupRequest; Versions: 0-6
func (t *JoinGroupRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	t.SessionTimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.RebalanceTimeoutMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.MemberId, err = d.String()
	if err != nil {
		return err
	}
	if version >= 5 {
		t.GroupInstanceId, err = d.String()
		if err != nil {
			return err
		}
	}
	t.ProtocolType, err = d.String()
	if err != nil {
		return err
	}
	// Protocols
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Protocols = make([]JoinGroupRequestProtocol11, n)
		for i := 0; i < n; i++ {
			var item JoinGroupRequestProtocol11
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Protocols[i] = item
		}
	}
	return err
}

type JoinGroupRequestProtocol11 struct {
	Name     string // The protocol name. Versions: 0-6
	Metadata []byte // The protocol metadata. Versions: 0-6
}

// size of JoinGroupRequestProtocol11; Versions: 0-6
func (t JoinGroupRequestProtocol11) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)    // Name
	sz += sizeof.Bytes(t.Metadata) // Metadata
	return sz
}

// encode JoinGroupRequestProtocol11; Versions: 0-6
func (t JoinGroupRequestProtocol11) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)    // Name
	e.PutBytes(t.Metadata) // Metadata
}

// decode JoinGroupRequestProtocol11; Versions: 0-6
func (t *JoinGroupRequestProtocol11) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.Metadata, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

// JoinGroupResponse; ApiKey: 11, Versions: 0-6
type JoinGroupResponse struct {
	ThrottleTimeMs int32                       // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-6
	ErrorCode      int16                       // The error code, or 0 if there was no error. Versions: 0-6
	GenerationId   int32                       // The generation ID of the group. Versions: 0-6
	ProtocolName   string                      // The group protocol selected by the coordinator. Versions: 0-6
	Leader         string                      // The leader of the group. Versions: 0-6
	MemberId       string                      // The member ID assigned by the group coordinator. Versions: 0-6
	Members        []JoinGroupResponseMember11 // Versions: 0-6
}

// size of JoinGroupResponse; Versions: 0-6
func (t JoinGroupResponse) Size(version int16) int32 {
	var sz int32
	if version >= 2 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.Int32                  // GenerationId
	sz += sizeof.String(t.ProtocolName) // ProtocolName
	sz += sizeof.String(t.Leader)       // Leader
	sz += sizeof.String(t.MemberId)     // MemberId
	sz += sizeof.ArrayLength            // Members
	for i := len(t.Members) - 1; i >= 0; i-- {
		sz += t.Members[i].Size(version)
	}
	return sz
}

// encode JoinGroupResponse; Versions: 0-6
func (t JoinGroupResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 2 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutInt32(t.GenerationId)  // GenerationId
	e.PutString(t.ProtocolName) // ProtocolName
	e.PutString(t.Leader)       // Leader
	e.PutString(t.MemberId)     // MemberId
	// Members
	len6 := len(t.Members)
	e.PutArrayLength(len6)
	for i := 0; i < len6; i++ {
		t.Members[i].Encode(e, version)
	}
}

// decode JoinGroupResponse; Versions: 0-6
func (t *JoinGroupResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 2 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.GenerationId, err = d.Int32()
	if err != nil {
		return err
	}
	t.ProtocolName, err = d.String()
	if err != nil {
		return err
	}
	t.Leader, err = d.String()
	if err != nil {
		return err
	}
	t.MemberId, err = d.String()
	if err != nil {
		return err
	}
	// Members
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Members = make([]JoinGroupResponseMember11, n)
		for i := 0; i < n; i++ {
			var item JoinGroupResponseMember11
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Members[i] = item
		}
	}
	return err
}

type JoinGroupResponseMember11 struct {
	MemberId        string // The group member ID. Versions: 0-6
	GroupInstanceId string // The unique identifier of the consumer instance provided by end user. Versions: 0-6
	Metadata        []byte // The group member metadata. Versions: 0-6
}

// size of JoinGroupResponseMember11; Versions: 0-6
func (t JoinGroupResponseMember11) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.MemberId) // MemberId
	if version >= 5 {
		sz += sizeof.String(t.GroupInstanceId) // GroupInstanceId
	}
	sz += sizeof.Bytes(t.Metadata) // Metadata
	return sz
}

// encode JoinGroupResponseMember11; Versions: 0-6
func (t JoinGroupResponseMember11) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.MemberId) // MemberId
	if version >= 5 {
		e.PutString(t.GroupInstanceId) // GroupInstanceId
	}
	e.PutBytes(t.Metadata) // Metadata
}

// decode JoinGroupResponseMember11; Versions: 0-6
func (t *JoinGroupResponseMember11) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.MemberId, err = d.String()
	if err != nil {
		return err
	}
	if version >= 5 {
		t.GroupInstanceId, err = d.String()
		if err != nil {
			return err
		}
	}
	t.Metadata, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

// HeartbeatRequest; ApiKey: 12, Versions: 0-4
type HeartbeatRequest struct {
	GroupId         string // The group id. Versions: 0-4
	GenerationId    int32  // The generation of the group. Versions: 0-4
	MemberId        string // The member ID. Versions: 0-4
	GroupInstanceId string // The unique identifier of the consumer instance provided by end user. Versions: 0-4
}

// size of HeartbeatRequest; Versions: 0-4
func (t HeartbeatRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId)  // GroupId
	sz += sizeof.Int32              // GenerationId
	sz += sizeof.String(t.MemberId) // MemberId
	if version >= 3 {
		sz += sizeof.String(t.GroupInstanceId) // GroupInstanceId
	}
	return sz
}

// encode HeartbeatRequest; Versions: 0-4
func (t HeartbeatRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId)     // GroupId
	e.PutInt32(t.GenerationId) // GenerationId
	e.PutString(t.MemberId)    // MemberId
	if version >= 3 {
		e.PutString(t.GroupInstanceId) // GroupInstanceId
	}
}

// decode HeartbeatRequest; Versions: 0-4
func (t *HeartbeatRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	t.GenerationId, err = d.Int32()
	if err != nil {
		return err
	}
	t.MemberId, err = d.String()
	if err != nil {
		return err
	}
	if version >= 3 {
		t.GroupInstanceId, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

// HeartbeatResponse; ApiKey: 12, Versions: 0-4
type HeartbeatResponse struct {
	ThrottleTimeMs int32 // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-4
	ErrorCode      int16 // The error code, or 0 if there was no error. Versions: 0-4
}

// size of HeartbeatResponse; Versions: 0-4
func (t HeartbeatResponse) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode HeartbeatResponse; Versions: 0-4
func (t HeartbeatResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	e.PutInt16(t.ErrorCode) // ErrorCode
}

// decode HeartbeatResponse; Versions: 0-4
func (t *HeartbeatResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// LeaveGroupRequest; ApiKey: 13, Versions: 0-4
type LeaveGroupRequest struct {
	GroupId  string             // The ID of the group to leave. Versions: 0-4
	MemberId string             // The member ID to remove from the group. Versions: 0-4
	Members  []MemberIdentity13 // List of leaving member identities. Versions: 0-4
}

// size of LeaveGroupRequest; Versions: 0-4
func (t LeaveGroupRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId) // GroupId
	if version >= 0 && version <= 2 {
		sz += sizeof.String(t.MemberId) // MemberId
	}
	if version >= 3 {
		sz += sizeof.ArrayLength // Members
		for i := len(t.Members) - 1; i >= 0; i-- {
			sz += t.Members[i].Size(version)
		}
	}
	return sz
}

// encode LeaveGroupRequest; Versions: 0-4
func (t LeaveGroupRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId) // GroupId
	if version >= 0 && version <= 2 {
		e.PutString(t.MemberId) // MemberId
	}
	if version >= 3 {
		// Members
		len2 := len(t.Members)
		e.PutArrayLength(len2)
		for i := 0; i < len2; i++ {
			t.Members[i].Encode(e, version)
		}
	}
}

// decode LeaveGroupRequest; Versions: 0-4
func (t *LeaveGroupRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	if version >= 0 && version <= 2 {
		t.MemberId, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 3 {
		// Members
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Members = make([]MemberIdentity13, n)
			for i := 0; i < n; i++ {
				var item MemberIdentity13
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.Members[i] = item
			}
		}
	}
	return err
}

type MemberIdentity13 struct {
	MemberId        string // The member ID to remove from the group. Versions: 0-4
	GroupInstanceId string // The group instance ID to remove from the group. Versions: 0-4
}

// size of MemberIdentity13; Versions: 0-4
func (t MemberIdentity13) Size(version int16) int32 {
	var sz int32
	if version >= 3 {
		sz += sizeof.String(t.MemberId) // MemberId
	}
	if version >= 3 {
		sz += sizeof.String(t.GroupInstanceId) // GroupInstanceId
	}
	return sz
}

// encode MemberIdentity13; Versions: 0-4
func (t MemberIdentity13) Encode(e *protocol.Encoder, version int16) {
	if version >= 3 {
		e.PutString(t.MemberId) // MemberId
	}
	if version >= 3 {
		e.PutString(t.GroupInstanceId) // GroupInstanceId
	}
}

// decode MemberIdentity13; Versions: 0-4
func (t *MemberIdentity13) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 3 {
		t.MemberId, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 3 {
		t.GroupInstanceId, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

// LeaveGroupResponse; ApiKey: 13, Versions: 0-4
type LeaveGroupResponse struct {
	ThrottleTimeMs int32              // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-4
	ErrorCode      int16              // The error code, or 0 if there was no error. Versions: 0-4
	Members        []MemberResponse13 // List of leaving member responses. Versions: 0-4
}

// size of LeaveGroupResponse; Versions: 0-4
func (t LeaveGroupResponse) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.Int16 // ErrorCode
	if version >= 3 {
		sz += sizeof.ArrayLength // Members
		for i := len(t.Members) - 1; i >= 0; i-- {
			sz += t.Members[i].Size(version)
		}
	}
	return sz
}

// encode LeaveGroupResponse; Versions: 0-4
func (t LeaveGroupResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	e.PutInt16(t.ErrorCode) // ErrorCode
	if version >= 3 {
		// Members
		len2 := len(t.Members)
		e.PutArrayLength(len2)
		for i := 0; i < len2; i++ {
			t.Members[i].Encode(e, version)
		}
	}
}

// decode LeaveGroupResponse; Versions: 0-4
func (t *LeaveGroupResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	if version >= 3 {
		// Members
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Members = make([]MemberResponse13, n)
			for i := 0; i < n; i++ {
				var item MemberResponse13
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.Members[i] = item
			}
		}
	}
	return err
}

type MemberResponse13 struct {
	MemberId        string // The member ID to remove from the group. Versions: 0-4
	GroupInstanceId string // The group instance ID to remove from the group. Versions: 0-4
	ErrorCode       int16  // The error code, or 0 if there was no error. Versions: 0-4
}

// size of MemberResponse13; Versions: 0-4
func (t MemberResponse13) Size(version int16) int32 {
	var sz int32
	if version >= 3 {
		sz += sizeof.String(t.MemberId) // MemberId
	}
	if version >= 3 {
		sz += sizeof.String(t.GroupInstanceId) // GroupInstanceId
	}
	if version >= 3 {
		sz += sizeof.Int16 // ErrorCode
	}
	return sz
}

// encode MemberResponse13; Versions: 0-4
func (t MemberResponse13) Encode(e *protocol.Encoder, version int16) {
	if version >= 3 {
		e.PutString(t.MemberId) // MemberId
	}
	if version >= 3 {
		e.PutString(t.GroupInstanceId) // GroupInstanceId
	}
	if version >= 3 {
		e.PutInt16(t.ErrorCode) // ErrorCode
	}
}

// decode MemberResponse13; Versions: 0-4
func (t *MemberResponse13) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 3 {
		t.MemberId, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 3 {
		t.GroupInstanceId, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 3 {
		t.ErrorCode, err = d.Int16()
		if err != nil {
			return err
		}
	}
	return err
}

// SyncGroupRequest; ApiKey: 14, Versions: 0-4
type SyncGroupRequest struct {
	GroupId         string                         // The unique group identifier. Versions: 0-4
	GenerationId    int32                          // The generation of the group. Versions: 0-4
	MemberId        string                         // The member ID assigned by the group. Versions: 0-4
	GroupInstanceId string                         // The unique identifier of the consumer instance provided by end user. Versions: 0-4
	Assignments     []SyncGroupRequestAssignment14 // Each assignment. Versions: 0-4
}

// size of SyncGroupRequest; Versions: 0-4
func (t SyncGroupRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId)  // GroupId
	sz += sizeof.Int32              // GenerationId
	sz += sizeof.String(t.MemberId) // MemberId
	if version >= 3 {
		sz += sizeof.String(t.GroupInstanceId) // GroupInstanceId
	}
	sz += sizeof.ArrayLength // Assignments
	for i := len(t.Assignments) - 1; i >= 0; i-- {
		sz += t.Assignments[i].Size(version)
	}
	return sz
}

// encode SyncGroupRequest; Versions: 0-4
func (t SyncGroupRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId)     // GroupId
	e.PutInt32(t.GenerationId) // GenerationId
	e.PutString(t.MemberId)    // MemberId
	if version >= 3 {
		e.PutString(t.GroupInstanceId) // GroupInstanceId
	}
	// Assignments
	len4 := len(t.Assignments)
	e.PutArrayLength(len4)
	for i := 0; i < len4; i++ {
		t.Assignments[i].Encode(e, version)
	}
}

// decode SyncGroupRequest; Versions: 0-4
func (t *SyncGroupRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	t.GenerationId, err = d.Int32()
	if err != nil {
		return err
	}
	t.MemberId, err = d.String()
	if err != nil {
		return err
	}
	if version >= 3 {
		t.GroupInstanceId, err = d.String()
		if err != nil {
			return err
		}
	}
	// Assignments
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Assignments = make([]SyncGroupRequestAssignment14, n)
		for i := 0; i < n; i++ {
			var item SyncGroupRequestAssignment14
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Assignments[i] = item
		}
	}
	return err
}

type SyncGroupRequestAssignment14 struct {
	MemberId   string // The ID of the member to assign. Versions: 0-4
	Assignment []byte // The member assignment. Versions: 0-4
}

// size of SyncGroupRequestAssignment14; Versions: 0-4
func (t SyncGroupRequestAssignment14) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.MemberId)  // MemberId
	sz += sizeof.Bytes(t.Assignment) // Assignment
	return sz
}

// encode SyncGroupRequestAssignment14; Versions: 0-4
func (t SyncGroupRequestAssignment14) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.MemberId)  // MemberId
	e.PutBytes(t.Assignment) // Assignment
}

// decode SyncGroupRequestAssignment14; Versions: 0-4
func (t *SyncGroupRequestAssignment14) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.MemberId, err = d.String()
	if err != nil {
		return err
	}
	t.Assignment, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

// SyncGroupResponse; ApiKey: 14, Versions: 0-4
type SyncGroupResponse struct {
	ThrottleTimeMs int32  // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-4
	ErrorCode      int16  // The error code, or 0 if there was no error. Versions: 0-4
	Assignment     []byte // The member assignment. Versions: 0-4
}

// size of SyncGroupResponse; Versions: 0-4
func (t SyncGroupResponse) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.Int16               // ErrorCode
	sz += sizeof.Bytes(t.Assignment) // Assignment
	return sz
}

// encode SyncGroupResponse; Versions: 0-4
func (t SyncGroupResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	e.PutInt16(t.ErrorCode)  // ErrorCode
	e.PutBytes(t.Assignment) // Assignment
}

// decode SyncGroupResponse; Versions: 0-4
func (t *SyncGroupResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.Assignment, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

// DescribeGroupsRequest; ApiKey: 15, Versions: 0-5
type DescribeGroupsRequest struct {
	Groups                      []string // The names of the groups to describe Versions: 0-5
	IncludeAuthorizedOperations bool     // Whether to include authorized operations. Versions: 0-5
}

// size of DescribeGroupsRequest; Versions: 0-5
func (t DescribeGroupsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.StringArray(t.Groups) // Groups
	if version >= 3 {
		sz += sizeof.Bool // IncludeAuthorizedOperations
	}
	return sz
}

// encode DescribeGroupsRequest; Versions: 0-5
func (t DescribeGroupsRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutStringArray(t.Groups) // Groups
	if version >= 3 {
		e.PutBool(t.IncludeAuthorizedOperations) // IncludeAuthorizedOperations
	}
}

// decode DescribeGroupsRequest; Versions: 0-5
func (t *DescribeGroupsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Groups, err = d.StringArray()
	if err != nil {
		return err
	}
	if version >= 3 {
		t.IncludeAuthorizedOperations, err = d.Bool()
		if err != nil {
			return err
		}
	}
	return err
}

// DescribeGroupsResponse; ApiKey: 15, Versions: 0-5
type DescribeGroupsResponse struct {
	ThrottleTimeMs int32              // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-5
	Groups         []DescribedGroup15 // Each described group. Versions: 0-5
}

// size of DescribeGroupsResponse; Versions: 0-5
func (t DescribeGroupsResponse) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.ArrayLength // Groups
	for i := len(t.Groups) - 1; i >= 0; i-- {
		sz += t.Groups[i].Size(version)
	}
	return sz
}

// encode DescribeGroupsResponse; Versions: 0-5
func (t DescribeGroupsResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	// Groups
	len1 := len(t.Groups)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Groups[i].Encode(e, version)
	}
}

// decode DescribeGroupsResponse; Versions: 0-5
func (t *DescribeGroupsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Groups
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Groups = make([]DescribedGroup15, n)
		for i := 0; i < n; i++ {
			var item DescribedGroup15
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Groups[i] = item
		}
	}
	return err
}

type DescribedGroup15 struct {
	ErrorCode            int16                    // The describe error, or 0 if there was no error. Versions: 0-5
	GroupId              string                   // The group ID string. Versions: 0-5
	GroupState           string                   // The group state string, or the empty string. Versions: 0-5
	ProtocolType         string                   // The group protocol type, or the empty string. Versions: 0-5
	ProtocolData         string                   // The group protocol data, or the empty string. Versions: 0-5
	Members              []DescribedGroupMember15 // The group members. Versions: 0-5
	AuthorizedOperations int32                    // 32-bit bitfield to represent authorized operations for this group. Versions: 0-5
}

// size of DescribedGroup15; Versions: 0-5
func (t DescribedGroup15) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.GroupId)      // GroupId
	sz += sizeof.String(t.GroupState)   // GroupState
	sz += sizeof.String(t.ProtocolType) // ProtocolType
	sz += sizeof.String(t.ProtocolData) // ProtocolData
	sz += sizeof.ArrayLength            // Members
	for i := len(t.Members) - 1; i >= 0; i-- {
		sz += t.Members[i].Size(version)
	}
	if version >= 3 {
		sz += sizeof.Int32 // AuthorizedOperations
	}
	return sz
}

// encode DescribedGroup15; Versions: 0-5
func (t DescribedGroup15) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.GroupId)      // GroupId
	e.PutString(t.GroupState)   // GroupState
	e.PutString(t.ProtocolType) // ProtocolType
	e.PutString(t.ProtocolData) // ProtocolData
	// Members
	len5 := len(t.Members)
	e.PutArrayLength(len5)
	for i := 0; i < len5; i++ {
		t.Members[i].Encode(e, version)
	}
	if version >= 3 {
		e.PutInt32(t.AuthorizedOperations) // AuthorizedOperations
	}
}

// decode DescribedGroup15; Versions: 0-5
func (t *DescribedGroup15) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	t.GroupState, err = d.String()
	if err != nil {
		return err
	}
	t.ProtocolType, err = d.String()
	if err != nil {
		return err
	}
	t.ProtocolData, err = d.String()
	if err != nil {
		return err
	}
	// Members
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Members = make([]DescribedGroupMember15, n)
		for i := 0; i < n; i++ {
			var item DescribedGroupMember15
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Members[i] = item
		}
	}
	if version >= 3 {
		t.AuthorizedOperations, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}

type DescribedGroupMember15 struct {
	MemberId         string // The member ID assigned by the group coordinator. Versions: 0-5
	GroupInstanceId  string // The unique identifier of the consumer instance provided by end user. Versions: 0-5
	ClientId         string // The client ID used in the member's latest join group request. Versions: 0-5
	ClientHost       string // The client host. Versions: 0-5
	MemberMetadata   []byte // The metadata corresponding to the current group protocol in use. Versions: 0-5
	MemberAssignment []byte // The current assignment provided by the group leader. Versions: 0-5
}

// size of DescribedGroupMember15; Versions: 0-5
func (t DescribedGroupMember15) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.MemberId) // MemberId
	if version >= 4 {
		sz += sizeof.String(t.GroupInstanceId) // GroupInstanceId
	}
	sz += sizeof.String(t.ClientId)        // ClientId
	sz += sizeof.String(t.ClientHost)      // ClientHost
	sz += sizeof.Bytes(t.MemberMetadata)   // MemberMetadata
	sz += sizeof.Bytes(t.MemberAssignment) // MemberAssignment
	return sz
}

// encode DescribedGroupMember15; Versions: 0-5
func (t DescribedGroupMember15) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.MemberId) // MemberId
	if version >= 4 {
		e.PutString(t.GroupInstanceId) // GroupInstanceId
	}
	e.PutString(t.ClientId)        // ClientId
	e.PutString(t.ClientHost)      // ClientHost
	e.PutBytes(t.MemberMetadata)   // MemberMetadata
	e.PutBytes(t.MemberAssignment) // MemberAssignment
}

// decode DescribedGroupMember15; Versions: 0-5
func (t *DescribedGroupMember15) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.MemberId, err = d.String()
	if err != nil {
		return err
	}
	if version >= 4 {
		t.GroupInstanceId, err = d.String()
		if err != nil {
			return err
		}
	}
	t.ClientId, err = d.String()
	if err != nil {
		return err
	}
	t.ClientHost, err = d.String()
	if err != nil {
		return err
	}
	t.MemberMetadata, err = d.Bytes()
	if err != nil {
		return err
	}
	t.MemberAssignment, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

// ListGroupsRequest; ApiKey: 16, Versions: 0-3
type ListGroupsRequest struct {
}

// size of ListGroupsRequest; Versions: 0-3
func (t ListGroupsRequest) Size(version int16) int32 {
	var sz int32
	return sz
}

// encode ListGroupsRequest; Versions: 0-3
func (t ListGroupsRequest) Encode(e *protocol.Encoder, version int16) {
}

// decode ListGroupsRequest; Versions: 0-3
func (t *ListGroupsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	return err
}

// ListGroupsResponse; ApiKey: 16, Versions: 0-3
type ListGroupsResponse struct {
	ThrottleTimeMs int32           // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-3
	ErrorCode      int16           // The error code, or 0 if there was no error. Versions: 0-3
	Groups         []ListedGroup16 // Each group in the response. Versions: 0-3
}

// size of ListGroupsResponse; Versions: 0-3
func (t ListGroupsResponse) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.Int16       // ErrorCode
	sz += sizeof.ArrayLength // Groups
	for i := len(t.Groups) - 1; i >= 0; i-- {
		sz += t.Groups[i].Size(version)
	}
	return sz
}

// encode ListGroupsResponse; Versions: 0-3
func (t ListGroupsResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	e.PutInt16(t.ErrorCode) // ErrorCode
	// Groups
	len2 := len(t.Groups)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Groups[i].Encode(e, version)
	}
}

// decode ListGroupsResponse; Versions: 0-3
func (t *ListGroupsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	// Groups
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Groups = make([]ListedGroup16, n)
		for i := 0; i < n; i++ {
			var item ListedGroup16
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Groups[i] = item
		}
	}
	return err
}

type ListedGroup16 struct {
	GroupId      string // The group ID. Versions: 0-3
	ProtocolType string // The group protocol type. Versions: 0-3
}

// size of ListedGroup16; Versions: 0-3
func (t ListedGroup16) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId)      // GroupId
	sz += sizeof.String(t.ProtocolType) // ProtocolType
	return sz
}

// encode ListedGroup16; Versions: 0-3
func (t ListedGroup16) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId)      // GroupId
	e.PutString(t.ProtocolType) // ProtocolType
}

// decode ListedGroup16; Versions: 0-3
func (t *ListedGroup16) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	t.ProtocolType, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// SaslHandshakeRequest; ApiKey: 17, Versions: 0-1
type SaslHandshakeRequest struct {
	Mechanism string // The SASL mechanism chosen by the client. Versions: 0-1
}

// size of SaslHandshakeRequest; Versions: 0-1
func (t SaslHandshakeRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Mechanism) // Mechanism
	return sz
}

// encode SaslHandshakeRequest; Versions: 0-1
func (t SaslHandshakeRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Mechanism) // Mechanism
}

// decode SaslHandshakeRequest; Versions: 0-1
func (t *SaslHandshakeRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Mechanism, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// SaslHandshakeResponse; ApiKey: 17, Versions: 0-1
type SaslHandshakeResponse struct {
	ErrorCode  int16    // The error code, or 0 if there was no error. Versions: 0-1
	Mechanisms []string // The mechanisms enabled in the server. Versions: 0-1
}

// size of SaslHandshakeResponse; Versions: 0-1
func (t SaslHandshakeResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                     // ErrorCode
	sz += sizeof.StringArray(t.Mechanisms) // Mechanisms
	return sz
}

// encode SaslHandshakeResponse; Versions: 0-1
func (t SaslHandshakeResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)        // ErrorCode
	e.PutStringArray(t.Mechanisms) // Mechanisms
}

// decode SaslHandshakeResponse; Versions: 0-1
func (t *SaslHandshakeResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.Mechanisms, err = d.StringArray()
	if err != nil {
		return err
	}
	return err
}

// ApiVersionsRequest; ApiKey: 18, Versions: 0-3
type ApiVersionsRequest struct {
	ClientSoftwareName    string // The name of the client. Versions: 0-3
	ClientSoftwareVersion string // The version of the client. Versions: 0-3
}

// size of ApiVersionsRequest; Versions: 0-3
func (t ApiVersionsRequest) Size(version int16) int32 {
	var sz int32
	if version >= 3 {
		sz += sizeof.String(t.ClientSoftwareName) // ClientSoftwareName
	}
	if version >= 3 {
		sz += sizeof.String(t.ClientSoftwareVersion) // ClientSoftwareVersion
	}
	return sz
}

// encode ApiVersionsRequest; Versions: 0-3
func (t ApiVersionsRequest) Encode(e *protocol.Encoder, version int16) {
	if version >= 3 {
		e.PutString(t.ClientSoftwareName) // ClientSoftwareName
	}
	if version >= 3 {
		e.PutString(t.ClientSoftwareVersion) // ClientSoftwareVersion
	}
}

// decode ApiVersionsRequest; Versions: 0-3
func (t *ApiVersionsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 3 {
		t.ClientSoftwareName, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 3 {
		t.ClientSoftwareVersion, err = d.String()
		if err != nil {
			return err
		}
	}
	return err
}

// ApiVersionsResponse; ApiKey: 18, Versions: 0-3
type ApiVersionsResponse struct {
	ErrorCode      int16                      // The top-level error code. Versions: 0-3
	ApiKeys        []ApiVersionsResponseKey18 // The APIs supported by the broker. Versions: 0-3
	ThrottleTimeMs int32                      // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-3
}

// size of ApiVersionsResponse; Versions: 0-3
func (t ApiVersionsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16       // ErrorCode
	sz += sizeof.ArrayLength // ApiKeys
	for i := len(t.ApiKeys) - 1; i >= 0; i-- {
		sz += t.ApiKeys[i].Size(version)
	}
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	return sz
}

// encode ApiVersionsResponse; Versions: 0-3
func (t ApiVersionsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
	// ApiKeys
	len1 := len(t.ApiKeys)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.ApiKeys[i].Encode(e, version)
	}
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
}

// decode ApiVersionsResponse; Versions: 0-3
func (t *ApiVersionsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	// ApiKeys
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.ApiKeys = make([]ApiVersionsResponseKey18, n)
		for i := 0; i < n; i++ {
			var item ApiVersionsResponseKey18
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.ApiKeys[i] = item
		}
	}
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}

type ApiVersionsResponseKey18 struct {
	ApiKey     int16 // The API index. Versions: 0-3
	MinVersion int16 // The minimum supported version, inclusive. Versions: 0-3
	MaxVersion int16 // The maximum supported version, inclusive. Versions: 0-3
}

// size of ApiVersionsResponseKey18; Versions: 0-3
func (t ApiVersionsResponseKey18) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16 // ApiKey
	sz += sizeof.Int16 // MinVersion
	sz += sizeof.Int16 // MaxVersion
	return sz
}

// encode ApiVersionsResponseKey18; Versions: 0-3
func (t ApiVersionsResponseKey18) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ApiKey)     // ApiKey
	e.PutInt16(t.MinVersion) // MinVersion
	e.PutInt16(t.MaxVersion) // MaxVersion
}

// decode ApiVersionsResponseKey18; Versions: 0-3
func (t *ApiVersionsResponseKey18) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ApiKey, err = d.Int16()
	if err != nil {
		return err
	}
	t.MinVersion, err = d.Int16()
	if err != nil {
		return err
	}
	t.MaxVersion, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// CreateTopicsRequest; ApiKey: 19, Versions: 0-5
type CreateTopicsRequest struct {
	Topics       []CreatableTopic19 // The topics to create. Versions: 0-5
	timeoutMs    int32              // How long to wait in milliseconds before timing out the request. Versions: 0-5
	validateOnly bool               // If true, check that the topics can be created as specified, but don't create anything. Versions: 0-5
}

// size of CreateTopicsRequest; Versions: 0-5
func (t CreateTopicsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	sz += sizeof.Int32 // timeoutMs
	if version >= 1 {
		sz += sizeof.Bool // validateOnly
	}
	return sz
}

// encode CreateTopicsRequest; Versions: 0-5
func (t CreateTopicsRequest) Encode(e *protocol.Encoder, version int16) {
	// Topics
	len0 := len(t.Topics)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Topics[i].Encode(e, version)
	}
	e.PutInt32(t.timeoutMs) // timeoutMs
	if version >= 1 {
		e.PutBool(t.validateOnly) // validateOnly
	}
}

// decode CreateTopicsRequest; Versions: 0-5
func (t *CreateTopicsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]CreatableTopic19, n)
		for i := 0; i < n; i++ {
			var item CreatableTopic19
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	t.timeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.validateOnly, err = d.Bool()
		if err != nil {
			return err
		}
	}
	return err
}

type CreatableTopic19 struct {
	Name              string                         // The topic name. Versions: 0-5
	NumPartitions     int32                          // The number of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions. Versions: 0-5
	ReplicationFactor int16                          // The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor. Versions: 0-5
	Assignments       []CreatableReplicaAssignment19 // The manual partition assignment, or the empty array if we are using automatic assignment. Versions: 0-5
	Configs           []CreateableTopicConfig19      // The custom topic configurations to set. Versions: 0-5
}

// size of CreatableTopic19; Versions: 0-5
func (t CreatableTopic19) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.Int32          // NumPartitions
	sz += sizeof.Int16          // ReplicationFactor
	sz += sizeof.ArrayLength    // Assignments
	for i := len(t.Assignments) - 1; i >= 0; i-- {
		sz += t.Assignments[i].Size(version)
	}
	sz += sizeof.ArrayLength // Configs
	for i := len(t.Configs) - 1; i >= 0; i-- {
		sz += t.Configs[i].Size(version)
	}
	return sz
}

// encode CreatableTopic19; Versions: 0-5
func (t CreatableTopic19) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)             // Name
	e.PutInt32(t.NumPartitions)     // NumPartitions
	e.PutInt16(t.ReplicationFactor) // ReplicationFactor
	// Assignments
	len3 := len(t.Assignments)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Assignments[i].Encode(e, version)
	}
	// Configs
	len4 := len(t.Configs)
	e.PutArrayLength(len4)
	for i := 0; i < len4; i++ {
		t.Configs[i].Encode(e, version)
	}
}

// decode CreatableTopic19; Versions: 0-5
func (t *CreatableTopic19) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.NumPartitions, err = d.Int32()
	if err != nil {
		return err
	}
	t.ReplicationFactor, err = d.Int16()
	if err != nil {
		return err
	}
	// Assignments
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Assignments = make([]CreatableReplicaAssignment19, n)
		for i := 0; i < n; i++ {
			var item CreatableReplicaAssignment19
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Assignments[i] = item
		}
	}
	// Configs
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Configs = make([]CreateableTopicConfig19, n)
		for i := 0; i < n; i++ {
			var item CreateableTopicConfig19
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Configs[i] = item
		}
	}
	return err
}

type CreatableReplicaAssignment19 struct {
	PartitionIndex int32   // The partition index. Versions: 0-5
	BrokerIds      []int32 // The brokers to place the partition on. Versions: 0-5
}

// size of CreatableReplicaAssignment19; Versions: 0-5
func (t CreatableReplicaAssignment19) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32                   // PartitionIndex
	sz += sizeof.Int32Array(t.BrokerIds) // BrokerIds
	return sz
}

// encode CreatableReplicaAssignment19; Versions: 0-5
func (t CreatableReplicaAssignment19) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt32Array(t.BrokerIds) // BrokerIds
}

// decode CreatableReplicaAssignment19; Versions: 0-5
func (t *CreatableReplicaAssignment19) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.BrokerIds, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

type CreateableTopicConfig19 struct {
	Name  string // The configuration name. Versions: 0-5
	Value string // The configuration value. Versions: 0-5
}

// size of CreateableTopicConfig19; Versions: 0-5
func (t CreateableTopicConfig19) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)  // Name
	sz += sizeof.String(t.Value) // Value
	return sz
}

// encode CreateableTopicConfig19; Versions: 0-5
func (t CreateableTopicConfig19) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)  // Name
	e.PutString(t.Value) // Value
}

// decode CreateableTopicConfig19; Versions: 0-5
func (t *CreateableTopicConfig19) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.Value, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// CreateTopicsResponse; ApiKey: 19, Versions: 0-5
type CreateTopicsResponse struct {
	ThrottleTimeMs int32                    // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-5
	Topics         []CreatableTopicResult19 // Results for each topic we tried to create. Versions: 0-5
}

// size of CreateTopicsResponse; Versions: 0-5
func (t CreateTopicsResponse) Size(version int16) int32 {
	var sz int32
	if version >= 2 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode CreateTopicsResponse; Versions: 0-5
func (t CreateTopicsResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 2 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode CreateTopicsResponse; Versions: 0-5
func (t *CreateTopicsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 2 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]CreatableTopicResult19, n)
		for i := 0; i < n; i++ {
			var item CreatableTopicResult19
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type CreatableTopicResult19 struct {
	Name                 string                    // The topic name. Versions: 0-5
	ErrorCode            int16                     // The error code, or 0 if there was no error. Versions: 0-5
	ErrorMessage         string                    // The error message, or null if there was no error. Versions: 0-5
	TopicConfigErrorCode int16                     // Optional topic config error returned if configs are not returned in the response. Versions: 0-5
	NumPartitions        int32                     // Number of partitions of the topic. Versions: 0-5
	ReplicationFactor    int16                     // Replicator factor of the topic. Versions: 0-5
	Configs              []CreatableTopicConfigs19 // Configuration of the topic. Versions: 0-5
}

// size of CreatableTopicResult19; Versions: 0-5
func (t CreatableTopicResult19) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.Int16          // ErrorCode
	if version >= 1 {
		sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	}
	if version >= 5 {
		sz += sizeof.Int16 // TopicConfigErrorCode
	}
	if version >= 5 {
		sz += sizeof.Int32 // NumPartitions
	}
	if version >= 5 {
		sz += sizeof.Int16 // ReplicationFactor
	}
	if version >= 5 {
		sz += sizeof.ArrayLength // Configs
		for i := len(t.Configs) - 1; i >= 0; i-- {
			sz += t.Configs[i].Size(version)
		}
	}
	return sz
}

// encode CreatableTopicResult19; Versions: 0-5
func (t CreatableTopicResult19) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)     // Name
	e.PutInt16(t.ErrorCode) // ErrorCode
	if version >= 1 {
		e.PutString(t.ErrorMessage) // ErrorMessage
	}
	if version >= 5 {
		e.PutInt16(t.TopicConfigErrorCode) // TopicConfigErrorCode
	}
	if version >= 5 {
		e.PutInt32(t.NumPartitions) // NumPartitions
	}
	if version >= 5 {
		e.PutInt16(t.ReplicationFactor) // ReplicationFactor
	}
	if version >= 5 {
		// Configs
		len6 := len(t.Configs)
		e.PutArrayLength(len6)
		for i := 0; i < len6; i++ {
			t.Configs[i].Encode(e, version)
		}
	}
}

// decode CreatableTopicResult19; Versions: 0-5
func (t *CreatableTopicResult19) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.ErrorMessage, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.TopicConfigErrorCode, err = d.Int16()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.NumPartitions, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.ReplicationFactor, err = d.Int16()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		// Configs
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Configs = make([]CreatableTopicConfigs19, n)
			for i := 0; i < n; i++ {
				var item CreatableTopicConfigs19
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.Configs[i] = item
			}
		}
	}
	return err
}

type CreatableTopicConfigs19 struct {
	Name         string // The configuration name. Versions: 0-5
	Value        string // The configuration value. Versions: 0-5
	ReadOnly     bool   // True if the configuration is read-only. Versions: 0-5
	ConfigSource int8   // The configuration source. Versions: 0-5
	IsSensitive  bool   // True if this configuration is sensitive. Versions: 0-5
}

// size of CreatableTopicConfigs19; Versions: 0-5
func (t CreatableTopicConfigs19) Size(version int16) int32 {
	var sz int32
	if version >= 5 {
		sz += sizeof.String(t.Name) // Name
	}
	if version >= 5 {
		sz += sizeof.String(t.Value) // Value
	}
	if version >= 5 {
		sz += sizeof.Bool // ReadOnly
	}
	if version >= 5 {
		sz += sizeof.Int8 // ConfigSource
	}
	if version >= 5 {
		sz += sizeof.Bool // IsSensitive
	}
	return sz
}

// encode CreatableTopicConfigs19; Versions: 0-5
func (t CreatableTopicConfigs19) Encode(e *protocol.Encoder, version int16) {
	if version >= 5 {
		e.PutString(t.Name) // Name
	}
	if version >= 5 {
		e.PutString(t.Value) // Value
	}
	if version >= 5 {
		e.PutBool(t.ReadOnly) // ReadOnly
	}
	if version >= 5 {
		e.PutInt8(t.ConfigSource) // ConfigSource
	}
	if version >= 5 {
		e.PutBool(t.IsSensitive) // IsSensitive
	}
}

// decode CreatableTopicConfigs19; Versions: 0-5
func (t *CreatableTopicConfigs19) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 5 {
		t.Name, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.Value, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.ReadOnly, err = d.Bool()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.ConfigSource, err = d.Int8()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.IsSensitive, err = d.Bool()
		if err != nil {
			return err
		}
	}
	return err
}

// DeleteTopicsRequest; ApiKey: 20, Versions: 0-4
type DeleteTopicsRequest struct {
	TopicNames []string // The names of the topics to delete Versions: 0-4
	TimeoutMs  int32    // The length of time in milliseconds to wait for the deletions to complete. Versions: 0-4
}

// size of DeleteTopicsRequest; Versions: 0-4
func (t DeleteTopicsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.StringArray(t.TopicNames) // TopicNames
	sz += sizeof.Int32                     // TimeoutMs
	return sz
}

// encode DeleteTopicsRequest; Versions: 0-4
func (t DeleteTopicsRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutStringArray(t.TopicNames) // TopicNames
	e.PutInt32(t.TimeoutMs)        // TimeoutMs
}

// decode DeleteTopicsRequest; Versions: 0-4
func (t *DeleteTopicsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TopicNames, err = d.StringArray()
	if err != nil {
		return err
	}
	t.TimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// DeleteTopicsResponse; ApiKey: 20, Versions: 0-4
type DeleteTopicsResponse struct {
	ThrottleTimeMs int32                    // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-4
	Responses      []DeletableTopicResult20 // The results for each topic we tried to delete. Versions: 0-4
}

// size of DeleteTopicsResponse; Versions: 0-4
func (t DeleteTopicsResponse) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.ArrayLength // Responses
	for i := len(t.Responses) - 1; i >= 0; i-- {
		sz += t.Responses[i].Size(version)
	}
	return sz
}

// encode DeleteTopicsResponse; Versions: 0-4
func (t DeleteTopicsResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	// Responses
	len1 := len(t.Responses)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Responses[i].Encode(e, version)
	}
}

// decode DeleteTopicsResponse; Versions: 0-4
func (t *DeleteTopicsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Responses
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Responses = make([]DeletableTopicResult20, n)
		for i := 0; i < n; i++ {
			var item DeletableTopicResult20
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Responses[i] = item
		}
	}
	return err
}

type DeletableTopicResult20 struct {
	Name      string // The topic name Versions: 0-4
	ErrorCode int16  // The deletion error, or 0 if the deletion succeeded. Versions: 0-4
}

// size of DeletableTopicResult20; Versions: 0-4
func (t DeletableTopicResult20) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.Int16          // ErrorCode
	return sz
}

// encode DeletableTopicResult20; Versions: 0-4
func (t DeletableTopicResult20) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)     // Name
	e.PutInt16(t.ErrorCode) // ErrorCode
}

// decode DeletableTopicResult20; Versions: 0-4
func (t *DeletableTopicResult20) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// DeleteRecordsRequest; ApiKey: 21, Versions: 0-1
type DeleteRecordsRequest struct {
	Topics    []DeleteRecordsTopic21 // Each topic that we want to delete records from. Versions: 0-1
	TimeoutMs int32                  // How long to wait for the deletion to complete, in milliseconds. Versions: 0-1
}

// size of DeleteRecordsRequest; Versions: 0-1
func (t DeleteRecordsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	sz += sizeof.Int32 // TimeoutMs
	return sz
}

// encode DeleteRecordsRequest; Versions: 0-1
func (t DeleteRecordsRequest) Encode(e *protocol.Encoder, version int16) {
	// Topics
	len0 := len(t.Topics)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Topics[i].Encode(e, version)
	}
	e.PutInt32(t.TimeoutMs) // TimeoutMs
}

// decode DeleteRecordsRequest; Versions: 0-1
func (t *DeleteRecordsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]DeleteRecordsTopic21, n)
		for i := 0; i < n; i++ {
			var item DeleteRecordsTopic21
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	t.TimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

type DeleteRecordsTopic21 struct {
	Name       string                     // The topic name. Versions: 0-1
	Partitions []DeleteRecordsPartition21 // Each partition that we want to delete records from. Versions: 0-1
}

// size of DeleteRecordsTopic21; Versions: 0-1
func (t DeleteRecordsTopic21) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode DeleteRecordsTopic21; Versions: 0-1
func (t DeleteRecordsTopic21) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode DeleteRecordsTopic21; Versions: 0-1
func (t *DeleteRecordsTopic21) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]DeleteRecordsPartition21, n)
		for i := 0; i < n; i++ {
			var item DeleteRecordsPartition21
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type DeleteRecordsPartition21 struct {
	PartitionIndex int32 // The partition index. Versions: 0-1
	Offset         int64 // The deletion offset. Versions: 0-1
}

// size of DeleteRecordsPartition21; Versions: 0-1
func (t DeleteRecordsPartition21) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int64 // Offset
	return sz
}

// encode DeleteRecordsPartition21; Versions: 0-1
func (t DeleteRecordsPartition21) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt64(t.Offset)         // Offset
}

// decode DeleteRecordsPartition21; Versions: 0-1
func (t *DeleteRecordsPartition21) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.Offset, err = d.Int64()
	if err != nil {
		return err
	}
	return err
}

// DeleteRecordsResponse; ApiKey: 21, Versions: 0-1
type DeleteRecordsResponse struct {
	ThrottleTimeMs int32                        // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	Topics         []DeleteRecordsTopicResult21 // Each topic that we wanted to delete records from. Versions: 0-1
}

// size of DeleteRecordsResponse; Versions: 0-1
func (t DeleteRecordsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode DeleteRecordsResponse; Versions: 0-1
func (t DeleteRecordsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode DeleteRecordsResponse; Versions: 0-1
func (t *DeleteRecordsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]DeleteRecordsTopicResult21, n)
		for i := 0; i < n; i++ {
			var item DeleteRecordsTopicResult21
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type DeleteRecordsTopicResult21 struct {
	Name       string                           // The topic name. Versions: 0-1
	Partitions []DeleteRecordsPartitionResult21 // Each partition that we wanted to delete records from. Versions: 0-1
}

// size of DeleteRecordsTopicResult21; Versions: 0-1
func (t DeleteRecordsTopicResult21) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode DeleteRecordsTopicResult21; Versions: 0-1
func (t DeleteRecordsTopicResult21) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode DeleteRecordsTopicResult21; Versions: 0-1
func (t *DeleteRecordsTopicResult21) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]DeleteRecordsPartitionResult21, n)
		for i := 0; i < n; i++ {
			var item DeleteRecordsPartitionResult21
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type DeleteRecordsPartitionResult21 struct {
	PartitionIndex int32 // The partition index. Versions: 0-1
	LowWatermark   int64 // The partition low water mark. Versions: 0-1
	ErrorCode      int16 // The deletion error code, or 0 if the deletion succeeded. Versions: 0-1
}

// size of DeleteRecordsPartitionResult21; Versions: 0-1
func (t DeleteRecordsPartitionResult21) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int64 // LowWatermark
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode DeleteRecordsPartitionResult21; Versions: 0-1
func (t DeleteRecordsPartitionResult21) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt64(t.LowWatermark)   // LowWatermark
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode DeleteRecordsPartitionResult21; Versions: 0-1
func (t *DeleteRecordsPartitionResult21) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.LowWatermark, err = d.Int64()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// InitProducerIdRequest; ApiKey: 22, Versions: 0-2
type InitProducerIdRequest struct {
	TransactionalId      string // The transactional id, or null if the producer is not transactional. Versions: 0-2
	TransactionTimeoutMs int32  // The time in ms to wait for before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been defined. Versions: 0-2
}

// size of InitProducerIdRequest; Versions: 0-2
func (t InitProducerIdRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TransactionalId) // TransactionalId
	sz += sizeof.Int32                     // TransactionTimeoutMs
	return sz
}

// encode InitProducerIdRequest; Versions: 0-2
func (t InitProducerIdRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TransactionalId)     // TransactionalId
	e.PutInt32(t.TransactionTimeoutMs) // TransactionTimeoutMs
}

// decode InitProducerIdRequest; Versions: 0-2
func (t *InitProducerIdRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TransactionalId, err = d.String()
	if err != nil {
		return err
	}
	t.TransactionTimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// InitProducerIdResponse; ApiKey: 22, Versions: 0-2
type InitProducerIdResponse struct {
	ThrottleTimeMs int32 // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-2
	ErrorCode      int16 // The error code, or 0 if there was no error. Versions: 0-2
	ProducerId     int64 // The current producer id. Versions: 0-2
	ProducerEpoch  int16 // The current epoch associated with the producer id. Versions: 0-2
}

// size of InitProducerIdResponse; Versions: 0-2
func (t InitProducerIdResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ThrottleTimeMs
	sz += sizeof.Int16 // ErrorCode
	sz += sizeof.Int64 // ProducerId
	sz += sizeof.Int16 // ProducerEpoch
	return sz
}

// encode InitProducerIdResponse; Versions: 0-2
func (t InitProducerIdResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutInt64(t.ProducerId)     // ProducerId
	e.PutInt16(t.ProducerEpoch)  // ProducerEpoch
}

// decode InitProducerIdResponse; Versions: 0-2
func (t *InitProducerIdResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ProducerId, err = d.Int64()
	if err != nil {
		return err
	}
	t.ProducerEpoch, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// OffsetForLeaderEpochRequest; ApiKey: 23, Versions: 0-3
type OffsetForLeaderEpochRequest struct {
	ReplicaId int32                    // The broker ID of the follower, of -1 if this request is from a consumer. Versions: 0-3
	Topics    []OffsetForLeaderTopic23 // Each topic to get offsets for. Versions: 0-3
}

// size of OffsetForLeaderEpochRequest; Versions: 0-3
func (t OffsetForLeaderEpochRequest) Size(version int16) int32 {
	var sz int32
	if version >= 3 {
		sz += sizeof.Int32 // ReplicaId
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode OffsetForLeaderEpochRequest; Versions: 0-3
func (t OffsetForLeaderEpochRequest) Encode(e *protocol.Encoder, version int16) {
	if version >= 3 {
		e.PutInt32(t.ReplicaId) // ReplicaId
	}
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode OffsetForLeaderEpochRequest; Versions: 0-3
func (t *OffsetForLeaderEpochRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 3 {
		t.ReplicaId, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OffsetForLeaderTopic23, n)
		for i := 0; i < n; i++ {
			var item OffsetForLeaderTopic23
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type OffsetForLeaderTopic23 struct {
	Name       string                       // The topic name. Versions: 0-3
	Partitions []OffsetForLeaderPartition23 // Each partition to get offsets for. Versions: 0-3
}

// size of OffsetForLeaderTopic23; Versions: 0-3
func (t OffsetForLeaderTopic23) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode OffsetForLeaderTopic23; Versions: 0-3
func (t OffsetForLeaderTopic23) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode OffsetForLeaderTopic23; Versions: 0-3
func (t *OffsetForLeaderTopic23) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]OffsetForLeaderPartition23, n)
		for i := 0; i < n; i++ {
			var item OffsetForLeaderPartition23
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type OffsetForLeaderPartition23 struct {
	PartitionIndex     int32 // The partition index. Versions: 0-3
	CurrentLeaderEpoch int32 // An epoch used to fence consumers/replicas with old metadata.  If the epoch provided by the client is larger than the current epoch known to the broker, then the UNKNOWN_LEADER_EPOCH error code will be returned. If the provided epoch is smaller, then the FENCED_LEADER_EPOCH error code will be returned. Versions: 0-3
	LeaderEpoch        int32 // The epoch to look up an offset for. Versions: 0-3
}

// size of OffsetForLeaderPartition23; Versions: 0-3
func (t OffsetForLeaderPartition23) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	if version >= 2 {
		sz += sizeof.Int32 // CurrentLeaderEpoch
	}
	sz += sizeof.Int32 // LeaderEpoch
	return sz
}

// encode OffsetForLeaderPartition23; Versions: 0-3
func (t OffsetForLeaderPartition23) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	if version >= 2 {
		e.PutInt32(t.CurrentLeaderEpoch) // CurrentLeaderEpoch
	}
	e.PutInt32(t.LeaderEpoch) // LeaderEpoch
}

// decode OffsetForLeaderPartition23; Versions: 0-3
func (t *OffsetForLeaderPartition23) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 2 {
		t.CurrentLeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.LeaderEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// OffsetForLeaderEpochResponse; ApiKey: 23, Versions: 0-3
type OffsetForLeaderEpochResponse struct {
	ThrottleTimeMs int32                          // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-3
	Topics         []OffsetForLeaderTopicResult23 // Each topic we fetched offsets for. Versions: 0-3
}

// size of OffsetForLeaderEpochResponse; Versions: 0-3
func (t OffsetForLeaderEpochResponse) Size(version int16) int32 {
	var sz int32
	if version >= 2 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode OffsetForLeaderEpochResponse; Versions: 0-3
func (t OffsetForLeaderEpochResponse) Encode(e *protocol.Encoder, version int16) {
	if version >= 2 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode OffsetForLeaderEpochResponse; Versions: 0-3
func (t *OffsetForLeaderEpochResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 2 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OffsetForLeaderTopicResult23, n)
		for i := 0; i < n; i++ {
			var item OffsetForLeaderTopicResult23
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type OffsetForLeaderTopicResult23 struct {
	Name       string                             // The topic name. Versions: 0-3
	Partitions []OffsetForLeaderPartitionResult23 // Each partition in the topic we fetched offsets for. Versions: 0-3
}

// size of OffsetForLeaderTopicResult23; Versions: 0-3
func (t OffsetForLeaderTopicResult23) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode OffsetForLeaderTopicResult23; Versions: 0-3
func (t OffsetForLeaderTopicResult23) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode OffsetForLeaderTopicResult23; Versions: 0-3
func (t *OffsetForLeaderTopicResult23) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]OffsetForLeaderPartitionResult23, n)
		for i := 0; i < n; i++ {
			var item OffsetForLeaderPartitionResult23
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type OffsetForLeaderPartitionResult23 struct {
	ErrorCode      int16 // The error code 0, or if there was no error. Versions: 0-3
	PartitionIndex int32 // The partition index. Versions: 0-3
	LeaderEpoch    int32 // The leader epoch of the partition. Versions: 0-3
	EndOffset      int64 // The end offset of the epoch. Versions: 0-3
}

// size of OffsetForLeaderPartitionResult23; Versions: 0-3
func (t OffsetForLeaderPartitionResult23) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16 // ErrorCode
	sz += sizeof.Int32 // PartitionIndex
	if version >= 1 {
		sz += sizeof.Int32 // LeaderEpoch
	}
	sz += sizeof.Int64 // EndOffset
	return sz
}

// encode OffsetForLeaderPartitionResult23; Versions: 0-3
func (t OffsetForLeaderPartitionResult23) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	if version >= 1 {
		e.PutInt32(t.LeaderEpoch) // LeaderEpoch
	}
	e.PutInt64(t.EndOffset) // EndOffset
}

// decode OffsetForLeaderPartitionResult23; Versions: 0-3
func (t *OffsetForLeaderPartitionResult23) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.LeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.EndOffset, err = d.Int64()
	if err != nil {
		return err
	}
	return err
}

// AddPartitionsToTxnRequest; ApiKey: 24, Versions: 0-1
type AddPartitionsToTxnRequest struct {
	TransactionalId string                      // The transactional id corresponding to the transaction. Versions: 0-1
	ProducerId      int64                       // Current producer id in use by the transactional id. Versions: 0-1
	ProducerEpoch   int16                       // Current epoch associated with the producer id. Versions: 0-1
	Topics          []AddPartitionsToTxnTopic24 // The partitions to add to the transation. Versions: 0-1
}

// size of AddPartitionsToTxnRequest; Versions: 0-1
func (t AddPartitionsToTxnRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TransactionalId) // TransactionalId
	sz += sizeof.Int64                     // ProducerId
	sz += sizeof.Int16                     // ProducerEpoch
	sz += sizeof.ArrayLength               // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode AddPartitionsToTxnRequest; Versions: 0-1
func (t AddPartitionsToTxnRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TransactionalId) // TransactionalId
	e.PutInt64(t.ProducerId)       // ProducerId
	e.PutInt16(t.ProducerEpoch)    // ProducerEpoch
	// Topics
	len3 := len(t.Topics)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode AddPartitionsToTxnRequest; Versions: 0-1
func (t *AddPartitionsToTxnRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TransactionalId, err = d.String()
	if err != nil {
		return err
	}
	t.ProducerId, err = d.Int64()
	if err != nil {
		return err
	}
	t.ProducerEpoch, err = d.Int16()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]AddPartitionsToTxnTopic24, n)
		for i := 0; i < n; i++ {
			var item AddPartitionsToTxnTopic24
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type AddPartitionsToTxnTopic24 struct {
	Name       string  // The name of the topic. Versions: 0-1
	Partitions []int32 // The partition indexes to add to the transaction Versions: 0-1
}

// size of AddPartitionsToTxnTopic24; Versions: 0-1
func (t AddPartitionsToTxnTopic24) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)           // Name
	sz += sizeof.Int32Array(t.Partitions) // Partitions
	return sz
}

// encode AddPartitionsToTxnTopic24; Versions: 0-1
func (t AddPartitionsToTxnTopic24) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)           // Name
	e.PutInt32Array(t.Partitions) // Partitions
}

// decode AddPartitionsToTxnTopic24; Versions: 0-1
func (t *AddPartitionsToTxnTopic24) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.Partitions, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// AddPartitionsToTxnResponse; ApiKey: 24, Versions: 0-1
type AddPartitionsToTxnResponse struct {
	ThrottleTimeMs int32                             // Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	Results        []AddPartitionsToTxnTopicResult24 // The results for each topic. Versions: 0-1
}

// size of AddPartitionsToTxnResponse; Versions: 0-1
func (t AddPartitionsToTxnResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].Size(version)
	}
	return sz
}

// encode AddPartitionsToTxnResponse; Versions: 0-1
func (t AddPartitionsToTxnResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].Encode(e, version)
	}
}

// decode AddPartitionsToTxnResponse; Versions: 0-1
func (t *AddPartitionsToTxnResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]AddPartitionsToTxnTopicResult24, n)
		for i := 0; i < n; i++ {
			var item AddPartitionsToTxnTopicResult24
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type AddPartitionsToTxnTopicResult24 struct {
	Name    string                                // The topic name. Versions: 0-1
	Results []AddPartitionsToTxnPartitionResult24 // The results for each partition Versions: 0-1
}

// size of AddPartitionsToTxnTopicResult24; Versions: 0-1
func (t AddPartitionsToTxnTopicResult24) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].Size(version)
	}
	return sz
}

// encode AddPartitionsToTxnTopicResult24; Versions: 0-1
func (t AddPartitionsToTxnTopicResult24) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].Encode(e, version)
	}
}

// decode AddPartitionsToTxnTopicResult24; Versions: 0-1
func (t *AddPartitionsToTxnTopicResult24) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]AddPartitionsToTxnPartitionResult24, n)
		for i := 0; i < n; i++ {
			var item AddPartitionsToTxnPartitionResult24
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type AddPartitionsToTxnPartitionResult24 struct {
	PartitionIndex int32 // The partition indexes. Versions: 0-1
	ErrorCode      int16 // The response error code. Versions: 0-1
}

// size of AddPartitionsToTxnPartitionResult24; Versions: 0-1
func (t AddPartitionsToTxnPartitionResult24) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode AddPartitionsToTxnPartitionResult24; Versions: 0-1
func (t AddPartitionsToTxnPartitionResult24) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode AddPartitionsToTxnPartitionResult24; Versions: 0-1
func (t *AddPartitionsToTxnPartitionResult24) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// AddOffsetsToTxnRequest; ApiKey: 25, Versions: 0-1
type AddOffsetsToTxnRequest struct {
	TransactionalId string // The transactional id corresponding to the transaction. Versions: 0-1
	ProducerId      int64  // Current producer id in use by the transactional id. Versions: 0-1
	ProducerEpoch   int16  // Current epoch associated with the producer id. Versions: 0-1
	GroupId         string // The unique group identifier. Versions: 0-1
}

// size of AddOffsetsToTxnRequest; Versions: 0-1
func (t AddOffsetsToTxnRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TransactionalId) // TransactionalId
	sz += sizeof.Int64                     // ProducerId
	sz += sizeof.Int16                     // ProducerEpoch
	sz += sizeof.String(t.GroupId)         // GroupId
	return sz
}

// encode AddOffsetsToTxnRequest; Versions: 0-1
func (t AddOffsetsToTxnRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TransactionalId) // TransactionalId
	e.PutInt64(t.ProducerId)       // ProducerId
	e.PutInt16(t.ProducerEpoch)    // ProducerEpoch
	e.PutString(t.GroupId)         // GroupId
}

// decode AddOffsetsToTxnRequest; Versions: 0-1
func (t *AddOffsetsToTxnRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TransactionalId, err = d.String()
	if err != nil {
		return err
	}
	t.ProducerId, err = d.Int64()
	if err != nil {
		return err
	}
	t.ProducerEpoch, err = d.Int16()
	if err != nil {
		return err
	}
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// AddOffsetsToTxnResponse; ApiKey: 25, Versions: 0-1
type AddOffsetsToTxnResponse struct {
	ThrottleTimeMs int32 // Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	ErrorCode      int16 // The response error code, or 0 if there was no error. Versions: 0-1
}

// size of AddOffsetsToTxnResponse; Versions: 0-1
func (t AddOffsetsToTxnResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ThrottleTimeMs
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode AddOffsetsToTxnResponse; Versions: 0-1
func (t AddOffsetsToTxnResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode AddOffsetsToTxnResponse; Versions: 0-1
func (t *AddOffsetsToTxnResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// EndTxnRequest; ApiKey: 26, Versions: 0-1
type EndTxnRequest struct {
	TransactionalId string // The ID of the transaction to end. Versions: 0-1
	ProducerId      int64  // The producer ID. Versions: 0-1
	ProducerEpoch   int16  // The current epoch associated with the producer. Versions: 0-1
	Committed       bool   // True if the transaction was committed, false if it was aborted. Versions: 0-1
}

// size of EndTxnRequest; Versions: 0-1
func (t EndTxnRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TransactionalId) // TransactionalId
	sz += sizeof.Int64                     // ProducerId
	sz += sizeof.Int16                     // ProducerEpoch
	sz += sizeof.Bool                      // Committed
	return sz
}

// encode EndTxnRequest; Versions: 0-1
func (t EndTxnRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TransactionalId) // TransactionalId
	e.PutInt64(t.ProducerId)       // ProducerId
	e.PutInt16(t.ProducerEpoch)    // ProducerEpoch
	e.PutBool(t.Committed)         // Committed
}

// decode EndTxnRequest; Versions: 0-1
func (t *EndTxnRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TransactionalId, err = d.String()
	if err != nil {
		return err
	}
	t.ProducerId, err = d.Int64()
	if err != nil {
		return err
	}
	t.ProducerEpoch, err = d.Int16()
	if err != nil {
		return err
	}
	t.Committed, err = d.Bool()
	if err != nil {
		return err
	}
	return err
}

// EndTxnResponse; ApiKey: 26, Versions: 0-1
type EndTxnResponse struct {
	ThrottleTimeMs int32 // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	ErrorCode      int16 // The error code, or 0 if there was no error. Versions: 0-1
}

// size of EndTxnResponse; Versions: 0-1
func (t EndTxnResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ThrottleTimeMs
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode EndTxnResponse; Versions: 0-1
func (t EndTxnResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode EndTxnResponse; Versions: 0-1
func (t *EndTxnResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// WriteTxnMarkersRequest; ApiKey: 27, Versions: 0
type WriteTxnMarkersRequest struct {
	Markers []WritableTxnMarker27 // The transaction markers to be written. Versions: 0
}

// size of WriteTxnMarkersRequest; Versions: 0
func (t WriteTxnMarkersRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Markers
	for i := len(t.Markers) - 1; i >= 0; i-- {
		sz += t.Markers[i].Size(version)
	}
	return sz
}

// encode WriteTxnMarkersRequest; Versions: 0
func (t WriteTxnMarkersRequest) Encode(e *protocol.Encoder, version int16) {
	// Markers
	len0 := len(t.Markers)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Markers[i].Encode(e, version)
	}
}

// decode WriteTxnMarkersRequest; Versions: 0
func (t *WriteTxnMarkersRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Markers
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Markers = make([]WritableTxnMarker27, n)
		for i := 0; i < n; i++ {
			var item WritableTxnMarker27
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Markers[i] = item
		}
	}
	return err
}

type WritableTxnMarker27 struct {
	ProducerId        int64                      // The current producer ID. Versions: 0
	ProducerEpoch     int16                      // The current epoch associated with the producer ID. Versions: 0
	TransactionResult bool                       // The result of the transaction to write to the partitions (false = ABORT, true = COMMIT). Versions: 0
	Topics            []WritableTxnMarkerTopic27 // Each topic that we want to write transaction marker(s) for. Versions: 0
	CoordinatorEpoch  int32                      // Epoch associated with the transaction state partition hosted by this transaction coordinator Versions: 0
}

// size of WritableTxnMarker27; Versions: 0
func (t WritableTxnMarker27) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int64       // ProducerId
	sz += sizeof.Int16       // ProducerEpoch
	sz += sizeof.Bool        // TransactionResult
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	sz += sizeof.Int32 // CoordinatorEpoch
	return sz
}

// encode WritableTxnMarker27; Versions: 0
func (t WritableTxnMarker27) Encode(e *protocol.Encoder, version int16) {
	e.PutInt64(t.ProducerId)       // ProducerId
	e.PutInt16(t.ProducerEpoch)    // ProducerEpoch
	e.PutBool(t.TransactionResult) // TransactionResult
	// Topics
	len3 := len(t.Topics)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Topics[i].Encode(e, version)
	}
	e.PutInt32(t.CoordinatorEpoch) // CoordinatorEpoch
}

// decode WritableTxnMarker27; Versions: 0
func (t *WritableTxnMarker27) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ProducerId, err = d.Int64()
	if err != nil {
		return err
	}
	t.ProducerEpoch, err = d.Int16()
	if err != nil {
		return err
	}
	t.TransactionResult, err = d.Bool()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]WritableTxnMarkerTopic27, n)
		for i := 0; i < n; i++ {
			var item WritableTxnMarkerTopic27
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	t.CoordinatorEpoch, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

type WritableTxnMarkerTopic27 struct {
	Name             string  // The topic name. Versions: 0
	PartitionIndexes []int32 // The indexes of the partitions to write transaction markers for. Versions: 0
}

// size of WritableTxnMarkerTopic27; Versions: 0
func (t WritableTxnMarkerTopic27) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)                 // Name
	sz += sizeof.Int32Array(t.PartitionIndexes) // PartitionIndexes
	return sz
}

// encode WritableTxnMarkerTopic27; Versions: 0
func (t WritableTxnMarkerTopic27) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)                 // Name
	e.PutInt32Array(t.PartitionIndexes) // PartitionIndexes
}

// decode WritableTxnMarkerTopic27; Versions: 0
func (t *WritableTxnMarkerTopic27) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.PartitionIndexes, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// WriteTxnMarkersResponse; ApiKey: 27, Versions: 0
type WriteTxnMarkersResponse struct {
	Markers []WritableTxnMarkerResult27 // The results for writing makers. Versions: 0
}

// size of WriteTxnMarkersResponse; Versions: 0
func (t WriteTxnMarkersResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Markers
	for i := len(t.Markers) - 1; i >= 0; i-- {
		sz += t.Markers[i].Size(version)
	}
	return sz
}

// encode WriteTxnMarkersResponse; Versions: 0
func (t WriteTxnMarkersResponse) Encode(e *protocol.Encoder, version int16) {
	// Markers
	len0 := len(t.Markers)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Markers[i].Encode(e, version)
	}
}

// decode WriteTxnMarkersResponse; Versions: 0
func (t *WriteTxnMarkersResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Markers
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Markers = make([]WritableTxnMarkerResult27, n)
		for i := 0; i < n; i++ {
			var item WritableTxnMarkerResult27
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Markers[i] = item
		}
	}
	return err
}

type WritableTxnMarkerResult27 struct {
	ProducerId int64                            // The current producer ID in use by the transactional ID. Versions: 0
	Topics     []WritableTxnMarkerTopicResult27 // The results by topic. Versions: 0
}

// size of WritableTxnMarkerResult27; Versions: 0
func (t WritableTxnMarkerResult27) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int64       // ProducerId
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode WritableTxnMarkerResult27; Versions: 0
func (t WritableTxnMarkerResult27) Encode(e *protocol.Encoder, version int16) {
	e.PutInt64(t.ProducerId) // ProducerId
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode WritableTxnMarkerResult27; Versions: 0
func (t *WritableTxnMarkerResult27) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ProducerId, err = d.Int64()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]WritableTxnMarkerTopicResult27, n)
		for i := 0; i < n; i++ {
			var item WritableTxnMarkerTopicResult27
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type WritableTxnMarkerTopicResult27 struct {
	Name       string                               // The topic name. Versions: 0
	Partitions []WritableTxnMarkerPartitionResult27 // The results by partition. Versions: 0
}

// size of WritableTxnMarkerTopicResult27; Versions: 0
func (t WritableTxnMarkerTopicResult27) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode WritableTxnMarkerTopicResult27; Versions: 0
func (t WritableTxnMarkerTopicResult27) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode WritableTxnMarkerTopicResult27; Versions: 0
func (t *WritableTxnMarkerTopicResult27) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]WritableTxnMarkerPartitionResult27, n)
		for i := 0; i < n; i++ {
			var item WritableTxnMarkerPartitionResult27
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type WritableTxnMarkerPartitionResult27 struct {
	PartitionIndex int32 // The partition index. Versions: 0
	ErrorCode      int16 // The error code, or 0 if there was no error. Versions: 0
}

// size of WritableTxnMarkerPartitionResult27; Versions: 0
func (t WritableTxnMarkerPartitionResult27) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode WritableTxnMarkerPartitionResult27; Versions: 0
func (t WritableTxnMarkerPartitionResult27) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode WritableTxnMarkerPartitionResult27; Versions: 0
func (t *WritableTxnMarkerPartitionResult27) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// TxnOffsetCommitRequest; ApiKey: 28, Versions: 0-2
type TxnOffsetCommitRequest struct {
	TransactionalId string                          // The ID of the transaction. Versions: 0-2
	GroupId         string                          // The ID of the group. Versions: 0-2
	ProducerId      int64                           // The current producer ID in use by the transactional ID. Versions: 0-2
	ProducerEpoch   int16                           // The current epoch associated with the producer ID. Versions: 0-2
	Topics          []TxnOffsetCommitRequestTopic28 // Each topic that we want to committ offsets for. Versions: 0-2
}

// size of TxnOffsetCommitRequest; Versions: 0-2
func (t TxnOffsetCommitRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TransactionalId) // TransactionalId
	sz += sizeof.String(t.GroupId)         // GroupId
	sz += sizeof.Int64                     // ProducerId
	sz += sizeof.Int16                     // ProducerEpoch
	sz += sizeof.ArrayLength               // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode TxnOffsetCommitRequest; Versions: 0-2
func (t TxnOffsetCommitRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TransactionalId) // TransactionalId
	e.PutString(t.GroupId)         // GroupId
	e.PutInt64(t.ProducerId)       // ProducerId
	e.PutInt16(t.ProducerEpoch)    // ProducerEpoch
	// Topics
	len4 := len(t.Topics)
	e.PutArrayLength(len4)
	for i := 0; i < len4; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode TxnOffsetCommitRequest; Versions: 0-2
func (t *TxnOffsetCommitRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TransactionalId, err = d.String()
	if err != nil {
		return err
	}
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	t.ProducerId, err = d.Int64()
	if err != nil {
		return err
	}
	t.ProducerEpoch, err = d.Int16()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]TxnOffsetCommitRequestTopic28, n)
		for i := 0; i < n; i++ {
			var item TxnOffsetCommitRequestTopic28
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type TxnOffsetCommitRequestTopic28 struct {
	Name       string                              // The topic name. Versions: 0-2
	Partitions []TxnOffsetCommitRequestPartition28 // The partitions inside the topic that we want to committ offsets for. Versions: 0-2
}

// size of TxnOffsetCommitRequestTopic28; Versions: 0-2
func (t TxnOffsetCommitRequestTopic28) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode TxnOffsetCommitRequestTopic28; Versions: 0-2
func (t TxnOffsetCommitRequestTopic28) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode TxnOffsetCommitRequestTopic28; Versions: 0-2
func (t *TxnOffsetCommitRequestTopic28) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]TxnOffsetCommitRequestPartition28, n)
		for i := 0; i < n; i++ {
			var item TxnOffsetCommitRequestPartition28
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type TxnOffsetCommitRequestPartition28 struct {
	PartitionIndex       int32  // The index of the partition within the topic. Versions: 0-2
	CommittedOffset      int64  // The message offset to be committed. Versions: 0-2
	CommittedLeaderEpoch int32  // The leader epoch of the last consumed record. Versions: 0-2
	CommittedMetadata    string // Any associated metadata the client wants to keep. Versions: 0-2
}

// size of TxnOffsetCommitRequestPartition28; Versions: 0-2
func (t TxnOffsetCommitRequestPartition28) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int64 // CommittedOffset
	if version >= 2 {
		sz += sizeof.Int32 // CommittedLeaderEpoch
	}
	sz += sizeof.String(t.CommittedMetadata) // CommittedMetadata
	return sz
}

// encode TxnOffsetCommitRequestPartition28; Versions: 0-2
func (t TxnOffsetCommitRequestPartition28) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex)  // PartitionIndex
	e.PutInt64(t.CommittedOffset) // CommittedOffset
	if version >= 2 {
		e.PutInt32(t.CommittedLeaderEpoch) // CommittedLeaderEpoch
	}
	e.PutString(t.CommittedMetadata) // CommittedMetadata
}

// decode TxnOffsetCommitRequestPartition28; Versions: 0-2
func (t *TxnOffsetCommitRequestPartition28) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.CommittedOffset, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 2 {
		t.CommittedLeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.CommittedMetadata, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// TxnOffsetCommitResponse; ApiKey: 28, Versions: 0-2
type TxnOffsetCommitResponse struct {
	ThrottleTimeMs int32                            // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-2
	Topics         []TxnOffsetCommitResponseTopic28 // The responses for each topic. Versions: 0-2
}

// size of TxnOffsetCommitResponse; Versions: 0-2
func (t TxnOffsetCommitResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode TxnOffsetCommitResponse; Versions: 0-2
func (t TxnOffsetCommitResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode TxnOffsetCommitResponse; Versions: 0-2
func (t *TxnOffsetCommitResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]TxnOffsetCommitResponseTopic28, n)
		for i := 0; i < n; i++ {
			var item TxnOffsetCommitResponseTopic28
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type TxnOffsetCommitResponseTopic28 struct {
	Name       string                               // The topic name. Versions: 0-2
	Partitions []TxnOffsetCommitResponsePartition28 // The responses for each partition in the topic. Versions: 0-2
}

// size of TxnOffsetCommitResponseTopic28; Versions: 0-2
func (t TxnOffsetCommitResponseTopic28) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode TxnOffsetCommitResponseTopic28; Versions: 0-2
func (t TxnOffsetCommitResponseTopic28) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode TxnOffsetCommitResponseTopic28; Versions: 0-2
func (t *TxnOffsetCommitResponseTopic28) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]TxnOffsetCommitResponsePartition28, n)
		for i := 0; i < n; i++ {
			var item TxnOffsetCommitResponsePartition28
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type TxnOffsetCommitResponsePartition28 struct {
	PartitionIndex int32 // The partitition index. Versions: 0-2
	ErrorCode      int16 // The error code, or 0 if there was no error. Versions: 0-2
}

// size of TxnOffsetCommitResponsePartition28; Versions: 0-2
func (t TxnOffsetCommitResponsePartition28) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode TxnOffsetCommitResponsePartition28; Versions: 0-2
func (t TxnOffsetCommitResponsePartition28) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode TxnOffsetCommitResponsePartition28; Versions: 0-2
func (t *TxnOffsetCommitResponsePartition28) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// DescribeAclsRequest; ApiKey: 29, Versions: 0-1
type DescribeAclsRequest struct {
	ResourceType        int8   // The resource type. Versions: 0-1
	ResourceNameFilter  string // The resource name, or null to match any resource name. Versions: 0-1
	ResourcePatternType int8   // The resource pattern to match. Versions: 0-1
	PrincipalFilter     string // The principal to match, or null to match any principal. Versions: 0-1
	HostFilter          string // The host to match, or null to match any host. Versions: 0-1
	Operation           int8   // The operation to match. Versions: 0-1
	PermissionType      int8   // The permission type to match. Versions: 0-1
}

// size of DescribeAclsRequest; Versions: 0-1
func (t DescribeAclsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int8                         // ResourceType
	sz += sizeof.String(t.ResourceNameFilter) // ResourceNameFilter
	if version >= 1 {
		sz += sizeof.Int8 // ResourcePatternType
	}
	sz += sizeof.String(t.PrincipalFilter) // PrincipalFilter
	sz += sizeof.String(t.HostFilter)      // HostFilter
	sz += sizeof.Int8                      // Operation
	sz += sizeof.Int8                      // PermissionType
	return sz
}

// encode DescribeAclsRequest; Versions: 0-1
func (t DescribeAclsRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt8(t.ResourceType)         // ResourceType
	e.PutString(t.ResourceNameFilter) // ResourceNameFilter
	if version >= 1 {
		e.PutInt8(t.ResourcePatternType) // ResourcePatternType
	}
	e.PutString(t.PrincipalFilter) // PrincipalFilter
	e.PutString(t.HostFilter)      // HostFilter
	e.PutInt8(t.Operation)         // Operation
	e.PutInt8(t.PermissionType)    // PermissionType
}

// decode DescribeAclsRequest; Versions: 0-1
func (t *DescribeAclsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceNameFilter, err = d.String()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.ResourcePatternType, err = d.Int8()
		if err != nil {
			return err
		}
	}
	t.PrincipalFilter, err = d.String()
	if err != nil {
		return err
	}
	t.HostFilter, err = d.String()
	if err != nil {
		return err
	}
	t.Operation, err = d.Int8()
	if err != nil {
		return err
	}
	t.PermissionType, err = d.Int8()
	if err != nil {
		return err
	}
	return err
}

// DescribeAclsResponse; ApiKey: 29, Versions: 0-1
type DescribeAclsResponse struct {
	ThrottleTimeMs int32                    // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	ErrorCode      int16                    // The error code, or 0 if there was no error. Versions: 0-1
	ErrorMessage   string                   // The error message, or null if there was no error. Versions: 0-1
	Resources      []DescribeAclsResource29 // Each Resource that is referenced in an ACL. Versions: 0-1
}

// size of DescribeAclsResponse; Versions: 0-1
func (t DescribeAclsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32                  // ThrottleTimeMs
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.ArrayLength            // Resources
	for i := len(t.Resources) - 1; i >= 0; i-- {
		sz += t.Resources[i].Size(version)
	}
	return sz
}

// encode DescribeAclsResponse; Versions: 0-1
func (t DescribeAclsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutString(t.ErrorMessage)  // ErrorMessage
	// Resources
	len3 := len(t.Resources)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Resources[i].Encode(e, version)
	}
}

// decode DescribeAclsResponse; Versions: 0-1
func (t *DescribeAclsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	// Resources
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Resources = make([]DescribeAclsResource29, n)
		for i := 0; i < n; i++ {
			var item DescribeAclsResource29
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Resources[i] = item
		}
	}
	return err
}

type DescribeAclsResource29 struct {
	Type        int8               // The resource type. Versions: 0-1
	Name        string             // The resource name. Versions: 0-1
	PatternType int8               // The resource pattern type. Versions: 0-1
	Acls        []AclDescription29 // The ACLs. Versions: 0-1
}

// size of DescribeAclsResource29; Versions: 0-1
func (t DescribeAclsResource29) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int8           // Type
	sz += sizeof.String(t.Name) // Name
	if version >= 1 {
		sz += sizeof.Int8 // PatternType
	}
	sz += sizeof.ArrayLength // Acls
	for i := len(t.Acls) - 1; i >= 0; i-- {
		sz += t.Acls[i].Size(version)
	}
	return sz
}

// encode DescribeAclsResource29; Versions: 0-1
func (t DescribeAclsResource29) Encode(e *protocol.Encoder, version int16) {
	e.PutInt8(t.Type)   // Type
	e.PutString(t.Name) // Name
	if version >= 1 {
		e.PutInt8(t.PatternType) // PatternType
	}
	// Acls
	len3 := len(t.Acls)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Acls[i].Encode(e, version)
	}
}

// decode DescribeAclsResource29; Versions: 0-1
func (t *DescribeAclsResource29) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Type, err = d.Int8()
	if err != nil {
		return err
	}
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.PatternType, err = d.Int8()
		if err != nil {
			return err
		}
	}
	// Acls
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Acls = make([]AclDescription29, n)
		for i := 0; i < n; i++ {
			var item AclDescription29
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Acls[i] = item
		}
	}
	return err
}

type AclDescription29 struct {
	Principal      string // The ACL principal. Versions: 0-1
	Host           string // The ACL host. Versions: 0-1
	Operation      int8   // The ACL operation. Versions: 0-1
	PermissionType int8   // The ACL permission type. Versions: 0-1
}

// size of AclDescription29; Versions: 0-1
func (t AclDescription29) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Principal) // Principal
	sz += sizeof.String(t.Host)      // Host
	sz += sizeof.Int8                // Operation
	sz += sizeof.Int8                // PermissionType
	return sz
}

// encode AclDescription29; Versions: 0-1
func (t AclDescription29) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Principal)    // Principal
	e.PutString(t.Host)         // Host
	e.PutInt8(t.Operation)      // Operation
	e.PutInt8(t.PermissionType) // PermissionType
}

// decode AclDescription29; Versions: 0-1
func (t *AclDescription29) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Principal, err = d.String()
	if err != nil {
		return err
	}
	t.Host, err = d.String()
	if err != nil {
		return err
	}
	t.Operation, err = d.Int8()
	if err != nil {
		return err
	}
	t.PermissionType, err = d.Int8()
	if err != nil {
		return err
	}
	return err
}

// CreateAclsRequest; ApiKey: 30, Versions: 0-1
type CreateAclsRequest struct {
	Creations []CreatableAcl30 // The ACLs that we want to create. Versions: 0-1
}

// size of CreateAclsRequest; Versions: 0-1
func (t CreateAclsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Creations
	for i := len(t.Creations) - 1; i >= 0; i-- {
		sz += t.Creations[i].Size(version)
	}
	return sz
}

// encode CreateAclsRequest; Versions: 0-1
func (t CreateAclsRequest) Encode(e *protocol.Encoder, version int16) {
	// Creations
	len0 := len(t.Creations)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Creations[i].Encode(e, version)
	}
}

// decode CreateAclsRequest; Versions: 0-1
func (t *CreateAclsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Creations
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Creations = make([]CreatableAcl30, n)
		for i := 0; i < n; i++ {
			var item CreatableAcl30
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Creations[i] = item
		}
	}
	return err
}

type CreatableAcl30 struct {
	ResourceType        int8   // The type of the resource. Versions: 0-1
	ResourceName        string // The resource name for the ACL. Versions: 0-1
	ResourcePatternType int8   // The pattern type for the ACL. Versions: 0-1
	Principal           string // The principal for the ACL. Versions: 0-1
	Host                string // The host for the ACL. Versions: 0-1
	Operation           int8   // The operation type for the ACL (read, write, etc.). Versions: 0-1
	PermissionType      int8   // The permission type for the ACL (allow, deny, etc.). Versions: 0-1
}

// size of CreatableAcl30; Versions: 0-1
func (t CreatableAcl30) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int8                   // ResourceType
	sz += sizeof.String(t.ResourceName) // ResourceName
	if version >= 1 {
		sz += sizeof.Int8 // ResourcePatternType
	}
	sz += sizeof.String(t.Principal) // Principal
	sz += sizeof.String(t.Host)      // Host
	sz += sizeof.Int8                // Operation
	sz += sizeof.Int8                // PermissionType
	return sz
}

// encode CreatableAcl30; Versions: 0-1
func (t CreatableAcl30) Encode(e *protocol.Encoder, version int16) {
	e.PutInt8(t.ResourceType)   // ResourceType
	e.PutString(t.ResourceName) // ResourceName
	if version >= 1 {
		e.PutInt8(t.ResourcePatternType) // ResourcePatternType
	}
	e.PutString(t.Principal)    // Principal
	e.PutString(t.Host)         // Host
	e.PutInt8(t.Operation)      // Operation
	e.PutInt8(t.PermissionType) // PermissionType
}

// decode CreatableAcl30; Versions: 0-1
func (t *CreatableAcl30) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceName, err = d.String()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.ResourcePatternType, err = d.Int8()
		if err != nil {
			return err
		}
	}
	t.Principal, err = d.String()
	if err != nil {
		return err
	}
	t.Host, err = d.String()
	if err != nil {
		return err
	}
	t.Operation, err = d.Int8()
	if err != nil {
		return err
	}
	t.PermissionType, err = d.Int8()
	if err != nil {
		return err
	}
	return err
}

// CreateAclsResponse; ApiKey: 30, Versions: 0-1
type CreateAclsResponse struct {
	ThrottleTimeMs int32                  // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	Results        []CreatableAclResult30 // The results for each ACL creation. Versions: 0-1
}

// size of CreateAclsResponse; Versions: 0-1
func (t CreateAclsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].Size(version)
	}
	return sz
}

// encode CreateAclsResponse; Versions: 0-1
func (t CreateAclsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].Encode(e, version)
	}
}

// decode CreateAclsResponse; Versions: 0-1
func (t *CreateAclsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]CreatableAclResult30, n)
		for i := 0; i < n; i++ {
			var item CreatableAclResult30
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type CreatableAclResult30 struct {
	ErrorCode    int16  // The result error, or zero if there was no error. Versions: 0-1
	ErrorMessage string // The result message, or null if there was no error. Versions: 0-1
}

// size of CreatableAclResult30; Versions: 0-1
func (t CreatableAclResult30) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	return sz
}

// encode CreatableAclResult30; Versions: 0-1
func (t CreatableAclResult30) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
}

// decode CreatableAclResult30; Versions: 0-1
func (t *CreatableAclResult30) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// DeleteAclsRequest; ApiKey: 31, Versions: 0-1
type DeleteAclsRequest struct {
	Filters []DeleteAclsFilter31 // The filters to use when deleting ACLs. Versions: 0-1
}

// size of DeleteAclsRequest; Versions: 0-1
func (t DeleteAclsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Filters
	for i := len(t.Filters) - 1; i >= 0; i-- {
		sz += t.Filters[i].Size(version)
	}
	return sz
}

// encode DeleteAclsRequest; Versions: 0-1
func (t DeleteAclsRequest) Encode(e *protocol.Encoder, version int16) {
	// Filters
	len0 := len(t.Filters)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Filters[i].Encode(e, version)
	}
}

// decode DeleteAclsRequest; Versions: 0-1
func (t *DeleteAclsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Filters
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Filters = make([]DeleteAclsFilter31, n)
		for i := 0; i < n; i++ {
			var item DeleteAclsFilter31
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Filters[i] = item
		}
	}
	return err
}

type DeleteAclsFilter31 struct {
	ResourceTypeFilter int8   // The resource type. Versions: 0-1
	ResourceNameFilter string // The resource name. Versions: 0-1
	PatternTypeFilter  int8   // The pattern type. Versions: 0-1
	PrincipalFilter    string // The principal filter, or null to accept all principals. Versions: 0-1
	HostFilter         string // The host filter, or null to accept all hosts. Versions: 0-1
	Operation          int8   // The ACL operation. Versions: 0-1
	PermissionType     int8   // The permission type. Versions: 0-1
}

// size of DeleteAclsFilter31; Versions: 0-1
func (t DeleteAclsFilter31) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int8                         // ResourceTypeFilter
	sz += sizeof.String(t.ResourceNameFilter) // ResourceNameFilter
	if version >= 1 {
		sz += sizeof.Int8 // PatternTypeFilter
	}
	sz += sizeof.String(t.PrincipalFilter) // PrincipalFilter
	sz += sizeof.String(t.HostFilter)      // HostFilter
	sz += sizeof.Int8                      // Operation
	sz += sizeof.Int8                      // PermissionType
	return sz
}

// encode DeleteAclsFilter31; Versions: 0-1
func (t DeleteAclsFilter31) Encode(e *protocol.Encoder, version int16) {
	e.PutInt8(t.ResourceTypeFilter)   // ResourceTypeFilter
	e.PutString(t.ResourceNameFilter) // ResourceNameFilter
	if version >= 1 {
		e.PutInt8(t.PatternTypeFilter) // PatternTypeFilter
	}
	e.PutString(t.PrincipalFilter) // PrincipalFilter
	e.PutString(t.HostFilter)      // HostFilter
	e.PutInt8(t.Operation)         // Operation
	e.PutInt8(t.PermissionType)    // PermissionType
}

// decode DeleteAclsFilter31; Versions: 0-1
func (t *DeleteAclsFilter31) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ResourceTypeFilter, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceNameFilter, err = d.String()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.PatternTypeFilter, err = d.Int8()
		if err != nil {
			return err
		}
	}
	t.PrincipalFilter, err = d.String()
	if err != nil {
		return err
	}
	t.HostFilter, err = d.String()
	if err != nil {
		return err
	}
	t.Operation, err = d.Int8()
	if err != nil {
		return err
	}
	t.PermissionType, err = d.Int8()
	if err != nil {
		return err
	}
	return err
}

// DeleteAclsResponse; ApiKey: 31, Versions: 0-1
type DeleteAclsResponse struct {
	ThrottleTimeMs int32                      // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	FilterResults  []DeleteAclsFilterResult31 // The results for each filter. Versions: 0-1
}

// size of DeleteAclsResponse; Versions: 0-1
func (t DeleteAclsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // FilterResults
	for i := len(t.FilterResults) - 1; i >= 0; i-- {
		sz += t.FilterResults[i].Size(version)
	}
	return sz
}

// encode DeleteAclsResponse; Versions: 0-1
func (t DeleteAclsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// FilterResults
	len1 := len(t.FilterResults)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.FilterResults[i].Encode(e, version)
	}
}

// decode DeleteAclsResponse; Versions: 0-1
func (t *DeleteAclsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// FilterResults
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.FilterResults = make([]DeleteAclsFilterResult31, n)
		for i := 0; i < n; i++ {
			var item DeleteAclsFilterResult31
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.FilterResults[i] = item
		}
	}
	return err
}

type DeleteAclsFilterResult31 struct {
	ErrorCode    int16                     // The error code, or 0 if the filter succeeded. Versions: 0-1
	ErrorMessage string                    // The error message, or null if the filter succeeded. Versions: 0-1
	MatchingAcls []DeleteAclsMatchingAcl31 // The ACLs which matched this filter. Versions: 0-1
}

// size of DeleteAclsFilterResult31; Versions: 0-1
func (t DeleteAclsFilterResult31) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.ArrayLength            // MatchingAcls
	for i := len(t.MatchingAcls) - 1; i >= 0; i-- {
		sz += t.MatchingAcls[i].Size(version)
	}
	return sz
}

// encode DeleteAclsFilterResult31; Versions: 0-1
func (t DeleteAclsFilterResult31) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
	// MatchingAcls
	len2 := len(t.MatchingAcls)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.MatchingAcls[i].Encode(e, version)
	}
}

// decode DeleteAclsFilterResult31; Versions: 0-1
func (t *DeleteAclsFilterResult31) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	// MatchingAcls
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.MatchingAcls = make([]DeleteAclsMatchingAcl31, n)
		for i := 0; i < n; i++ {
			var item DeleteAclsMatchingAcl31
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.MatchingAcls[i] = item
		}
	}
	return err
}

type DeleteAclsMatchingAcl31 struct {
	ErrorCode      int16  // The deletion error code, or 0 if the deletion succeeded. Versions: 0-1
	ErrorMessage   string // The deletion error message, or null if the deletion succeeded. Versions: 0-1
	ResourceType   int8   // The ACL resource type. Versions: 0-1
	ResourceName   string // The ACL resource name. Versions: 0-1
	PatternType    int8   // The ACL resource pattern type. Versions: 0-1
	Principal      string // The ACL principal. Versions: 0-1
	Host           string // The ACL host. Versions: 0-1
	Operation      int8   // The ACL operation. Versions: 0-1
	PermissionType int8   // The ACL permission type. Versions: 0-1
}

// size of DeleteAclsMatchingAcl31; Versions: 0-1
func (t DeleteAclsMatchingAcl31) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.Int8                   // ResourceType
	sz += sizeof.String(t.ResourceName) // ResourceName
	if version >= 1 {
		sz += sizeof.Int8 // PatternType
	}
	sz += sizeof.String(t.Principal) // Principal
	sz += sizeof.String(t.Host)      // Host
	sz += sizeof.Int8                // Operation
	sz += sizeof.Int8                // PermissionType
	return sz
}

// encode DeleteAclsMatchingAcl31; Versions: 0-1
func (t DeleteAclsMatchingAcl31) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
	e.PutInt8(t.ResourceType)   // ResourceType
	e.PutString(t.ResourceName) // ResourceName
	if version >= 1 {
		e.PutInt8(t.PatternType) // PatternType
	}
	e.PutString(t.Principal)    // Principal
	e.PutString(t.Host)         // Host
	e.PutInt8(t.Operation)      // Operation
	e.PutInt8(t.PermissionType) // PermissionType
}

// decode DeleteAclsMatchingAcl31; Versions: 0-1
func (t *DeleteAclsMatchingAcl31) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceName, err = d.String()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.PatternType, err = d.Int8()
		if err != nil {
			return err
		}
	}
	t.Principal, err = d.String()
	if err != nil {
		return err
	}
	t.Host, err = d.String()
	if err != nil {
		return err
	}
	t.Operation, err = d.Int8()
	if err != nil {
		return err
	}
	t.PermissionType, err = d.Int8()
	if err != nil {
		return err
	}
	return err
}

// DescribeConfigsRequest; ApiKey: 32, Versions: 0-2
type DescribeConfigsRequest struct {
	Resources      []DescribeConfigsResource32 // The resources whose configurations we want to describe. Versions: 0-2
	IncludeSynoyms bool                        // True if we should include all synonyms. Versions: 0-2
}

// size of DescribeConfigsRequest; Versions: 0-2
func (t DescribeConfigsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Resources
	for i := len(t.Resources) - 1; i >= 0; i-- {
		sz += t.Resources[i].Size(version)
	}
	if version >= 1 {
		sz += sizeof.Bool // IncludeSynoyms
	}
	return sz
}

// encode DescribeConfigsRequest; Versions: 0-2
func (t DescribeConfigsRequest) Encode(e *protocol.Encoder, version int16) {
	// Resources
	len0 := len(t.Resources)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Resources[i].Encode(e, version)
	}
	if version >= 1 {
		e.PutBool(t.IncludeSynoyms) // IncludeSynoyms
	}
}

// decode DescribeConfigsRequest; Versions: 0-2
func (t *DescribeConfigsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Resources
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Resources = make([]DescribeConfigsResource32, n)
		for i := 0; i < n; i++ {
			var item DescribeConfigsResource32
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Resources[i] = item
		}
	}
	if version >= 1 {
		t.IncludeSynoyms, err = d.Bool()
		if err != nil {
			return err
		}
	}
	return err
}

type DescribeConfigsResource32 struct {
	ResourceType      int8     // The resource type. Versions: 0-2
	ResourceName      string   // The resource name. Versions: 0-2
	ConfigurationKeys []string // The configuration keys to list, or null to list all configuration keys. Versions: 0-2
}

// size of DescribeConfigsResource32; Versions: 0-2
func (t DescribeConfigsResource32) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int8                             // ResourceType
	sz += sizeof.String(t.ResourceName)           // ResourceName
	sz += sizeof.StringArray(t.ConfigurationKeys) // ConfigurationKeys
	return sz
}

// encode DescribeConfigsResource32; Versions: 0-2
func (t DescribeConfigsResource32) Encode(e *protocol.Encoder, version int16) {
	e.PutInt8(t.ResourceType)             // ResourceType
	e.PutString(t.ResourceName)           // ResourceName
	e.PutStringArray(t.ConfigurationKeys) // ConfigurationKeys
}

// decode DescribeConfigsResource32; Versions: 0-2
func (t *DescribeConfigsResource32) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceName, err = d.String()
	if err != nil {
		return err
	}
	t.ConfigurationKeys, err = d.StringArray()
	if err != nil {
		return err
	}
	return err
}

// DescribeConfigsResponse; ApiKey: 32, Versions: 0-2
type DescribeConfigsResponse struct {
	ThrottleTimeMs int32                     // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-2
	Results        []DescribeConfigsResult32 // The results for each resource. Versions: 0-2
}

// size of DescribeConfigsResponse; Versions: 0-2
func (t DescribeConfigsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].Size(version)
	}
	return sz
}

// encode DescribeConfigsResponse; Versions: 0-2
func (t DescribeConfigsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].Encode(e, version)
	}
}

// decode DescribeConfigsResponse; Versions: 0-2
func (t *DescribeConfigsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]DescribeConfigsResult32, n)
		for i := 0; i < n; i++ {
			var item DescribeConfigsResult32
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type DescribeConfigsResult32 struct {
	ErrorCode    int16                             // The error code, or 0 if we were able to successfully describe the configurations. Versions: 0-2
	ErrorMessage string                            // The error message, or null if we were able to successfully describe the configurations. Versions: 0-2
	ResourceType int8                              // The resource type. Versions: 0-2
	ResourceName string                            // The resource name. Versions: 0-2
	Configs      []DescribeConfigsResourceResult32 // Each listed configuration. Versions: 0-2
}

// size of DescribeConfigsResult32; Versions: 0-2
func (t DescribeConfigsResult32) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.Int8                   // ResourceType
	sz += sizeof.String(t.ResourceName) // ResourceName
	sz += sizeof.ArrayLength            // Configs
	for i := len(t.Configs) - 1; i >= 0; i-- {
		sz += t.Configs[i].Size(version)
	}
	return sz
}

// encode DescribeConfigsResult32; Versions: 0-2
func (t DescribeConfigsResult32) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
	e.PutInt8(t.ResourceType)   // ResourceType
	e.PutString(t.ResourceName) // ResourceName
	// Configs
	len4 := len(t.Configs)
	e.PutArrayLength(len4)
	for i := 0; i < len4; i++ {
		t.Configs[i].Encode(e, version)
	}
}

// decode DescribeConfigsResult32; Versions: 0-2
func (t *DescribeConfigsResult32) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceName, err = d.String()
	if err != nil {
		return err
	}
	// Configs
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Configs = make([]DescribeConfigsResourceResult32, n)
		for i := 0; i < n; i++ {
			var item DescribeConfigsResourceResult32
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Configs[i] = item
		}
	}
	return err
}

type DescribeConfigsResourceResult32 struct {
	Name         string                     // The configuration name. Versions: 0-2
	Value        string                     // The configuration value. Versions: 0-2
	ReadOnly     bool                       // True if the configuration is read-only. Versions: 0-2
	IsDefault    bool                       // True if the configuration is not set. Versions: 0-2
	ConfigSource int8                       // The configuration source. Versions: 0-2
	IsSensitive  bool                       // True if this configuration is sensitive. Versions: 0-2
	Synonyms     []DescribeConfigsSynonym32 // The synonyms for this configuration key. Versions: 0-2
}

// size of DescribeConfigsResourceResult32; Versions: 0-2
func (t DescribeConfigsResourceResult32) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)  // Name
	sz += sizeof.String(t.Value) // Value
	sz += sizeof.Bool            // ReadOnly
	if version >= 0 && version <= 0 {
		sz += sizeof.Bool // IsDefault
	}
	if version >= 1 {
		sz += sizeof.Int8 // ConfigSource
	}
	sz += sizeof.Bool // IsSensitive
	if version >= 1 {
		sz += sizeof.ArrayLength // Synonyms
		for i := len(t.Synonyms) - 1; i >= 0; i-- {
			sz += t.Synonyms[i].Size(version)
		}
	}
	return sz
}

// encode DescribeConfigsResourceResult32; Versions: 0-2
func (t DescribeConfigsResourceResult32) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)   // Name
	e.PutString(t.Value)  // Value
	e.PutBool(t.ReadOnly) // ReadOnly
	if version >= 0 && version <= 0 {
		e.PutBool(t.IsDefault) // IsDefault
	}
	if version >= 1 {
		e.PutInt8(t.ConfigSource) // ConfigSource
	}
	e.PutBool(t.IsSensitive) // IsSensitive
	if version >= 1 {
		// Synonyms
		len6 := len(t.Synonyms)
		e.PutArrayLength(len6)
		for i := 0; i < len6; i++ {
			t.Synonyms[i].Encode(e, version)
		}
	}
}

// decode DescribeConfigsResourceResult32; Versions: 0-2
func (t *DescribeConfigsResourceResult32) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.Value, err = d.String()
	if err != nil {
		return err
	}
	t.ReadOnly, err = d.Bool()
	if err != nil {
		return err
	}
	if version >= 0 && version <= 0 {
		t.IsDefault, err = d.Bool()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.ConfigSource, err = d.Int8()
		if err != nil {
			return err
		}
	}
	t.IsSensitive, err = d.Bool()
	if err != nil {
		return err
	}
	if version >= 1 {
		// Synonyms
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Synonyms = make([]DescribeConfigsSynonym32, n)
			for i := 0; i < n; i++ {
				var item DescribeConfigsSynonym32
				if err := (&item).Decode(d, version); err != nil {
					return err
				}
				t.Synonyms[i] = item
			}
		}
	}
	return err
}

type DescribeConfigsSynonym32 struct {
	Name   string // The synonym name. Versions: 0-2
	Value  string // The synonym value. Versions: 0-2
	Source int8   // The synonym source. Versions: 0-2
}

// size of DescribeConfigsSynonym32; Versions: 0-2
func (t DescribeConfigsSynonym32) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.String(t.Name) // Name
	}
	if version >= 1 {
		sz += sizeof.String(t.Value) // Value
	}
	if version >= 1 {
		sz += sizeof.Int8 // Source
	}
	return sz
}

// encode DescribeConfigsSynonym32; Versions: 0-2
func (t DescribeConfigsSynonym32) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutString(t.Name) // Name
	}
	if version >= 1 {
		e.PutString(t.Value) // Value
	}
	if version >= 1 {
		e.PutInt8(t.Source) // Source
	}
}

// decode DescribeConfigsSynonym32; Versions: 0-2
func (t *DescribeConfigsSynonym32) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.Name, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.Value, err = d.String()
		if err != nil {
			return err
		}
	}
	if version >= 1 {
		t.Source, err = d.Int8()
		if err != nil {
			return err
		}
	}
	return err
}

// AlterConfigsRequest; ApiKey: 33, Versions: 0-1
type AlterConfigsRequest struct {
	Resources    []AlterConfigsResource33 // The updates for each resource. Versions: 0-1
	ValidateOnly bool                     // True if we should validate the request, but not change the configurations. Versions: 0-1
}

// size of AlterConfigsRequest; Versions: 0-1
func (t AlterConfigsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Resources
	for i := len(t.Resources) - 1; i >= 0; i-- {
		sz += t.Resources[i].Size(version)
	}
	sz += sizeof.Bool // ValidateOnly
	return sz
}

// encode AlterConfigsRequest; Versions: 0-1
func (t AlterConfigsRequest) Encode(e *protocol.Encoder, version int16) {
	// Resources
	len0 := len(t.Resources)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Resources[i].Encode(e, version)
	}
	e.PutBool(t.ValidateOnly) // ValidateOnly
}

// decode AlterConfigsRequest; Versions: 0-1
func (t *AlterConfigsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Resources
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Resources = make([]AlterConfigsResource33, n)
		for i := 0; i < n; i++ {
			var item AlterConfigsResource33
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Resources[i] = item
		}
	}
	t.ValidateOnly, err = d.Bool()
	if err != nil {
		return err
	}
	return err
}

type AlterConfigsResource33 struct {
	ResourceType int8                // The resource type. Versions: 0-1
	ResourceName string              // The resource name. Versions: 0-1
	Configs      []AlterableConfig33 // The configurations. Versions: 0-1
}

// size of AlterConfigsResource33; Versions: 0-1
func (t AlterConfigsResource33) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int8                   // ResourceType
	sz += sizeof.String(t.ResourceName) // ResourceName
	sz += sizeof.ArrayLength            // Configs
	for i := len(t.Configs) - 1; i >= 0; i-- {
		sz += t.Configs[i].Size(version)
	}
	return sz
}

// encode AlterConfigsResource33; Versions: 0-1
func (t AlterConfigsResource33) Encode(e *protocol.Encoder, version int16) {
	e.PutInt8(t.ResourceType)   // ResourceType
	e.PutString(t.ResourceName) // ResourceName
	// Configs
	len2 := len(t.Configs)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Configs[i].Encode(e, version)
	}
}

// decode AlterConfigsResource33; Versions: 0-1
func (t *AlterConfigsResource33) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceName, err = d.String()
	if err != nil {
		return err
	}
	// Configs
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Configs = make([]AlterableConfig33, n)
		for i := 0; i < n; i++ {
			var item AlterableConfig33
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Configs[i] = item
		}
	}
	return err
}

type AlterableConfig33 struct {
	Name  string // The configuration key name. Versions: 0-1
	Value string // The value to set for the configuration key. Versions: 0-1
}

// size of AlterableConfig33; Versions: 0-1
func (t AlterableConfig33) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)  // Name
	sz += sizeof.String(t.Value) // Value
	return sz
}

// encode AlterableConfig33; Versions: 0-1
func (t AlterableConfig33) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)  // Name
	e.PutString(t.Value) // Value
}

// decode AlterableConfig33; Versions: 0-1
func (t *AlterableConfig33) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.Value, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// AlterConfigsResponse; ApiKey: 33, Versions: 0-1
type AlterConfigsResponse struct {
	ThrottleTimeMs int32                            // Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	Responses      []AlterConfigsResourceResponse33 // The responses for each resource. Versions: 0-1
}

// size of AlterConfigsResponse; Versions: 0-1
func (t AlterConfigsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Responses
	for i := len(t.Responses) - 1; i >= 0; i-- {
		sz += t.Responses[i].Size(version)
	}
	return sz
}

// encode AlterConfigsResponse; Versions: 0-1
func (t AlterConfigsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Responses
	len1 := len(t.Responses)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Responses[i].Encode(e, version)
	}
}

// decode AlterConfigsResponse; Versions: 0-1
func (t *AlterConfigsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Responses
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Responses = make([]AlterConfigsResourceResponse33, n)
		for i := 0; i < n; i++ {
			var item AlterConfigsResourceResponse33
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Responses[i] = item
		}
	}
	return err
}

type AlterConfigsResourceResponse33 struct {
	ErrorCode    int16  // The resource error code. Versions: 0-1
	ErrorMessage string // The resource error message, or null if there was no error. Versions: 0-1
	ResourceType int8   // The resource type. Versions: 0-1
	ResourceName string // The resource name. Versions: 0-1
}

// size of AlterConfigsResourceResponse33; Versions: 0-1
func (t AlterConfigsResourceResponse33) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.Int8                   // ResourceType
	sz += sizeof.String(t.ResourceName) // ResourceName
	return sz
}

// encode AlterConfigsResourceResponse33; Versions: 0-1
func (t AlterConfigsResourceResponse33) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
	e.PutInt8(t.ResourceType)   // ResourceType
	e.PutString(t.ResourceName) // ResourceName
}

// decode AlterConfigsResourceResponse33; Versions: 0-1
func (t *AlterConfigsResourceResponse33) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceName, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// AlterReplicaLogDirsRequest; ApiKey: 34, Versions: 0-1
type AlterReplicaLogDirsRequest struct {
	Dirs []AlterReplicaLogDir34 // The alterations to make for each directory. Versions: 0-1
}

// size of AlterReplicaLogDirsRequest; Versions: 0-1
func (t AlterReplicaLogDirsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Dirs
	for i := len(t.Dirs) - 1; i >= 0; i-- {
		sz += t.Dirs[i].Size(version)
	}
	return sz
}

// encode AlterReplicaLogDirsRequest; Versions: 0-1
func (t AlterReplicaLogDirsRequest) Encode(e *protocol.Encoder, version int16) {
	// Dirs
	len0 := len(t.Dirs)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Dirs[i].Encode(e, version)
	}
}

// decode AlterReplicaLogDirsRequest; Versions: 0-1
func (t *AlterReplicaLogDirsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Dirs
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Dirs = make([]AlterReplicaLogDir34, n)
		for i := 0; i < n; i++ {
			var item AlterReplicaLogDir34
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Dirs[i] = item
		}
	}
	return err
}

type AlterReplicaLogDir34 struct {
	Path   string                      // The absolute directory path. Versions: 0-1
	Topics []AlterReplicaLogDirTopic34 // The topics to add to the directory. Versions: 0-1
}

// size of AlterReplicaLogDir34; Versions: 0-1
func (t AlterReplicaLogDir34) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Path) // Path
	sz += sizeof.ArrayLength    // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode AlterReplicaLogDir34; Versions: 0-1
func (t AlterReplicaLogDir34) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Path) // Path
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode AlterReplicaLogDir34; Versions: 0-1
func (t *AlterReplicaLogDir34) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Path, err = d.String()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]AlterReplicaLogDirTopic34, n)
		for i := 0; i < n; i++ {
			var item AlterReplicaLogDirTopic34
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type AlterReplicaLogDirTopic34 struct {
	Name       string  // The topic name. Versions: 0-1
	Partitions []int32 // The partition indexes. Versions: 0-1
}

// size of AlterReplicaLogDirTopic34; Versions: 0-1
func (t AlterReplicaLogDirTopic34) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)           // Name
	sz += sizeof.Int32Array(t.Partitions) // Partitions
	return sz
}

// encode AlterReplicaLogDirTopic34; Versions: 0-1
func (t AlterReplicaLogDirTopic34) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)           // Name
	e.PutInt32Array(t.Partitions) // Partitions
}

// decode AlterReplicaLogDirTopic34; Versions: 0-1
func (t *AlterReplicaLogDirTopic34) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.Partitions, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// AlterReplicaLogDirsResponse; ApiKey: 34, Versions: 0-1
type AlterReplicaLogDirsResponse struct {
	ThrottleTimeMs int32                             // Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	Results        []AlterReplicaLogDirTopicResult34 // The results for each topic. Versions: 0-1
}

// size of AlterReplicaLogDirsResponse; Versions: 0-1
func (t AlterReplicaLogDirsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].Size(version)
	}
	return sz
}

// encode AlterReplicaLogDirsResponse; Versions: 0-1
func (t AlterReplicaLogDirsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].Encode(e, version)
	}
}

// decode AlterReplicaLogDirsResponse; Versions: 0-1
func (t *AlterReplicaLogDirsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]AlterReplicaLogDirTopicResult34, n)
		for i := 0; i < n; i++ {
			var item AlterReplicaLogDirTopicResult34
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type AlterReplicaLogDirTopicResult34 struct {
	TopicName  string                                // The name of the topic. Versions: 0-1
	Partitions []AlterReplicaLogDirPartitionResult34 // The results for each partition. Versions: 0-1
}

// size of AlterReplicaLogDirTopicResult34; Versions: 0-1
func (t AlterReplicaLogDirTopicResult34) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.TopicName) // TopicName
	sz += sizeof.ArrayLength         // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode AlterReplicaLogDirTopicResult34; Versions: 0-1
func (t AlterReplicaLogDirTopicResult34) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.TopicName) // TopicName
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode AlterReplicaLogDirTopicResult34; Versions: 0-1
func (t *AlterReplicaLogDirTopicResult34) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TopicName, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]AlterReplicaLogDirPartitionResult34, n)
		for i := 0; i < n; i++ {
			var item AlterReplicaLogDirPartitionResult34
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type AlterReplicaLogDirPartitionResult34 struct {
	PartitionIndex int32 // The partition index. Versions: 0-1
	ErrorCode      int16 // The error code, or 0 if there was no error. Versions: 0-1
}

// size of AlterReplicaLogDirPartitionResult34; Versions: 0-1
func (t AlterReplicaLogDirPartitionResult34) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode AlterReplicaLogDirPartitionResult34; Versions: 0-1
func (t AlterReplicaLogDirPartitionResult34) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode AlterReplicaLogDirPartitionResult34; Versions: 0-1
func (t *AlterReplicaLogDirPartitionResult34) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// DescribeLogDirsRequest; ApiKey: 35, Versions: 0-1
type DescribeLogDirsRequest struct {
	Topics []DescribableLogDirTopic35 // Each topic that we want to describe log directories for, or null for all topics. Versions: 0-1
}

// size of DescribeLogDirsRequest; Versions: 0-1
func (t DescribeLogDirsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode DescribeLogDirsRequest; Versions: 0-1
func (t DescribeLogDirsRequest) Encode(e *protocol.Encoder, version int16) {
	// Topics
	len0 := len(t.Topics)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode DescribeLogDirsRequest; Versions: 0-1
func (t *DescribeLogDirsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]DescribableLogDirTopic35, n)
		for i := 0; i < n; i++ {
			var item DescribableLogDirTopic35
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type DescribableLogDirTopic35 struct {
	Topic          string  // The topic name Versions: 0-1
	PartitionIndex []int32 // The partition indxes. Versions: 0-1
}

// size of DescribableLogDirTopic35; Versions: 0-1
func (t DescribableLogDirTopic35) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Topic)              // Topic
	sz += sizeof.Int32Array(t.PartitionIndex) // PartitionIndex
	return sz
}

// encode DescribableLogDirTopic35; Versions: 0-1
func (t DescribableLogDirTopic35) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Topic)              // Topic
	e.PutInt32Array(t.PartitionIndex) // PartitionIndex
}

// decode DescribableLogDirTopic35; Versions: 0-1
func (t *DescribableLogDirTopic35) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Topic, err = d.String()
	if err != nil {
		return err
	}
	t.PartitionIndex, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// DescribeLogDirsResponse; ApiKey: 35, Versions: 0-1
type DescribeLogDirsResponse struct {
	ThrottleTimeMs int32                     // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	Results        []DescribeLogDirsResult35 // The log directories. Versions: 0-1
}

// size of DescribeLogDirsResponse; Versions: 0-1
func (t DescribeLogDirsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].Size(version)
	}
	return sz
}

// encode DescribeLogDirsResponse; Versions: 0-1
func (t DescribeLogDirsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].Encode(e, version)
	}
}

// decode DescribeLogDirsResponse; Versions: 0-1
func (t *DescribeLogDirsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]DescribeLogDirsResult35, n)
		for i := 0; i < n; i++ {
			var item DescribeLogDirsResult35
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type DescribeLogDirsResult35 struct {
	ErrorCode int16                    // The error code, or 0 if there was no error. Versions: 0-1
	LogDir    string                   // The absolute log directory path. Versions: 0-1
	Topics    []DescribeLogDirsTopic35 // Each topic. Versions: 0-1
}

// size of DescribeLogDirsResult35; Versions: 0-1
func (t DescribeLogDirsResult35) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16            // ErrorCode
	sz += sizeof.String(t.LogDir) // LogDir
	sz += sizeof.ArrayLength      // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode DescribeLogDirsResult35; Versions: 0-1
func (t DescribeLogDirsResult35) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
	e.PutString(t.LogDir)   // LogDir
	// Topics
	len2 := len(t.Topics)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode DescribeLogDirsResult35; Versions: 0-1
func (t *DescribeLogDirsResult35) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.LogDir, err = d.String()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]DescribeLogDirsTopic35, n)
		for i := 0; i < n; i++ {
			var item DescribeLogDirsTopic35
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type DescribeLogDirsTopic35 struct {
	Name       string                       // The topic name. Versions: 0-1
	Partitions []DescribeLogDirsPartition35 // Versions: 0-1
}

// size of DescribeLogDirsTopic35; Versions: 0-1
func (t DescribeLogDirsTopic35) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode DescribeLogDirsTopic35; Versions: 0-1
func (t DescribeLogDirsTopic35) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode DescribeLogDirsTopic35; Versions: 0-1
func (t *DescribeLogDirsTopic35) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]DescribeLogDirsPartition35, n)
		for i := 0; i < n; i++ {
			var item DescribeLogDirsPartition35
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type DescribeLogDirsPartition35 struct {
	PartitionIndex int32 // The partition index. Versions: 0-1
	PartitionSize  int64 // The size of the log segments in this partition in bytes. Versions: 0-1
	OffsetLag      int64 // The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition) Versions: 0-1
	IsFutureKey    bool  // True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future. Versions: 0-1
}

// size of DescribeLogDirsPartition35; Versions: 0-1
func (t DescribeLogDirsPartition35) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int64 // PartitionSize
	sz += sizeof.Int64 // OffsetLag
	sz += sizeof.Bool  // IsFutureKey
	return sz
}

// encode DescribeLogDirsPartition35; Versions: 0-1
func (t DescribeLogDirsPartition35) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt64(t.PartitionSize)  // PartitionSize
	e.PutInt64(t.OffsetLag)      // OffsetLag
	e.PutBool(t.IsFutureKey)     // IsFutureKey
}

// decode DescribeLogDirsPartition35; Versions: 0-1
func (t *DescribeLogDirsPartition35) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.PartitionSize, err = d.Int64()
	if err != nil {
		return err
	}
	t.OffsetLag, err = d.Int64()
	if err != nil {
		return err
	}
	t.IsFutureKey, err = d.Bool()
	if err != nil {
		return err
	}
	return err
}

// SaslAuthenticateRequest; ApiKey: 36, Versions: 0-1
type SaslAuthenticateRequest struct {
	AuthBytes []byte // The SASL authentication bytes from the client, as defined by the SASL mechanism. Versions: 0-1
}

// size of SaslAuthenticateRequest; Versions: 0-1
func (t SaslAuthenticateRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Bytes(t.AuthBytes) // AuthBytes
	return sz
}

// encode SaslAuthenticateRequest; Versions: 0-1
func (t SaslAuthenticateRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutBytes(t.AuthBytes) // AuthBytes
}

// decode SaslAuthenticateRequest; Versions: 0-1
func (t *SaslAuthenticateRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.AuthBytes, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

// SaslAuthenticateResponse; ApiKey: 36, Versions: 0-1
type SaslAuthenticateResponse struct {
	ErrorCode         int16  // The error code, or 0 if there was no error. Versions: 0-1
	ErrorMessage      string // The error message, or null if there was no error. Versions: 0-1
	AuthBytes         []byte // The SASL authentication bytes from the server, as defined by the SASL mechanism. Versions: 0-1
	SessionLifetimeMs int64  // The SASL authentication bytes from the server, as defined by the SASL mechanism. Versions: 0-1
}

// size of SaslAuthenticateResponse; Versions: 0-1
func (t SaslAuthenticateResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.Bytes(t.AuthBytes)     // AuthBytes
	if version >= 1 {
		sz += sizeof.Int64 // SessionLifetimeMs
	}
	return sz
}

// encode SaslAuthenticateResponse; Versions: 0-1
func (t SaslAuthenticateResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
	e.PutBytes(t.AuthBytes)     // AuthBytes
	if version >= 1 {
		e.PutInt64(t.SessionLifetimeMs) // SessionLifetimeMs
	}
}

// decode SaslAuthenticateResponse; Versions: 0-1
func (t *SaslAuthenticateResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	t.AuthBytes, err = d.Bytes()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.SessionLifetimeMs, err = d.Int64()
		if err != nil {
			return err
		}
	}
	return err
}

// CreatePartitionsRequest; ApiKey: 37, Versions: 0-1
type CreatePartitionsRequest struct {
	Topics       []CreatePartitionsTopic37 // Each topic that we want to create new partitions inside. Versions: 0-1
	TimeoutMs    int32                     // The time in ms to wait for the partitions to be created. Versions: 0-1
	ValidateOnly bool                      // If true, then validate the request, but don't actually increase the number of partitions. Versions: 0-1
}

// size of CreatePartitionsRequest; Versions: 0-1
func (t CreatePartitionsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	sz += sizeof.Int32 // TimeoutMs
	sz += sizeof.Bool  // ValidateOnly
	return sz
}

// encode CreatePartitionsRequest; Versions: 0-1
func (t CreatePartitionsRequest) Encode(e *protocol.Encoder, version int16) {
	// Topics
	len0 := len(t.Topics)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Topics[i].Encode(e, version)
	}
	e.PutInt32(t.TimeoutMs)   // TimeoutMs
	e.PutBool(t.ValidateOnly) // ValidateOnly
}

// decode CreatePartitionsRequest; Versions: 0-1
func (t *CreatePartitionsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]CreatePartitionsTopic37, n)
		for i := 0; i < n; i++ {
			var item CreatePartitionsTopic37
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	t.TimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	t.ValidateOnly, err = d.Bool()
	if err != nil {
		return err
	}
	return err
}

type CreatePartitionsTopic37 struct {
	Name        string                         // The topic name. Versions: 0-1
	Count       int32                          // The new partition count. Versions: 0-1
	Assignments []CreatePartitionsAssignment37 // The new partition assignments. Versions: 0-1
}

// size of CreatePartitionsTopic37; Versions: 0-1
func (t CreatePartitionsTopic37) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.Int32          // Count
	sz += sizeof.ArrayLength    // Assignments
	for i := len(t.Assignments) - 1; i >= 0; i-- {
		sz += t.Assignments[i].Size(version)
	}
	return sz
}

// encode CreatePartitionsTopic37; Versions: 0-1
func (t CreatePartitionsTopic37) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	e.PutInt32(t.Count) // Count
	// Assignments
	len2 := len(t.Assignments)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Assignments[i].Encode(e, version)
	}
}

// decode CreatePartitionsTopic37; Versions: 0-1
func (t *CreatePartitionsTopic37) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.Count, err = d.Int32()
	if err != nil {
		return err
	}
	// Assignments
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Assignments = make([]CreatePartitionsAssignment37, n)
		for i := 0; i < n; i++ {
			var item CreatePartitionsAssignment37
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Assignments[i] = item
		}
	}
	return err
}

type CreatePartitionsAssignment37 struct {
	BrokerIds []int32 // The assigned broker IDs. Versions: 0-1
}

// size of CreatePartitionsAssignment37; Versions: 0-1
func (t CreatePartitionsAssignment37) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32Array(t.BrokerIds) // BrokerIds
	return sz
}

// encode CreatePartitionsAssignment37; Versions: 0-1
func (t CreatePartitionsAssignment37) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32Array(t.BrokerIds) // BrokerIds
}

// decode CreatePartitionsAssignment37; Versions: 0-1
func (t *CreatePartitionsAssignment37) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.BrokerIds, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// CreatePartitionsResponse; ApiKey: 37, Versions: 0-1
type CreatePartitionsResponse struct {
	ThrottleTimeMs int32                           // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	Results        []CreatePartitionsTopicResult37 // The partition creation results for each topic. Versions: 0-1
}

// size of CreatePartitionsResponse; Versions: 0-1
func (t CreatePartitionsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].Size(version)
	}
	return sz
}

// encode CreatePartitionsResponse; Versions: 0-1
func (t CreatePartitionsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].Encode(e, version)
	}
}

// decode CreatePartitionsResponse; Versions: 0-1
func (t *CreatePartitionsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]CreatePartitionsTopicResult37, n)
		for i := 0; i < n; i++ {
			var item CreatePartitionsTopicResult37
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type CreatePartitionsTopicResult37 struct {
	Name         string // The topic name. Versions: 0-1
	ErrorCode    int16  // The result error, or zero if there was no error. Versions: 0-1
	ErrorMessage string // The result message, or null if there was no error. Versions: 0-1
}

// size of CreatePartitionsTopicResult37; Versions: 0-1
func (t CreatePartitionsTopicResult37) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)         // Name
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	return sz
}

// encode CreatePartitionsTopicResult37; Versions: 0-1
func (t CreatePartitionsTopicResult37) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)         // Name
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
}

// decode CreatePartitionsTopicResult37; Versions: 0-1
func (t *CreatePartitionsTopicResult37) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// CreateDelegationTokenRequest; ApiKey: 38, Versions: 0-2
type CreateDelegationTokenRequest struct {
	Renewers      []CreatableRenewers38 // A list of those who are allowed to renew this token before it expires. Versions: 0-2
	MaxLifetimeMs int64                 // The maximum lifetime of the token in milliseconds, or -1 to use the server side default. Versions: 0-2
}

// size of CreateDelegationTokenRequest; Versions: 0-2
func (t CreateDelegationTokenRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Renewers
	for i := len(t.Renewers) - 1; i >= 0; i-- {
		sz += t.Renewers[i].Size(version)
	}
	sz += sizeof.Int64 // MaxLifetimeMs
	return sz
}

// encode CreateDelegationTokenRequest; Versions: 0-2
func (t CreateDelegationTokenRequest) Encode(e *protocol.Encoder, version int16) {
	// Renewers
	len0 := len(t.Renewers)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Renewers[i].Encode(e, version)
	}
	e.PutInt64(t.MaxLifetimeMs) // MaxLifetimeMs
}

// decode CreateDelegationTokenRequest; Versions: 0-2
func (t *CreateDelegationTokenRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Renewers
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Renewers = make([]CreatableRenewers38, n)
		for i := 0; i < n; i++ {
			var item CreatableRenewers38
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Renewers[i] = item
		}
	}
	t.MaxLifetimeMs, err = d.Int64()
	if err != nil {
		return err
	}
	return err
}

type CreatableRenewers38 struct {
	PrincipalType string // The type of the Kafka principal. Versions: 0-2
	PrincipalName string // The name of the Kafka principal. Versions: 0-2
}

// size of CreatableRenewers38; Versions: 0-2
func (t CreatableRenewers38) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.PrincipalType) // PrincipalType
	sz += sizeof.String(t.PrincipalName) // PrincipalName
	return sz
}

// encode CreatableRenewers38; Versions: 0-2
func (t CreatableRenewers38) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.PrincipalType) // PrincipalType
	e.PutString(t.PrincipalName) // PrincipalName
}

// decode CreatableRenewers38; Versions: 0-2
func (t *CreatableRenewers38) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PrincipalType, err = d.String()
	if err != nil {
		return err
	}
	t.PrincipalName, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// CreateDelegationTokenResponse; ApiKey: 38, Versions: 0-2
type CreateDelegationTokenResponse struct {
	ErrorCode         int16  // The top-level error, or zero if there was no error. Versions: 0-2
	PrincipalType     string // The principal type of the token owner. Versions: 0-2
	PrincipalName     string // The name of the token owner. Versions: 0-2
	IssueTimestampMs  int64  // When this token was generated. Versions: 0-2
	ExpiryTimestampMs int64  // When this token expires. Versions: 0-2
	MaxTimestampMs    int64  // The maximum lifetime of this token. Versions: 0-2
	TokenId           string // The token UUID. Versions: 0-2
	Hmac              []byte // HMAC of the delegation token. Versions: 0-2
	ThrottleTimeMs    int32  // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-2
}

// size of CreateDelegationTokenResponse; Versions: 0-2
func (t CreateDelegationTokenResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                   // ErrorCode
	sz += sizeof.String(t.PrincipalType) // PrincipalType
	sz += sizeof.String(t.PrincipalName) // PrincipalName
	sz += sizeof.Int64                   // IssueTimestampMs
	sz += sizeof.Int64                   // ExpiryTimestampMs
	sz += sizeof.Int64                   // MaxTimestampMs
	sz += sizeof.String(t.TokenId)       // TokenId
	sz += sizeof.Bytes(t.Hmac)           // Hmac
	sz += sizeof.Int32                   // ThrottleTimeMs
	return sz
}

// encode CreateDelegationTokenResponse; Versions: 0-2
func (t CreateDelegationTokenResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)         // ErrorCode
	e.PutString(t.PrincipalType)    // PrincipalType
	e.PutString(t.PrincipalName)    // PrincipalName
	e.PutInt64(t.IssueTimestampMs)  // IssueTimestampMs
	e.PutInt64(t.ExpiryTimestampMs) // ExpiryTimestampMs
	e.PutInt64(t.MaxTimestampMs)    // MaxTimestampMs
	e.PutString(t.TokenId)          // TokenId
	e.PutBytes(t.Hmac)              // Hmac
	e.PutInt32(t.ThrottleTimeMs)    // ThrottleTimeMs
}

// decode CreateDelegationTokenResponse; Versions: 0-2
func (t *CreateDelegationTokenResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.PrincipalType, err = d.String()
	if err != nil {
		return err
	}
	t.PrincipalName, err = d.String()
	if err != nil {
		return err
	}
	t.IssueTimestampMs, err = d.Int64()
	if err != nil {
		return err
	}
	t.ExpiryTimestampMs, err = d.Int64()
	if err != nil {
		return err
	}
	t.MaxTimestampMs, err = d.Int64()
	if err != nil {
		return err
	}
	t.TokenId, err = d.String()
	if err != nil {
		return err
	}
	t.Hmac, err = d.Bytes()
	if err != nil {
		return err
	}
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// RenewDelegationTokenRequest; ApiKey: 39, Versions: 0-1
type RenewDelegationTokenRequest struct {
	Hmac          []byte // The HMAC of the delegation token to be renewed. Versions: 0-1
	RenewPeriodMs int64  // The renewal time period in milliseconds. Versions: 0-1
}

// size of RenewDelegationTokenRequest; Versions: 0-1
func (t RenewDelegationTokenRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Bytes(t.Hmac) // Hmac
	sz += sizeof.Int64         // RenewPeriodMs
	return sz
}

// encode RenewDelegationTokenRequest; Versions: 0-1
func (t RenewDelegationTokenRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutBytes(t.Hmac)          // Hmac
	e.PutInt64(t.RenewPeriodMs) // RenewPeriodMs
}

// decode RenewDelegationTokenRequest; Versions: 0-1
func (t *RenewDelegationTokenRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Hmac, err = d.Bytes()
	if err != nil {
		return err
	}
	t.RenewPeriodMs, err = d.Int64()
	if err != nil {
		return err
	}
	return err
}

// RenewDelegationTokenResponse; ApiKey: 39, Versions: 0-1
type RenewDelegationTokenResponse struct {
	ErrorCode         int16 // The error code, or 0 if there was no error. Versions: 0-1
	ExpiryTimestampMs int64 // The timestamp in milliseconds at which this token expires. Versions: 0-1
	ThrottleTimeMs    int32 // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
}

// size of RenewDelegationTokenResponse; Versions: 0-1
func (t RenewDelegationTokenResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16 // ErrorCode
	sz += sizeof.Int64 // ExpiryTimestampMs
	sz += sizeof.Int32 // ThrottleTimeMs
	return sz
}

// encode RenewDelegationTokenResponse; Versions: 0-1
func (t RenewDelegationTokenResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)         // ErrorCode
	e.PutInt64(t.ExpiryTimestampMs) // ExpiryTimestampMs
	e.PutInt32(t.ThrottleTimeMs)    // ThrottleTimeMs
}

// decode RenewDelegationTokenResponse; Versions: 0-1
func (t *RenewDelegationTokenResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ExpiryTimestampMs, err = d.Int64()
	if err != nil {
		return err
	}
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// ExpireDelegationTokenRequest; ApiKey: 40, Versions: 0-1
type ExpireDelegationTokenRequest struct {
	Hmac               []byte // The HMAC of the delegation token to be expired. Versions: 0-1
	ExpiryTimePeriodMs int64  // The expiry time period in milliseconds. Versions: 0-1
}

// size of ExpireDelegationTokenRequest; Versions: 0-1
func (t ExpireDelegationTokenRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Bytes(t.Hmac) // Hmac
	sz += sizeof.Int64         // ExpiryTimePeriodMs
	return sz
}

// encode ExpireDelegationTokenRequest; Versions: 0-1
func (t ExpireDelegationTokenRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutBytes(t.Hmac)               // Hmac
	e.PutInt64(t.ExpiryTimePeriodMs) // ExpiryTimePeriodMs
}

// decode ExpireDelegationTokenRequest; Versions: 0-1
func (t *ExpireDelegationTokenRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Hmac, err = d.Bytes()
	if err != nil {
		return err
	}
	t.ExpiryTimePeriodMs, err = d.Int64()
	if err != nil {
		return err
	}
	return err
}

// ExpireDelegationTokenResponse; ApiKey: 40, Versions: 0-1
type ExpireDelegationTokenResponse struct {
	ErrorCode         int16 // The error code, or 0 if there was no error. Versions: 0-1
	ExpiryTimestampMs int64 // The timestamp in milliseconds at which this token expires. Versions: 0-1
	ThrottleTimeMs    int32 // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
}

// size of ExpireDelegationTokenResponse; Versions: 0-1
func (t ExpireDelegationTokenResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16 // ErrorCode
	sz += sizeof.Int64 // ExpiryTimestampMs
	sz += sizeof.Int32 // ThrottleTimeMs
	return sz
}

// encode ExpireDelegationTokenResponse; Versions: 0-1
func (t ExpireDelegationTokenResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)         // ErrorCode
	e.PutInt64(t.ExpiryTimestampMs) // ExpiryTimestampMs
	e.PutInt32(t.ThrottleTimeMs)    // ThrottleTimeMs
}

// decode ExpireDelegationTokenResponse; Versions: 0-1
func (t *ExpireDelegationTokenResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ExpiryTimestampMs, err = d.Int64()
	if err != nil {
		return err
	}
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// DescribeDelegationTokenRequest; ApiKey: 41, Versions: 0-1
type DescribeDelegationTokenRequest struct {
	Owners []DescribeDelegationTokenOwner41 // Each owner that we want to describe delegation tokens for, or null to describe all tokens. Versions: 0-1
}

// size of DescribeDelegationTokenRequest; Versions: 0-1
func (t DescribeDelegationTokenRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Owners
	for i := len(t.Owners) - 1; i >= 0; i-- {
		sz += t.Owners[i].Size(version)
	}
	return sz
}

// encode DescribeDelegationTokenRequest; Versions: 0-1
func (t DescribeDelegationTokenRequest) Encode(e *protocol.Encoder, version int16) {
	// Owners
	len0 := len(t.Owners)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Owners[i].Encode(e, version)
	}
}

// decode DescribeDelegationTokenRequest; Versions: 0-1
func (t *DescribeDelegationTokenRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Owners
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Owners = make([]DescribeDelegationTokenOwner41, n)
		for i := 0; i < n; i++ {
			var item DescribeDelegationTokenOwner41
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Owners[i] = item
		}
	}
	return err
}

type DescribeDelegationTokenOwner41 struct {
	PrincipalType string // The owner principal type. Versions: 0-1
	PrincipalName string // The owner principal name. Versions: 0-1
}

// size of DescribeDelegationTokenOwner41; Versions: 0-1
func (t DescribeDelegationTokenOwner41) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.PrincipalType) // PrincipalType
	sz += sizeof.String(t.PrincipalName) // PrincipalName
	return sz
}

// encode DescribeDelegationTokenOwner41; Versions: 0-1
func (t DescribeDelegationTokenOwner41) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.PrincipalType) // PrincipalType
	e.PutString(t.PrincipalName) // PrincipalName
}

// decode DescribeDelegationTokenOwner41; Versions: 0-1
func (t *DescribeDelegationTokenOwner41) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PrincipalType, err = d.String()
	if err != nil {
		return err
	}
	t.PrincipalName, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// DescribeDelegationTokenResponse; ApiKey: 41, Versions: 0-1
type DescribeDelegationTokenResponse struct {
	ErrorCode      int16                        // The error code, or 0 if there was no error. Versions: 0-1
	Tokens         []DescribedDelegationToken41 // The tokens. Versions: 0-1
	ThrottleTimeMs int32                        // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
}

// size of DescribeDelegationTokenResponse; Versions: 0-1
func (t DescribeDelegationTokenResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16       // ErrorCode
	sz += sizeof.ArrayLength // Tokens
	for i := len(t.Tokens) - 1; i >= 0; i-- {
		sz += t.Tokens[i].Size(version)
	}
	sz += sizeof.Int32 // ThrottleTimeMs
	return sz
}

// encode DescribeDelegationTokenResponse; Versions: 0-1
func (t DescribeDelegationTokenResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
	// Tokens
	len1 := len(t.Tokens)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Tokens[i].Encode(e, version)
	}
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
}

// decode DescribeDelegationTokenResponse; Versions: 0-1
func (t *DescribeDelegationTokenResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	// Tokens
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Tokens = make([]DescribedDelegationToken41, n)
		for i := 0; i < n; i++ {
			var item DescribedDelegationToken41
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Tokens[i] = item
		}
	}
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

type DescribedDelegationToken41 struct {
	PrincipalType   string                              // The token principal type. Versions: 0-1
	PrincipalName   string                              // The token principal name. Versions: 0-1
	IssueTimestamp  int64                               // The token issue timestamp in milliseconds. Versions: 0-1
	ExpiryTimestamp int64                               // The token expiry timestamp in milliseconds. Versions: 0-1
	MaxTimestamp    int64                               // The token maximum timestamp length in milliseconds. Versions: 0-1
	TokenId         string                              // The token ID. Versions: 0-1
	Hmac            []byte                              // The token HMAC. Versions: 0-1
	Renewers        []DescribedDelegationTokenRenewer41 // Those who are able to renew this token before it expires. Versions: 0-1
}

// size of DescribedDelegationToken41; Versions: 0-1
func (t DescribedDelegationToken41) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.PrincipalType) // PrincipalType
	sz += sizeof.String(t.PrincipalName) // PrincipalName
	sz += sizeof.Int64                   // IssueTimestamp
	sz += sizeof.Int64                   // ExpiryTimestamp
	sz += sizeof.Int64                   // MaxTimestamp
	sz += sizeof.String(t.TokenId)       // TokenId
	sz += sizeof.Bytes(t.Hmac)           // Hmac
	sz += sizeof.ArrayLength             // Renewers
	for i := len(t.Renewers) - 1; i >= 0; i-- {
		sz += t.Renewers[i].Size(version)
	}
	return sz
}

// encode DescribedDelegationToken41; Versions: 0-1
func (t DescribedDelegationToken41) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.PrincipalType)  // PrincipalType
	e.PutString(t.PrincipalName)  // PrincipalName
	e.PutInt64(t.IssueTimestamp)  // IssueTimestamp
	e.PutInt64(t.ExpiryTimestamp) // ExpiryTimestamp
	e.PutInt64(t.MaxTimestamp)    // MaxTimestamp
	e.PutString(t.TokenId)        // TokenId
	e.PutBytes(t.Hmac)            // Hmac
	// Renewers
	len7 := len(t.Renewers)
	e.PutArrayLength(len7)
	for i := 0; i < len7; i++ {
		t.Renewers[i].Encode(e, version)
	}
}

// decode DescribedDelegationToken41; Versions: 0-1
func (t *DescribedDelegationToken41) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PrincipalType, err = d.String()
	if err != nil {
		return err
	}
	t.PrincipalName, err = d.String()
	if err != nil {
		return err
	}
	t.IssueTimestamp, err = d.Int64()
	if err != nil {
		return err
	}
	t.ExpiryTimestamp, err = d.Int64()
	if err != nil {
		return err
	}
	t.MaxTimestamp, err = d.Int64()
	if err != nil {
		return err
	}
	t.TokenId, err = d.String()
	if err != nil {
		return err
	}
	t.Hmac, err = d.Bytes()
	if err != nil {
		return err
	}
	// Renewers
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Renewers = make([]DescribedDelegationTokenRenewer41, n)
		for i := 0; i < n; i++ {
			var item DescribedDelegationTokenRenewer41
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Renewers[i] = item
		}
	}
	return err
}

type DescribedDelegationTokenRenewer41 struct {
	PrincipalType string // The renewer principal type Versions: 0-1
	PrincipalName string // The renewer principal name Versions: 0-1
}

// size of DescribedDelegationTokenRenewer41; Versions: 0-1
func (t DescribedDelegationTokenRenewer41) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.PrincipalType) // PrincipalType
	sz += sizeof.String(t.PrincipalName) // PrincipalName
	return sz
}

// encode DescribedDelegationTokenRenewer41; Versions: 0-1
func (t DescribedDelegationTokenRenewer41) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.PrincipalType) // PrincipalType
	e.PutString(t.PrincipalName) // PrincipalName
}

// decode DescribedDelegationTokenRenewer41; Versions: 0-1
func (t *DescribedDelegationTokenRenewer41) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PrincipalType, err = d.String()
	if err != nil {
		return err
	}
	t.PrincipalName, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// DeleteGroupsRequest; ApiKey: 42, Versions: 0-2
type DeleteGroupsRequest struct {
	GroupsNames []string // The group names to delete. Versions: 0-2
}

// size of DeleteGroupsRequest; Versions: 0-2
func (t DeleteGroupsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.StringArray(t.GroupsNames) // GroupsNames
	return sz
}

// encode DeleteGroupsRequest; Versions: 0-2
func (t DeleteGroupsRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutStringArray(t.GroupsNames) // GroupsNames
}

// decode DeleteGroupsRequest; Versions: 0-2
func (t *DeleteGroupsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupsNames, err = d.StringArray()
	if err != nil {
		return err
	}
	return err
}

// DeleteGroupsResponse; ApiKey: 42, Versions: 0-2
type DeleteGroupsResponse struct {
	ThrottleTimeMs int32                    // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-2
	Results        []DeletableGroupResult42 // The deletion results Versions: 0-2
}

// size of DeleteGroupsResponse; Versions: 0-2
func (t DeleteGroupsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].Size(version)
	}
	return sz
}

// encode DeleteGroupsResponse; Versions: 0-2
func (t DeleteGroupsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].Encode(e, version)
	}
}

// decode DeleteGroupsResponse; Versions: 0-2
func (t *DeleteGroupsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]DeletableGroupResult42, n)
		for i := 0; i < n; i++ {
			var item DeletableGroupResult42
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type DeletableGroupResult42 struct {
	GroupId   string // The group id Versions: 0-2
	ErrorCode int16  // The deletion error, or 0 if the deletion succeeded. Versions: 0-2
}

// size of DeletableGroupResult42; Versions: 0-2
func (t DeletableGroupResult42) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId) // GroupId
	sz += sizeof.Int16             // ErrorCode
	return sz
}

// encode DeletableGroupResult42; Versions: 0-2
func (t DeletableGroupResult42) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId)  // GroupId
	e.PutInt16(t.ErrorCode) // ErrorCode
}

// decode DeletableGroupResult42; Versions: 0-2
func (t *DeletableGroupResult42) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// ElectLeadersRequest; ApiKey: 43, Versions: 0-2
type ElectLeadersRequest struct {
	ElectionType    int8                // Type of elections to conduct for the partition. A value of '0' elects the preferred replica. A value of '1' elects the first live replica if there are no in-sync replica. Versions: 0-2
	TopicPartitions []TopicPartitions43 // The topic partitions to elect leaders. Versions: 0-2
	TimeoutMs       int32               // The time in ms to wait for the election to complete. Versions: 0-2
}

// size of ElectLeadersRequest; Versions: 0-2
func (t ElectLeadersRequest) Size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int8 // ElectionType
	}
	sz += sizeof.ArrayLength // TopicPartitions
	for i := len(t.TopicPartitions) - 1; i >= 0; i-- {
		sz += t.TopicPartitions[i].Size(version)
	}
	sz += sizeof.Int32 // TimeoutMs
	return sz
}

// encode ElectLeadersRequest; Versions: 0-2
func (t ElectLeadersRequest) Encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt8(t.ElectionType) // ElectionType
	}
	// TopicPartitions
	len1 := len(t.TopicPartitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.TopicPartitions[i].Encode(e, version)
	}
	e.PutInt32(t.TimeoutMs) // TimeoutMs
}

// decode ElectLeadersRequest; Versions: 0-2
func (t *ElectLeadersRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ElectionType, err = d.Int8()
		if err != nil {
			return err
		}
	}
	// TopicPartitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.TopicPartitions = make([]TopicPartitions43, n)
		for i := 0; i < n; i++ {
			var item TopicPartitions43
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.TopicPartitions[i] = item
		}
	}
	t.TimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

type TopicPartitions43 struct {
	Topic       string  // The name of a topic. Versions: 0-2
	PartitionId []int32 // The partitions of this topic whose leader should be elected. Versions: 0-2
}

// size of TopicPartitions43; Versions: 0-2
func (t TopicPartitions43) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Topic)           // Topic
	sz += sizeof.Int32Array(t.PartitionId) // PartitionId
	return sz
}

// encode TopicPartitions43; Versions: 0-2
func (t TopicPartitions43) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Topic)           // Topic
	e.PutInt32Array(t.PartitionId) // PartitionId
}

// decode TopicPartitions43; Versions: 0-2
func (t *TopicPartitions43) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Topic, err = d.String()
	if err != nil {
		return err
	}
	t.PartitionId, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// ElectLeadersResponse; ApiKey: 43, Versions: 0-2
type ElectLeadersResponse struct {
	ThrottleTimeMs         int32                     // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-2
	ErrorCode              int16                     // The top level response error code. Versions: 0-2
	ReplicaElectionResults []ReplicaElectionResult43 // The election results, or an empty array if the requester did not have permission and the request asks for all partitions. Versions: 0-2
}

// size of ElectLeadersResponse; Versions: 0-2
func (t ElectLeadersResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ThrottleTimeMs
	if version >= 1 {
		sz += sizeof.Int16 // ErrorCode
	}
	sz += sizeof.ArrayLength // ReplicaElectionResults
	for i := len(t.ReplicaElectionResults) - 1; i >= 0; i-- {
		sz += t.ReplicaElectionResults[i].Size(version)
	}
	return sz
}

// encode ElectLeadersResponse; Versions: 0-2
func (t ElectLeadersResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	if version >= 1 {
		e.PutInt16(t.ErrorCode) // ErrorCode
	}
	// ReplicaElectionResults
	len2 := len(t.ReplicaElectionResults)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.ReplicaElectionResults[i].Encode(e, version)
	}
}

// decode ElectLeadersResponse; Versions: 0-2
func (t *ElectLeadersResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 1 {
		t.ErrorCode, err = d.Int16()
		if err != nil {
			return err
		}
	}
	// ReplicaElectionResults
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.ReplicaElectionResults = make([]ReplicaElectionResult43, n)
		for i := 0; i < n; i++ {
			var item ReplicaElectionResult43
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.ReplicaElectionResults[i] = item
		}
	}
	return err
}

type ReplicaElectionResult43 struct {
	Topic           string              // The topic name Versions: 0-2
	PartitionResult []PartitionResult43 // The results for each partition Versions: 0-2
}

// size of ReplicaElectionResult43; Versions: 0-2
func (t ReplicaElectionResult43) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Topic) // Topic
	sz += sizeof.ArrayLength     // PartitionResult
	for i := len(t.PartitionResult) - 1; i >= 0; i-- {
		sz += t.PartitionResult[i].Size(version)
	}
	return sz
}

// encode ReplicaElectionResult43; Versions: 0-2
func (t ReplicaElectionResult43) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Topic) // Topic
	// PartitionResult
	len1 := len(t.PartitionResult)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.PartitionResult[i].Encode(e, version)
	}
}

// decode ReplicaElectionResult43; Versions: 0-2
func (t *ReplicaElectionResult43) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Topic, err = d.String()
	if err != nil {
		return err
	}
	// PartitionResult
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.PartitionResult = make([]PartitionResult43, n)
		for i := 0; i < n; i++ {
			var item PartitionResult43
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.PartitionResult[i] = item
		}
	}
	return err
}

type PartitionResult43 struct {
	PartitionId  int32  // The partition id Versions: 0-2
	ErrorCode    int16  // The result error, or zero if there was no error. Versions: 0-2
	ErrorMessage string // The result message, or null if there was no error. Versions: 0-2
}

// size of PartitionResult43; Versions: 0-2
func (t PartitionResult43) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32                  // PartitionId
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	return sz
}

// encode PartitionResult43; Versions: 0-2
func (t PartitionResult43) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionId)   // PartitionId
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
}

// decode PartitionResult43; Versions: 0-2
func (t *PartitionResult43) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionId, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// IncrementalAlterConfigsRequest; ApiKey: 44, Versions: 0-1
type IncrementalAlterConfigsRequest struct {
	Resources    []AlterConfigsResource44 // The incremental updates for each resource. Versions: 0-1
	ValidateOnly bool                     // True if we should validate the request, but not change the configurations. Versions: 0-1
}

// size of IncrementalAlterConfigsRequest; Versions: 0-1
func (t IncrementalAlterConfigsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.ArrayLength // Resources
	for i := len(t.Resources) - 1; i >= 0; i-- {
		sz += t.Resources[i].Size(version)
	}
	sz += sizeof.Bool // ValidateOnly
	return sz
}

// encode IncrementalAlterConfigsRequest; Versions: 0-1
func (t IncrementalAlterConfigsRequest) Encode(e *protocol.Encoder, version int16) {
	// Resources
	len0 := len(t.Resources)
	e.PutArrayLength(len0)
	for i := 0; i < len0; i++ {
		t.Resources[i].Encode(e, version)
	}
	e.PutBool(t.ValidateOnly) // ValidateOnly
}

// decode IncrementalAlterConfigsRequest; Versions: 0-1
func (t *IncrementalAlterConfigsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	// Resources
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Resources = make([]AlterConfigsResource44, n)
		for i := 0; i < n; i++ {
			var item AlterConfigsResource44
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Resources[i] = item
		}
	}
	t.ValidateOnly, err = d.Bool()
	if err != nil {
		return err
	}
	return err
}

type AlterConfigsResource44 struct {
	ResourceType int8                // The resource type. Versions: 0-1
	ResourceName string              // The resource name. Versions: 0-1
	Configs      []AlterableConfig44 // The configurations. Versions: 0-1
}

// size of AlterConfigsResource44; Versions: 0-1
func (t AlterConfigsResource44) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int8                   // ResourceType
	sz += sizeof.String(t.ResourceName) // ResourceName
	sz += sizeof.ArrayLength            // Configs
	for i := len(t.Configs) - 1; i >= 0; i-- {
		sz += t.Configs[i].Size(version)
	}
	return sz
}

// encode AlterConfigsResource44; Versions: 0-1
func (t AlterConfigsResource44) Encode(e *protocol.Encoder, version int16) {
	e.PutInt8(t.ResourceType)   // ResourceType
	e.PutString(t.ResourceName) // ResourceName
	// Configs
	len2 := len(t.Configs)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Configs[i].Encode(e, version)
	}
}

// decode AlterConfigsResource44; Versions: 0-1
func (t *AlterConfigsResource44) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceName, err = d.String()
	if err != nil {
		return err
	}
	// Configs
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Configs = make([]AlterableConfig44, n)
		for i := 0; i < n; i++ {
			var item AlterableConfig44
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Configs[i] = item
		}
	}
	return err
}

type AlterableConfig44 struct {
	Name            string // The configuration key name. Versions: 0-1
	ConfigOperation int8   // The type (Set, Delete, Append, Subtract) of operation. Versions: 0-1
	Value           string // The value to set for the configuration key. Versions: 0-1
}

// size of AlterableConfig44; Versions: 0-1
func (t AlterableConfig44) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)  // Name
	sz += sizeof.Int8            // ConfigOperation
	sz += sizeof.String(t.Value) // Value
	return sz
}

// encode AlterableConfig44; Versions: 0-1
func (t AlterableConfig44) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)          // Name
	e.PutInt8(t.ConfigOperation) // ConfigOperation
	e.PutString(t.Value)         // Value
}

// decode AlterableConfig44; Versions: 0-1
func (t *AlterableConfig44) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.ConfigOperation, err = d.Int8()
	if err != nil {
		return err
	}
	t.Value, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// IncrementalAlterConfigsResponse; ApiKey: 44, Versions: 0-1
type IncrementalAlterConfigsResponse struct {
	ThrottleTimeMs int32                            // Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0-1
	Responses      []AlterConfigsResourceResponse44 // The responses for each resource. Versions: 0-1
}

// size of IncrementalAlterConfigsResponse; Versions: 0-1
func (t IncrementalAlterConfigsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Responses
	for i := len(t.Responses) - 1; i >= 0; i-- {
		sz += t.Responses[i].Size(version)
	}
	return sz
}

// encode IncrementalAlterConfigsResponse; Versions: 0-1
func (t IncrementalAlterConfigsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Responses
	len1 := len(t.Responses)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Responses[i].Encode(e, version)
	}
}

// decode IncrementalAlterConfigsResponse; Versions: 0-1
func (t *IncrementalAlterConfigsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Responses
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Responses = make([]AlterConfigsResourceResponse44, n)
		for i := 0; i < n; i++ {
			var item AlterConfigsResourceResponse44
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Responses[i] = item
		}
	}
	return err
}

type AlterConfigsResourceResponse44 struct {
	ErrorCode    int16  // The resource error code. Versions: 0-1
	ErrorMessage string // The resource error message, or null if there was no error. Versions: 0-1
	ResourceType int8   // The resource type. Versions: 0-1
	ResourceName string // The resource name. Versions: 0-1
}

// size of AlterConfigsResourceResponse44; Versions: 0-1
func (t AlterConfigsResourceResponse44) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.Int8                   // ResourceType
	sz += sizeof.String(t.ResourceName) // ResourceName
	return sz
}

// encode AlterConfigsResourceResponse44; Versions: 0-1
func (t AlterConfigsResourceResponse44) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)     // ErrorCode
	e.PutString(t.ErrorMessage) // ErrorMessage
	e.PutInt8(t.ResourceType)   // ResourceType
	e.PutString(t.ResourceName) // ResourceName
}

// decode AlterConfigsResourceResponse44; Versions: 0-1
func (t *AlterConfigsResourceResponse44) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	t.ResourceType, err = d.Int8()
	if err != nil {
		return err
	}
	t.ResourceName, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// AlterPartitionReassignmentsRequest; ApiKey: 45, Versions: 0
type AlterPartitionReassignmentsRequest struct {
	TimeoutMs int32                 // The time in ms to wait for the request to complete. Versions: 0
	Topics    []ReassignableTopic45 // The topics to reassign. Versions: 0
}

// size of AlterPartitionReassignmentsRequest; Versions: 0
func (t AlterPartitionReassignmentsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // TimeoutMs
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode AlterPartitionReassignmentsRequest; Versions: 0
func (t AlterPartitionReassignmentsRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.TimeoutMs) // TimeoutMs
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode AlterPartitionReassignmentsRequest; Versions: 0
func (t *AlterPartitionReassignmentsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]ReassignableTopic45, n)
		for i := 0; i < n; i++ {
			var item ReassignableTopic45
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type ReassignableTopic45 struct {
	Name       string                    // The topic name. Versions: 0
	Partitions []ReassignablePartition45 // The partitions to reassign. Versions: 0
}

// size of ReassignableTopic45; Versions: 0
func (t ReassignableTopic45) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode ReassignableTopic45; Versions: 0
func (t ReassignableTopic45) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode ReassignableTopic45; Versions: 0
func (t *ReassignableTopic45) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]ReassignablePartition45, n)
		for i := 0; i < n; i++ {
			var item ReassignablePartition45
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type ReassignablePartition45 struct {
	PartitionIndex int32   // The partition index. Versions: 0
	Replicas       []int32 // The replicas to place the partitions on, or null to cancel a pending reassignment for this partition. Versions: 0
}

// size of ReassignablePartition45; Versions: 0
func (t ReassignablePartition45) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32                  // PartitionIndex
	sz += sizeof.Int32Array(t.Replicas) // Replicas
	return sz
}

// encode ReassignablePartition45; Versions: 0
func (t ReassignablePartition45) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt32Array(t.Replicas)  // Replicas
}

// decode ReassignablePartition45; Versions: 0
func (t *ReassignablePartition45) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.Replicas, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// AlterPartitionReassignmentsResponse; ApiKey: 45, Versions: 0
type AlterPartitionReassignmentsResponse struct {
	ThrottleTimeMs int32                         // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0
	ErrorCode      int16                         // The top-level error code, or 0 if there was no error. Versions: 0
	ErrorMessage   string                        // The top-level error message, or null if there was no error. Versions: 0
	Responses      []ReassignableTopicResponse45 // The responses to topics to reassign. Versions: 0
}

// size of AlterPartitionReassignmentsResponse; Versions: 0
func (t AlterPartitionReassignmentsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32                  // ThrottleTimeMs
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.ArrayLength            // Responses
	for i := len(t.Responses) - 1; i >= 0; i-- {
		sz += t.Responses[i].Size(version)
	}
	return sz
}

// encode AlterPartitionReassignmentsResponse; Versions: 0
func (t AlterPartitionReassignmentsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutString(t.ErrorMessage)  // ErrorMessage
	// Responses
	len3 := len(t.Responses)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Responses[i].Encode(e, version)
	}
}

// decode AlterPartitionReassignmentsResponse; Versions: 0
func (t *AlterPartitionReassignmentsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	// Responses
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Responses = make([]ReassignableTopicResponse45, n)
		for i := 0; i < n; i++ {
			var item ReassignableTopicResponse45
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Responses[i] = item
		}
	}
	return err
}

type ReassignableTopicResponse45 struct {
	Name       string                            // The topic name Versions: 0
	Partitions []ReassignablePartitionResponse45 // The responses to partitions to reassign Versions: 0
}

// size of ReassignableTopicResponse45; Versions: 0
func (t ReassignableTopicResponse45) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode ReassignableTopicResponse45; Versions: 0
func (t ReassignableTopicResponse45) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode ReassignableTopicResponse45; Versions: 0
func (t *ReassignableTopicResponse45) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]ReassignablePartitionResponse45, n)
		for i := 0; i < n; i++ {
			var item ReassignablePartitionResponse45
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type ReassignablePartitionResponse45 struct {
	PartitionIndex int32  // The partition index. Versions: 0
	ErrorCode      int16  // The error code for this partition, or 0 if there was no error. Versions: 0
	ErrorMessage   string // The error message for this partition, or null if there was no error. Versions: 0
}

// size of ReassignablePartitionResponse45; Versions: 0
func (t ReassignablePartitionResponse45) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32                  // PartitionIndex
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	return sz
}

// encode ReassignablePartitionResponse45; Versions: 0
func (t ReassignablePartitionResponse45) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutString(t.ErrorMessage)  // ErrorMessage
}

// decode ReassignablePartitionResponse45; Versions: 0
func (t *ReassignablePartitionResponse45) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	return err
}

// ListPartitionReassignmentsRequest; ApiKey: 46, Versions: 0
type ListPartitionReassignmentsRequest struct {
	TimeoutMs int32                                // The time in ms to wait for the request to complete. Versions: 0
	Topics    []ListPartitionReassignmentsTopics46 // The topics to list partition reassignments for, or null to list everything. Versions: 0
}

// size of ListPartitionReassignmentsRequest; Versions: 0
func (t ListPartitionReassignmentsRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // TimeoutMs
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode ListPartitionReassignmentsRequest; Versions: 0
func (t ListPartitionReassignmentsRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.TimeoutMs) // TimeoutMs
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode ListPartitionReassignmentsRequest; Versions: 0
func (t *ListPartitionReassignmentsRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.TimeoutMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]ListPartitionReassignmentsTopics46, n)
		for i := 0; i < n; i++ {
			var item ListPartitionReassignmentsTopics46
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type ListPartitionReassignmentsTopics46 struct {
	Name             string  // The topic name Versions: 0
	PartitionIndexes []int32 // The partitions to list partition reassignments for. Versions: 0
}

// size of ListPartitionReassignmentsTopics46; Versions: 0
func (t ListPartitionReassignmentsTopics46) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name)                 // Name
	sz += sizeof.Int32Array(t.PartitionIndexes) // PartitionIndexes
	return sz
}

// encode ListPartitionReassignmentsTopics46; Versions: 0
func (t ListPartitionReassignmentsTopics46) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name)                 // Name
	e.PutInt32Array(t.PartitionIndexes) // PartitionIndexes
}

// decode ListPartitionReassignmentsTopics46; Versions: 0
func (t *ListPartitionReassignmentsTopics46) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	t.PartitionIndexes, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// ListPartitionReassignmentsResponse; ApiKey: 46, Versions: 0
type ListPartitionReassignmentsResponse struct {
	ThrottleTimeMs int32                        // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0
	ErrorCode      int16                        // The top-level error code, or 0 if there was no error Versions: 0
	ErrorMessage   string                       // The top-level error message, or null if there was no error. Versions: 0
	Topics         []OngoingTopicReassignment46 // The ongoing reassignments for each topic. Versions: 0
}

// size of ListPartitionReassignmentsResponse; Versions: 0
func (t ListPartitionReassignmentsResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32                  // ThrottleTimeMs
	sz += sizeof.Int16                  // ErrorCode
	sz += sizeof.String(t.ErrorMessage) // ErrorMessage
	sz += sizeof.ArrayLength            // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode ListPartitionReassignmentsResponse; Versions: 0
func (t ListPartitionReassignmentsResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutString(t.ErrorMessage)  // ErrorMessage
	// Topics
	len3 := len(t.Topics)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode ListPartitionReassignmentsResponse; Versions: 0
func (t *ListPartitionReassignmentsResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ErrorMessage, err = d.String()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OngoingTopicReassignment46, n)
		for i := 0; i < n; i++ {
			var item OngoingTopicReassignment46
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type OngoingTopicReassignment46 struct {
	Name       string                           // The topic name. Versions: 0
	Partitions []OngoingPartitionReassignment46 // The ongoing reassignments for each partition. Versions: 0
}

// size of OngoingTopicReassignment46; Versions: 0
func (t OngoingTopicReassignment46) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode OngoingTopicReassignment46; Versions: 0
func (t OngoingTopicReassignment46) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode OngoingTopicReassignment46; Versions: 0
func (t *OngoingTopicReassignment46) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]OngoingPartitionReassignment46, n)
		for i := 0; i < n; i++ {
			var item OngoingPartitionReassignment46
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type OngoingPartitionReassignment46 struct {
	PartitionIndex   int32   // The index of the partition. Versions: 0
	Replicas         []int32 // The current replica set. Versions: 0
	AddingReplicas   []int32 // The set of replicas we are currently adding. Versions: 0
	RemovingReplicas []int32 // The set of replicas we are currently removing. Versions: 0
}

// size of OngoingPartitionReassignment46; Versions: 0
func (t OngoingPartitionReassignment46) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32                          // PartitionIndex
	sz += sizeof.Int32Array(t.Replicas)         // Replicas
	sz += sizeof.Int32Array(t.AddingReplicas)   // AddingReplicas
	sz += sizeof.Int32Array(t.RemovingReplicas) // RemovingReplicas
	return sz
}

// encode OngoingPartitionReassignment46; Versions: 0
func (t OngoingPartitionReassignment46) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex)        // PartitionIndex
	e.PutInt32Array(t.Replicas)         // Replicas
	e.PutInt32Array(t.AddingReplicas)   // AddingReplicas
	e.PutInt32Array(t.RemovingReplicas) // RemovingReplicas
}

// decode OngoingPartitionReassignment46; Versions: 0
func (t *OngoingPartitionReassignment46) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.Replicas, err = d.Int32Array()
	if err != nil {
		return err
	}
	t.AddingReplicas, err = d.Int32Array()
	if err != nil {
		return err
	}
	t.RemovingReplicas, err = d.Int32Array()
	if err != nil {
		return err
	}
	return err
}

// OffsetDeleteRequest; ApiKey: 47, Versions: 0
type OffsetDeleteRequest struct {
	GroupId string                       // The unique group identifier. Versions: 0
	Topics  []OffsetDeleteRequestTopic47 // The topics to delete offsets for Versions: 0
}

// size of OffsetDeleteRequest; Versions: 0
func (t OffsetDeleteRequest) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.GroupId) // GroupId
	sz += sizeof.ArrayLength       // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode OffsetDeleteRequest; Versions: 0
func (t OffsetDeleteRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.GroupId) // GroupId
	// Topics
	len1 := len(t.Topics)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode OffsetDeleteRequest; Versions: 0
func (t *OffsetDeleteRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.GroupId, err = d.String()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OffsetDeleteRequestTopic47, n)
		for i := 0; i < n; i++ {
			var item OffsetDeleteRequestTopic47
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type OffsetDeleteRequestTopic47 struct {
	Name       string                           // The topic name. Versions: 0
	Partitions []OffsetDeleteRequestPartition47 // Each partition to delete offsets for. Versions: 0
}

// size of OffsetDeleteRequestTopic47; Versions: 0
func (t OffsetDeleteRequestTopic47) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode OffsetDeleteRequestTopic47; Versions: 0
func (t OffsetDeleteRequestTopic47) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode OffsetDeleteRequestTopic47; Versions: 0
func (t *OffsetDeleteRequestTopic47) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]OffsetDeleteRequestPartition47, n)
		for i := 0; i < n; i++ {
			var item OffsetDeleteRequestPartition47
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type OffsetDeleteRequestPartition47 struct {
	PartitionIndex int32 // The partition index. Versions: 0
}

// size of OffsetDeleteRequestPartition47; Versions: 0
func (t OffsetDeleteRequestPartition47) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	return sz
}

// encode OffsetDeleteRequestPartition47; Versions: 0
func (t OffsetDeleteRequestPartition47) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
}

// decode OffsetDeleteRequestPartition47; Versions: 0
func (t *OffsetDeleteRequestPartition47) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	return err
}

// OffsetDeleteResponse; ApiKey: 47, Versions: 0
type OffsetDeleteResponse struct {
	ErrorCode      int16                         // The top-level error code, or 0 if there was no error. Versions: 0
	ThrottleTimeMs int32                         // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0
	Topics         []OffsetDeleteResponseTopic47 // The responses for each topic. Versions: 0
}

// size of OffsetDeleteResponse; Versions: 0
func (t OffsetDeleteResponse) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16       // ErrorCode
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].Size(version)
	}
	return sz
}

// encode OffsetDeleteResponse; Versions: 0
func (t OffsetDeleteResponse) Encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Topics
	len2 := len(t.Topics)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode OffsetDeleteResponse; Versions: 0
func (t *OffsetDeleteResponse) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]OffsetDeleteResponseTopic47, n)
		for i := 0; i < n; i++ {
			var item OffsetDeleteResponseTopic47
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type OffsetDeleteResponseTopic47 struct {
	Name       string                            // The topic name. Versions: 0
	Partitions []OffsetDeleteResponsePartition47 // The responses for each partition in the topic. Versions: 0
}

// size of OffsetDeleteResponseTopic47; Versions: 0
func (t OffsetDeleteResponseTopic47) Size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].Size(version)
	}
	return sz
}

// encode OffsetDeleteResponseTopic47; Versions: 0
func (t OffsetDeleteResponseTopic47) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode OffsetDeleteResponseTopic47; Versions: 0
func (t *OffsetDeleteResponseTopic47) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]OffsetDeleteResponsePartition47, n)
		for i := 0; i < n; i++ {
			var item OffsetDeleteResponsePartition47
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type OffsetDeleteResponsePartition47 struct {
	PartitionIndex int32 // The partition index. Versions: 0
	ErrorCode      int16 // The error code, or 0 if there was no error. Versions: 0
}

// size of OffsetDeleteResponsePartition47; Versions: 0
func (t OffsetDeleteResponsePartition47) Size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	return sz
}

// encode OffsetDeleteResponsePartition47; Versions: 0
func (t OffsetDeleteResponsePartition47) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
}

// decode OffsetDeleteResponsePartition47; Versions: 0
func (t *OffsetDeleteResponsePartition47) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	return err
}

// negotiateApiVersions accepts the apiKeys from the broker and negotiates
// acceptable versions for each api based on the versions supported by
// this library.
func negotiateApiVersions(apiKeys []ApiVersionsResponseKey18) (apiVersion, error) {
	// Since this file is generated, there's no need to externalize the supported
	// versions elsewhere.  We can simply inline the values into the call to matchVersion
	var av apiVersion
	var err error
	for _, apiKey := range apiKeys {
		switch apiKey.ApiKey {
		case apikey.Produce:
			av.Produce, err = matchVersion(apiKey, 0, 8)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.Fetch:
			av.Fetch, err = matchVersion(apiKey, 0, 11)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ListOffset:
			av.ListOffset, err = matchVersion(apiKey, 0, 5)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.Metadata:
			av.Metadata, err = matchVersion(apiKey, 0, 9)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.LeaderAndIsr:
			av.LeaderAndIsr, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.StopReplica:
			av.StopReplica, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.UpdateMetadata:
			av.UpdateMetadata, err = matchVersion(apiKey, 0, 6)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ControlledShutdown:
			av.ControlledShutdown, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.OffsetCommit:
			av.OffsetCommit, err = matchVersion(apiKey, 0, 8)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.OffsetFetch:
			av.OffsetFetch, err = matchVersion(apiKey, 0, 6)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.FindCoordinator:
			av.FindCoordinator, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.JoinGroup:
			av.JoinGroup, err = matchVersion(apiKey, 0, 6)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.Heartbeat:
			av.Heartbeat, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.LeaveGroup:
			av.LeaveGroup, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.SyncGroup:
			av.SyncGroup, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeGroups:
			av.DescribeGroups, err = matchVersion(apiKey, 0, 5)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ListGroups:
			av.ListGroups, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.SaslHandshake:
			av.SaslHandshake, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ApiVersions:
			av.ApiVersions, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.CreateTopics:
			av.CreateTopics, err = matchVersion(apiKey, 0, 5)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DeleteTopics:
			av.DeleteTopics, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DeleteRecords:
			av.DeleteRecords, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.InitProducerId:
			av.InitProducerId, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.OffsetForLeaderEpoch:
			av.OffsetForLeaderEpoch, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AddPartitionsToTxn:
			av.AddPartitionsToTxn, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AddOffsetsToTxn:
			av.AddOffsetsToTxn, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.EndTxn:
			av.EndTxn, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.WriteTxnMarkers:
			av.WriteTxnMarkers, err = matchVersion(apiKey, 0, 0)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.TxnOffsetCommit:
			av.TxnOffsetCommit, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeAcls:
			av.DescribeAcls, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.CreateAcls:
			av.CreateAcls, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DeleteAcls:
			av.DeleteAcls, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeConfigs:
			av.DescribeConfigs, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AlterConfigs:
			av.AlterConfigs, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AlterReplicaLogDirs:
			av.AlterReplicaLogDirs, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeLogDirs:
			av.DescribeLogDirs, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.SaslAuthenticate:
			av.SaslAuthenticate, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.CreatePartitions:
			av.CreatePartitions, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.CreateDelegationToken:
			av.CreateDelegationToken, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.RenewDelegationToken:
			av.RenewDelegationToken, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ExpireDelegationToken:
			av.ExpireDelegationToken, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeDelegationToken:
			av.DescribeDelegationToken, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DeleteGroups:
			av.DeleteGroups, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ElectLeaders:
			av.ElectLeaders, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.IncrementalAlterConfigs:
			av.IncrementalAlterConfigs, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AlterPartitionReassignments:
			av.AlterPartitionReassignments, err = matchVersion(apiKey, 0, 0)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ListPartitionReassignments:
			av.ListPartitionReassignments, err = matchVersion(apiKey, 0, 0)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.OffsetDelete:
			av.OffsetDelete, err = matchVersion(apiKey, 0, 0)
			if err != nil {
				return apiVersion{}, err
			}
		}
	}
	return av, nil
}

// matchVersion determines which version of the api to use
func matchVersion(apiKey ApiVersionsResponseKey18, minVersion, maxVersion int16) (int16, error) {
	for version := apiKey.MaxVersion; version >= apiKey.MinVersion; version-- {
		if version := apiKey.MaxVersion; version >= minVersion && version <= maxVersion {
			return version, nil
		}
	}
	return 0, fmt.Errorf("unable to negotiate version for api key, %v", apiKey.ApiKey)
}
