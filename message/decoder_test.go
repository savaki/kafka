// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package message

import (
	"bytes"
	"io"
	"math"
	"reflect"
	"testing"
)

func makeTestDecoder(data []byte) *Decoder {
	return NewDecoder(data, len(data))
}

func TestDecoder_PutBool(t *testing.T) {
	testCases := map[string]struct {
		want bool
	}{
		"true": {
			want: true,
		},
		"false": {
			want: false,
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got bool
			)

			e := &Encoder{target: buf}
			e.PutBool(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.Bool()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got != tc.want {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutBytes(t *testing.T) {
	testCases := map[string]struct {
		want []byte
	}{
		"nil": {
			want: nil,
		},
		"none": {
			want: []byte{},
		},
		"some": {
			want: []byte("hello"),
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got []byte
			)

			e := &Encoder{target: buf}
			e.PutBytes(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.Bytes()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if !bytes.Equal(got, tc.want) {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutInt8(t *testing.T) {
	testCases := map[string]struct {
		want int8
	}{
		"pos": {
			want: 123,
		},
		"neg": {
			want: -123,
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got int8
			)

			e := &Encoder{target: buf}
			e.PutInt8(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.Int8()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got != tc.want {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutInt16(t *testing.T) {
	testCases := map[string]struct {
		want int16
	}{
		"pos": {
			want: 123,
		},
		"neg": {
			want: -123,
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got int16
			)

			e := &Encoder{target: buf}
			e.PutInt16(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.Int16()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got != tc.want {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutInt32(t *testing.T) {
	testCases := map[string]struct {
		want int32
	}{
		"pos": {
			want: 123,
		},
		"neg": {
			want: -123,
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got int32
			)

			e := &Encoder{target: buf}
			e.PutInt32(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.Int32()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got != tc.want {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutInt32Array(t *testing.T) {
	testCases := map[string]struct {
		want []int32
	}{
		"nil": {
			want: nil,
		},
		"pos": {
			want: []int32{1, 2, 3},
		},
		"neg": {
			want: []int32{-1, -2, -3},
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got []int32
			)

			e := &Encoder{target: buf}
			e.PutInt32Array(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.Int32Array()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if !reflect.DeepEqual(got, tc.want) {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutInt64(t *testing.T) {
	testCases := map[string]struct {
		want int64
	}{
		"pos": {
			want: 123,
		},
		"neg": {
			want: -123,
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got int64
			)

			e := &Encoder{target: buf}
			e.PutInt64(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.Int64()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got != tc.want {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutInt64Array(t *testing.T) {
	testCases := map[string]struct {
		want []int64
	}{
		"nil": {
			want: nil,
		},
		"pos": {
			want: []int64{1, 2, 3},
		},
		"neg": {
			want: []int64{-1, -2, -3},
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got []int64
			)

			e := &Encoder{target: buf}
			e.PutInt64Array(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.Int64Array()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if !reflect.DeepEqual(got, tc.want) {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutString(t *testing.T) {
	testCases := map[string]struct {
		want string
	}{
		"none": {
			want: "",
		},
		"some": {
			want: "abc",
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got string
			)

			e := &Encoder{target: buf}
			e.PutString(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.String()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got != tc.want {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutNullableString(t *testing.T) {
	var (
		blank = ""
		some  = "some"
	)

	testCases := map[string]struct {
		want *string
	}{
		"blank": {
			want: &blank,
		},
		"nil": {
			want: &blank,
		},
		"some": {
			want: &some,
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got *string
			)

			e := &Encoder{target: buf}
			e.PutNullableString(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.NullableString()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got == nil && tc.want != nil {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
			if got != nil && tc.want == nil {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
			if got != nil && tc.want != nil && *got != *tc.want {
				t.Fatalf("got %v; want %v", *got, *tc.want)
			}
		})
	}
}

func TestDecoder_PutStringArray(t *testing.T) {
	testCases := map[string]struct {
		want []string
	}{
		"nil": {
			want: nil,
		},
		"empty": {
			want: []string{},
		},
		"some": {
			want: []string{"a", "b", "c"},
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got []string
			)

			e := &Encoder{target: buf}
			e.PutStringArray(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.StringArray()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if !reflect.DeepEqual(got, tc.want) {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutVarBytes(t *testing.T) {
	testCases := map[string]struct {
		want []byte
	}{
		"none": {
			want: []byte{},
		},
		"some": {
			want: []byte("hello world"),
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got []byte
			)

			e := &Encoder{target: buf}
			e.PutVarBytes(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.VarBytes()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if !bytes.Equal(got, tc.want) {
				t.Fatalf("got %v; want %v", string(got), string(tc.want))
			}
		})
	}
}

func TestDecoder_PutVarInt(t *testing.T) {
	testCases := map[string]struct {
		want int64
	}{
		"0": {
			want: 0,
		},
		"1": {
			want: 1,
		},
		"-1": {
			want: 1,
		},
		"-int64": {
			want: math.MinInt64,
		},
		"int64": {
			want: math.MaxInt64,
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got int64
			)

			e := &Encoder{target: buf}
			e.PutVarInt(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.VarInt()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got != tc.want {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func TestDecoder_PutVarString(t *testing.T) {
	testCases := map[string]struct {
		want string
	}{
		"none": {
			want: "",
		},
		"some": {
			want: "hello world",
		},
		"unicode": {
			want: "你好",
		},
	}

	for label, tc := range testCases {
		t.Run(label, func(t *testing.T) {
			var (
				buf = bytes.NewBuffer(nil)
				got string
			)

			e := &Encoder{target: buf}
			e.PutVarString(tc.want)
			err := e.Flush()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			decoder := makeTestDecoder(buf.Bytes())
			got, err = decoder.VarString()
			if err != nil {
				t.Fatalf("got %v; want nil", err)
			}

			if got != tc.want {
				t.Fatalf("got %v; want %v", got, tc.want)
			}
		})
	}
}

func BenchmarkDecoder_PutVarBytes(t *testing.B) {
	buf := bytes.NewBuffer(nil)
	encoder := NewEncoder(buf)
	encoder.PutVarBytes([]byte("hello world"))

	var (
		length  = buf.Len()
		decoder = NewDecoder(buf.Bytes(), length)
	)

	for i := 0; i < t.N; i++ {
		decoder.Reset(length)
		_, err := decoder.VarBytes()
		if err != nil {
			t.Fatalf("got %v; want nil", err)
		}
	}
}

func TestStringLength(t *testing.T) {
	got := len("你好")
	if want := 6; got != want {
		t.Fatalf("got %v; want %v", got, want)
	}
}

func BenchmarkDecoder_PutVarString(t *testing.B) {
	buf := bytes.NewBuffer(nil)
	encoder := NewEncoder(buf)
	encoder.PutVarString("你好")

	var (
		length  = buf.Len()
		decoder = NewDecoder(buf.Bytes(), length)
	)

	for i := 0; i < t.N; i++ {
		decoder.Reset(length)
		_, err := decoder.VarString()
		if err != nil {
			t.Fatalf("got %v; want nil", err)
		}
	}
}

func TestDecoder_remain(t *testing.T) {
	var (
		d   = &Decoder{}
		err error
	)

	_, err = d.Bool()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.Bytes()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	err = d.Discard(100)
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.Int8()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.Int16()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.Int32()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.Int32Array()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.Int64()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.Int64Array()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.NullableString()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.String()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.StringArray()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.VarBytes()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.VarInt()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}

	_, err = d.VarString()
	if !IsInsufficientDataError(err) {
		t.Fatalf("got %v; want %v", err, io.ErrShortBuffer)
	}
}

func TestDecoder_Discard(t *testing.T) {
	var (
		length  = 100
		decoder = NewDecoder(make([]byte, length), length)
		want    = 10
	)

	decoder.Discard(want)
	if got, want := decoder.offset, want; got != want {
		t.Fatalf("got %v; want %v", got, want)
	}
	if got, want := decoder.length, length; got != want {
		t.Fatalf("got %v; want %v", got, want)
	}
}

func TestDecoder_Reset(t *testing.T) {
	decoder := &Decoder{}
	decoder.offset = 10
	decoder.length = 20

	want := 5
	decoder.Reset(want)
	if got, want := decoder.offset, 0; got != want {
		t.Fatalf("got %v; want %v", got, want)
	}
	if got := decoder.length; got != want {
		t.Fatalf("got %v; want %v", got, want)
	}
}
