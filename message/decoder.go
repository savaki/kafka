// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package message

import (
	"encoding/binary"
	"errors"
	"io"
	"unicode/utf8"
)

var (
	errNullString     = errors.New("null string")
	errVarIntOverflow = errors.New("var int overflow")
)

// IsInsufficientDataError if the buffer has insufficient data to unmarshal
// the message
func IsInsufficientDataError(err error) bool {
	return errors.Is(err, io.ErrShortBuffer)
}

// Decoder implements a generic protocol decoder
type Decoder struct {
	raw    []byte
	length int
	offset int
}

// NewDecoder returns a new Decoder
func NewDecoder(raw []byte, length int) *Decoder {
	return &Decoder{
		raw:    raw,
		length: length,
	}
}

// Reset allows the decoder to be reused by resetting the length of bytes available
// to length
func (d *Decoder) Reset(length int) {
	d.length = length
	d.offset = 0
}

// remains ensures that the buffer contains at least n more bytes
func (d *Decoder) remains(n int) error {
	if remain := d.length - d.offset; remain < n {
		return io.ErrShortBuffer
	}
	return nil
}

// ArrayLength reads the head of the buffer as an array length (int32)
func (d *Decoder) ArrayLength() (int, error) {
	n, err := d.Int32()
	if err != nil {
		return 0, err
	}
	return int(n), nil
}

// Bool returns the buffer head as a bool
func (d *Decoder) Bool() (bool, error) {
	if err := d.remains(1); err != nil {
		return false, err
	}
	b := d.raw[d.offset] == 1
	d.offset += 1
	return b, nil
}

// Bytes returns the buffer head as a byte array
func (d *Decoder) Bytes() ([]byte, error) {
	n, err := d.Int32()
	if err != nil {
		return nil, err
	}
	length := int(n)

	if err := d.remains(length); err != nil {
		return nil, err
	}

	a, b := d.offset, d.offset+length
	v := d.raw[a:b:b] // limit capacity of returned slice
	d.offset += length
	return v, nil
}

// Discard the specified number of bytes
func (d *Decoder) Discard(n int) error {
	if err := d.remains(n); err != nil {
		return err
	}

	d.offset += n

	return nil
}

// Int8 returns the buffer head as an int8
func (d *Decoder) Int8() (int8, error) {
	if err := d.remains(1); err != nil {
		return 0, err
	}
	v := int8(d.raw[d.offset])
	d.offset += 1
	return v, nil
}

// Int16 returns the buffer head as an int16
func (d *Decoder) Int16() (int16, error) {
	if err := d.remains(2); err != nil {
		return 0, err
	}
	v := int16(binary.BigEndian.Uint16(d.raw[d.offset:]))
	d.offset += 2
	return v, nil
}

// Int32 returns the buffer head as an int32
func (d *Decoder) Int32() (int32, error) {
	if err := d.remains(4); err != nil {
		return 0, err
	}
	v := int32(binary.BigEndian.Uint32(d.raw[d.offset:]))
	d.offset += 4
	return v, nil
}

// Int32Array returns the buffer head as an []int32
func (d *Decoder) Int32Array() ([]int32, error) {
	n, err := d.ArrayLength()
	if err != nil {
		return nil, err
	}

	if n == -1 {
		return nil, nil
	}

	items := make([]int32, n)
	for i := 0; i < n; i++ {
		item, err := d.Int32()
		if err != nil {
			return nil, err
		}
		items[i] = item
	}

	return items, nil
}

// Int64 returns the buffer head as an int64
func (d *Decoder) Int64() (int64, error) {
	if err := d.remains(8); err != nil {
		return 0, err
	}
	v := int64(binary.BigEndian.Uint64(d.raw[d.offset:]))
	d.offset += 8
	return v, nil
}

// Int64Array returns the buffer head as an []int64
func (d *Decoder) Int64Array() ([]int64, error) {
	n, err := d.ArrayLength()
	if err != nil {
		return nil, err
	}

	if n == -1 {
		return nil, nil
	}

	items := make([]int64, n)
	for i := 0; i < n; i++ {
		item, err := d.Int64()
		if err != nil {
			return nil, err
		}
		items[i] = item
	}

	return items, nil
}

// NullableString returns the buffer head as a *string
func (d *Decoder) NullableString() (*string, error) {
	s, err := d.String()
	if err != nil {
		return nil, err
	}

	return &s, nil
}

// String returns the buffer head as a string
func (d *Decoder) String() (string, error) {
	n, err := d.Int16()
	if err != nil {
		return "", err
	}

	if n == -1 {
		return "", nil
	}

	length := int(n)
	if err := d.remains(length); err != nil {
		return "", err
	}

	s := string(d.raw[d.offset : d.offset+length])
	d.offset += length
	return s, nil
}

// StringArray returns the buffer head as a []string
func (d *Decoder) StringArray() ([]string, error) {
	n, err := d.ArrayLength()
	if err != nil {
		return nil, err
	}

	if n == -1 {
		return nil, nil
	}

	items := make([]string, n)
	for i := 0; i < n; i++ {
		item, err := d.String()
		if err != nil {
			return nil, err
		}
		items[i] = item
	}

	return items, nil
}

func (d *Decoder) VarBytes() ([]byte, error) {
	n, err := d.VarInt()
	if err != nil {
		return nil, err
	}
	length := int(n)

	if err := d.remains(length); err != nil {
		return nil, err
	}

	a, b := d.offset, d.offset+length
	v := d.raw[a:b:b] // limit capacity of returned slice
	d.offset += length
	return v, nil
}

// VarInt returns the buffer head as an int64
func (d *Decoder) VarInt() (int64, error) {
	tmp, n := binary.Varint(d.raw[d.offset:])
	switch n {
	case 0:
		d.offset = d.length // no further requests can be made
		return 0, io.ErrShortBuffer

	case -1:
		d.offset = d.length // no further requests can be made
		return 0, errVarIntOverflow

	default:
		d.offset += n
		return tmp, nil
	}
}

func (d *Decoder) VarString() (string, error) {
	n, err := d.VarInt()
	if err != nil {
		return "", err
	}
	length := int(n)

	if err := d.remains(length); err != nil {
		return "", err
	}

	var (
		eom   = d.offset + length // end of message
		som   = d.offset          // start of message
		runes []rune
	)

	for som < eom {
		r, size := utf8.DecodeRune(d.raw[som:eom])
		som += size
		runes = append(runes, r)
	}

	d.offset += length
	return string(runes), nil
}
