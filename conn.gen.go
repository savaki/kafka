// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package kafka

import (
	"bufio"
	"context"
	"crypto/tls"
	"fmt"
	"net"
	"sync"
	"sync/atomic"

	"github.com/savaki/kafka/message"
	"github.com/savaki/kafka/ring"
)

type Conn struct {
	cancel      context.CancelFunc
	ch          chan request
	doneMessage chan struct{}
	doneRead    chan struct{}
	encoder     *message.Encoder
	err         error
	id          int32
	raw         net.Conn
	rb          *ring.Buffer

	writeLock sync.Mutex
	readLock  sync.Mutex
	requests  map[int32]request
}

type request struct {
	decode func(*message.Decoder) error
	reply  chan error
}

func dial(c config, addr string) (net.Conn, error) {
	if c.tlsConfig == nil {
		return c.dialer.Dial("tcp", addr)
	}

	return tls.DialWithDialer(c.dialer, "tcp", addr, c.tlsConfig)
}

func Connect(addr string, opts ...Option) (*Conn, error) {
	config := buildConfig(opts)

	raw, err := dial(config, addr)
	if err != nil {
		return nil, fmt.Errorf("failed to dial broker, %v: %w", addr, err)
	}

	var (
		ctx, cancel = context.WithCancel(context.Background())
		rb          = ring.New(5e6)
		ch          = make(chan request, 32)
		e           = message.NewEncoder(bufio.NewWriter(raw))
	)

	c := &Conn{
		cancel:      cancel,
		ch:          ch,
		doneMessage: make(chan struct{}),
		doneRead:    make(chan struct{}),
		encoder:     e,
		raw:         raw,
		rb:          rb,
		requests:    map[int32]request{},
	}
	go c.readLoop(ctx, rb, raw)
	go c.messageLoop(ctx, rb, ch)

	return c, nil
}

func (c *Conn) readLoop(ctx context.Context, rb *ring.Buffer, raw net.Conn) {
	defer close(c.doneRead)

	buffer := make([]byte, 2e6) // 2MB
	for {
		n, err := raw.Read(buffer)
		if err != nil {
			fmt.Println(err)
			return
		}

		rb.WriteN(buffer, n)
	}
}

func (c *Conn) messageLoop(ctx context.Context, rb *ring.Buffer, ch <-chan request) {
	defer close(c.doneMessage)

	var (
		buffer = make([]byte, 2e6) // 2MB
		d      = message.NewDecoder(buffer, len(buffer))
	)

	for {
		select {
		case <-ctx.Done():
			return
		default:
			// ok
		}

		// read the header
		rb.ReadN(buffer, 4)
		d.Reset(4)
		v, _ := d.Int32()
		size := int(v)

		// read the payload
		rb.ReadN(buffer, size)
		d.Reset(size)

		var resp message.ResponseHeader
		if err := (&resp).Decode(d, 1); err != nil {
			fmt.Println(err)
			continue
		}

		c.readLock.Lock()
		req, ok := c.requests[resp.CorrelationId]
		delete(c.requests, resp.CorrelationId)
		c.readLock.Unlock()

		if ok {
			req.reply <- req.decode(d)
		}
	}
}

type EncodeFunc func(e *message.Encoder, correlationID int32)
type DecodeFunc func(d *message.Decoder) error

func (c *Conn) Do(encode EncodeFunc, decode DecodeFunc) error {
	correlationID := atomic.AddInt32(&c.id, 1)
	req := request{
		decode: decode,
		reply:  make(chan error, 1),
	}

	c.readLock.Lock()
	c.requests[correlationID] = req
	c.readLock.Unlock()

	c.writeLock.Lock()
	encode(c.encoder, correlationID)
	err := c.encoder.Flush()
	c.writeLock.Unlock()

	if err != nil {
		return err
	}

	return <-req.reply
}

func (c *Conn) Close() error {
	c.cancel()
	c.rb.Close()
	c.raw.Close()
	<-c.doneMessage
	<-c.doneRead
	return c.err
}
