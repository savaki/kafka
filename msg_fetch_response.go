// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package kafka

import (
	"github.com/savaki/kafka/protocol"
	"github.com/savaki/kafka/sizeof"
)

// FetchResponse; ApiKey: 1, Versions: 0-11
type FetchResponse struct {
	ThrottleTimeMs int32                     // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 1+
	ErrorCode      int16                     // The top level response error code. Versions: 7+
	SessionId      int32                     // The fetch session ID, or 0 if this is not part of a fetch session. Versions: 7+
	Topics         []FetchableTopicResponse1 // The response topics. Versions: 0+
}

// size of FetchResponse; Versions: 0-11
func (t FetchResponse) size(version int16) int32 {
	var sz int32
	if version >= 1 {
		sz += sizeof.Int32 // ThrottleTimeMs
	}
	if version >= 7 {
		sz += sizeof.Int16 // ErrorCode
	}
	if version >= 7 {
		sz += sizeof.Int32 // SessionId
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].size(version)
	}
	return sz
}

// encode FetchResponse; Versions: 0-11
func (t FetchResponse) encode(e *protocol.Encoder, version int16) {
	if version >= 1 {
		e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	}
	if version >= 7 {
		e.PutInt16(t.ErrorCode) // ErrorCode
	}
	if version >= 7 {
		e.PutInt32(t.SessionId) // SessionId
	}
	// Topics
	len3 := len(t.Topics)
	e.PutArrayLength(len3)
	for i := 0; i < len3; i++ {
		t.Topics[i].encode(e, version)
	}
}

// decode FetchResponse; Versions: 0-11
func (t *FetchResponse) decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 1 {
		t.ThrottleTimeMs, err = d.Int32()
		if err != nil {
			return err
		}
	}
	if version >= 7 {
		t.ErrorCode, err = d.Int16()
		if err != nil {
			return err
		}
	}
	if version >= 7 {
		t.SessionId, err = d.Int32()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]FetchableTopicResponse1, n)
		for i := 0; i < n; i++ {
			var item FetchableTopicResponse1
			if err := (&item).decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type FetchableTopicResponse1 struct {
	Name       string                        // The topic name. Versions: 0+
	Partitions []FetchablePartitionResponse1 // The topic partitions. Versions: 0+
}

// size of FetchableTopicResponse1; Versions: 0-11
func (t FetchableTopicResponse1) size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].size(version)
	}
	return sz
}

// encode FetchableTopicResponse1; Versions: 0-11
func (t FetchableTopicResponse1) encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].encode(e, version)
	}
}

// decode FetchableTopicResponse1; Versions: 0-11
func (t *FetchableTopicResponse1) decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]FetchablePartitionResponse1, n)
		for i := 0; i < n; i++ {
			var item FetchablePartitionResponse1
			if err := (&item).decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type FetchablePartitionResponse1 struct {
	PartitionIndex       int32                 // The partiiton index. Versions: 0+
	ErrorCode            int16                 // The error code, or 0 if there was no fetch error. Versions: 0+
	HighWatermark        int64                 // The current high water mark. Versions: 0+
	LastStableOffset     int64                 // The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED) Versions: 4+
	LogStartOffset       int64                 // The current log start offset. Versions: 5+
	Aborted              []AbortedTransaction1 // The aborted transactions. Versions: 4+
	PreferredReadReplica int32                 // The preferred read replica for the consumer to use on its next fetch request Versions: 11+
	Records              []byte                // The record data. Versions: 0+
}

// size of FetchablePartitionResponse1; Versions: 0-11
func (t FetchablePartitionResponse1) size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int16 // ErrorCode
	sz += sizeof.Int64 // HighWatermark
	if version >= 4 {
		sz += sizeof.Int64 // LastStableOffset
	}
	if version >= 5 {
		sz += sizeof.Int64 // LogStartOffset
	}
	if version >= 4 {
		sz += sizeof.ArrayLength // Aborted
		for i := len(t.Aborted) - 1; i >= 0; i-- {
			sz += t.Aborted[i].size(version)
		}
	}
	if version >= 11 {
		sz += sizeof.Int32 // PreferredReadReplica
	}
	sz += sizeof.Bytes(t.Records) // Records
	return sz
}

// encode FetchablePartitionResponse1; Versions: 0-11
func (t FetchablePartitionResponse1) encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt16(t.ErrorCode)      // ErrorCode
	e.PutInt64(t.HighWatermark)  // HighWatermark
	if version >= 4 {
		e.PutInt64(t.LastStableOffset) // LastStableOffset
	}
	if version >= 5 {
		e.PutInt64(t.LogStartOffset) // LogStartOffset
	}
	if version >= 4 {
		// Aborted
		len5 := len(t.Aborted)
		e.PutArrayLength(len5)
		for i := 0; i < len5; i++ {
			t.Aborted[i].encode(e, version)
		}
	}
	if version >= 11 {
		e.PutInt32(t.PreferredReadReplica) // PreferredReadReplica
	}
	e.PutBytes(t.Records) // Records
}

// decode FetchablePartitionResponse1; Versions: 0-11
func (t *FetchablePartitionResponse1) decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.HighWatermark, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 4 {
		t.LastStableOffset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 5 {
		t.LogStartOffset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 4 {
		// Aborted
		if n, err := d.ArrayLength(); err != nil {
			return err
		} else if n >= 0 {
			t.Aborted = make([]AbortedTransaction1, n)
			for i := 0; i < n; i++ {
				var item AbortedTransaction1
				if err := (&item).decode(d, version); err != nil {
					return err
				}
				t.Aborted[i] = item
			}
		}
	}
	if version >= 11 {
		t.PreferredReadReplica, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.Records, err = d.Bytes()
	if err != nil {
		return err
	}
	return err
}

type AbortedTransaction1 struct {
	ProducerId  int64 // The producer id associated with the aborted transaction. Versions: 4+
	FirstOffset int64 // The first offset in the aborted transaction. Versions: 4+
}

// size of AbortedTransaction1; Versions: 0-11
func (t AbortedTransaction1) size(version int16) int32 {
	var sz int32
	if version >= 4 {
		sz += sizeof.Int64 // ProducerId
	}
	if version >= 4 {
		sz += sizeof.Int64 // FirstOffset
	}
	return sz
}

// encode AbortedTransaction1; Versions: 0-11
func (t AbortedTransaction1) encode(e *protocol.Encoder, version int16) {
	if version >= 4 {
		e.PutInt64(t.ProducerId) // ProducerId
	}
	if version >= 4 {
		e.PutInt64(t.FirstOffset) // FirstOffset
	}
}

// decode AbortedTransaction1; Versions: 0-11
func (t *AbortedTransaction1) decode(d *protocol.Decoder, version int16) error {
	var err error
	if version >= 4 {
		t.ProducerId, err = d.Int64()
		if err != nil {
			return err
		}
	}
	if version >= 4 {
		t.FirstOffset, err = d.Int64()
		if err != nil {
			return err
		}
	}
	return err
}
