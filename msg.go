// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package kafka

import (
	"fmt"

	"github.com/savaki/kafka/protocol/apikey"
)

// apiVersion contains the negotiated versions for each api key
type apiVersion struct {
	Produce                     int16
	Fetch                       int16
	ListOffset                  int16
	Metadata                    int16
	LeaderAndIsr                int16
	StopReplica                 int16
	UpdateMetadata              int16
	ControlledShutdown          int16
	OffsetCommit                int16
	OffsetFetch                 int16
	FindCoordinator             int16
	JoinGroup                   int16
	Heartbeat                   int16
	LeaveGroup                  int16
	SyncGroup                   int16
	DescribeGroups              int16
	ListGroups                  int16
	SaslHandshake               int16
	ApiVersions                 int16
	CreateTopics                int16
	DeleteTopics                int16
	DeleteRecords               int16
	InitProducerId              int16
	OffsetForLeaderEpoch        int16
	AddPartitionsToTxn          int16
	AddOffsetsToTxn             int16
	EndTxn                      int16
	WriteTxnMarkers             int16
	TxnOffsetCommit             int16
	DescribeAcls                int16
	CreateAcls                  int16
	DeleteAcls                  int16
	DescribeConfigs             int16
	AlterConfigs                int16
	AlterReplicaLogDirs         int16
	DescribeLogDirs             int16
	SaslAuthenticate            int16
	CreatePartitions            int16
	CreateDelegationToken       int16
	RenewDelegationToken        int16
	ExpireDelegationToken       int16
	DescribeDelegationToken     int16
	DeleteGroups                int16
	ElectLeaders                int16
	IncrementalAlterConfigs     int16
	AlterPartitionReassignments int16
	ListPartitionReassignments  int16
	OffsetDelete                int16
}

// negotiateApiVersions accepts the apiKeys from the broker and negotiates
// acceptable versions for each api based on the versions supported by
// this library.
func negotiateApiVersions(apiKeys []ApiVersionsResponseKey18) (apiVersion, error) {
	// Since this file is generated, there's no need to externalize the supported
	// versions elsewhere.  We can simply inline the values into the call to matchVersion
	var av apiVersion
	var err error
	for _, apiKey := range apiKeys {
		switch apiKey.ApiKey {
		case apikey.Produce:
			av.Produce, err = matchVersion(apiKey, 0, 8)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.Fetch:
			av.Fetch, err = matchVersion(apiKey, 0, 11)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ListOffset:
			av.ListOffset, err = matchVersion(apiKey, 0, 5)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.Metadata:
			av.Metadata, err = matchVersion(apiKey, 0, 9)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.LeaderAndIsr:
			av.LeaderAndIsr, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.StopReplica:
			av.StopReplica, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.UpdateMetadata:
			av.UpdateMetadata, err = matchVersion(apiKey, 0, 6)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ControlledShutdown:
			av.ControlledShutdown, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.OffsetCommit:
			av.OffsetCommit, err = matchVersion(apiKey, 0, 8)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.OffsetFetch:
			av.OffsetFetch, err = matchVersion(apiKey, 0, 6)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.FindCoordinator:
			av.FindCoordinator, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.JoinGroup:
			av.JoinGroup, err = matchVersion(apiKey, 0, 6)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.Heartbeat:
			av.Heartbeat, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.LeaveGroup:
			av.LeaveGroup, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.SyncGroup:
			av.SyncGroup, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeGroups:
			av.DescribeGroups, err = matchVersion(apiKey, 0, 5)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ListGroups:
			av.ListGroups, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.SaslHandshake:
			av.SaslHandshake, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ApiVersions:
			av.ApiVersions, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.CreateTopics:
			av.CreateTopics, err = matchVersion(apiKey, 0, 5)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DeleteTopics:
			av.DeleteTopics, err = matchVersion(apiKey, 0, 4)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DeleteRecords:
			av.DeleteRecords, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.InitProducerId:
			av.InitProducerId, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.OffsetForLeaderEpoch:
			av.OffsetForLeaderEpoch, err = matchVersion(apiKey, 0, 3)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AddPartitionsToTxn:
			av.AddPartitionsToTxn, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AddOffsetsToTxn:
			av.AddOffsetsToTxn, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.EndTxn:
			av.EndTxn, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.WriteTxnMarkers:
			av.WriteTxnMarkers, err = matchVersion(apiKey, 0, 0)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.TxnOffsetCommit:
			av.TxnOffsetCommit, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeAcls:
			av.DescribeAcls, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.CreateAcls:
			av.CreateAcls, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DeleteAcls:
			av.DeleteAcls, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeConfigs:
			av.DescribeConfigs, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AlterConfigs:
			av.AlterConfigs, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AlterReplicaLogDirs:
			av.AlterReplicaLogDirs, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeLogDirs:
			av.DescribeLogDirs, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.SaslAuthenticate:
			av.SaslAuthenticate, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.CreatePartitions:
			av.CreatePartitions, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.CreateDelegationToken:
			av.CreateDelegationToken, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.RenewDelegationToken:
			av.RenewDelegationToken, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ExpireDelegationToken:
			av.ExpireDelegationToken, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DescribeDelegationToken:
			av.DescribeDelegationToken, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.DeleteGroups:
			av.DeleteGroups, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ElectLeaders:
			av.ElectLeaders, err = matchVersion(apiKey, 0, 2)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.IncrementalAlterConfigs:
			av.IncrementalAlterConfigs, err = matchVersion(apiKey, 0, 1)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.AlterPartitionReassignments:
			av.AlterPartitionReassignments, err = matchVersion(apiKey, 0, 0)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.ListPartitionReassignments:
			av.ListPartitionReassignments, err = matchVersion(apiKey, 0, 0)
			if err != nil {
				return apiVersion{}, err
			}
		case apikey.OffsetDelete:
			av.OffsetDelete, err = matchVersion(apiKey, 0, 0)
			if err != nil {
				return apiVersion{}, err
			}
		}
	}
	return av, nil
}

// matchVersion determines which version of the api to use
func matchVersion(apiKey ApiVersionsResponseKey18, minVersion, maxVersion int16) (int16, error) {
	for version := apiKey.MaxVersion; version >= apiKey.MinVersion; version-- {
		if version := apiKey.MaxVersion; version >= minVersion && version <= maxVersion {
			return version, nil
		}
	}
	return 0, fmt.Errorf("unable to negotiate version for api key, %v", apiKey.ApiKey)
}
