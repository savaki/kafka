// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package kafka

import (
	"github.com/savaki/kafka/protocol"
	"github.com/savaki/kafka/sizeof"
)

// DescribeLogDirsResponse; ApiKey: 35, Versions: 0-1
type DescribeLogDirsResponse struct {
	ThrottleTimeMs int32                     // The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota. Versions: 0+
	Results        []DescribeLogDirsResult35 // The log directories. Versions: 0+
}

// size of DescribeLogDirsResponse; Versions: 0-1
func (t DescribeLogDirsResponse) size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32       // ThrottleTimeMs
	sz += sizeof.ArrayLength // Results
	for i := len(t.Results) - 1; i >= 0; i-- {
		sz += t.Results[i].size(version)
	}
	return sz
}

// encode DescribeLogDirsResponse; Versions: 0-1
func (t DescribeLogDirsResponse) encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ThrottleTimeMs) // ThrottleTimeMs
	// Results
	len1 := len(t.Results)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Results[i].encode(e, version)
	}
}

// decode DescribeLogDirsResponse; Versions: 0-1
func (t *DescribeLogDirsResponse) decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ThrottleTimeMs, err = d.Int32()
	if err != nil {
		return err
	}
	// Results
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Results = make([]DescribeLogDirsResult35, n)
		for i := 0; i < n; i++ {
			var item DescribeLogDirsResult35
			if err := (&item).decode(d, version); err != nil {
				return err
			}
			t.Results[i] = item
		}
	}
	return err
}

type DescribeLogDirsResult35 struct {
	ErrorCode int16                    // The error code, or 0 if there was no error. Versions: 0+
	LogDir    string                   // The absolute log directory path. Versions: 0+
	Topics    []DescribeLogDirsTopic35 // Each topic. Versions: 0+
}

// size of DescribeLogDirsResult35; Versions: 0-1
func (t DescribeLogDirsResult35) size(version int16) int32 {
	var sz int32
	sz += sizeof.Int16            // ErrorCode
	sz += sizeof.String(t.LogDir) // LogDir
	sz += sizeof.ArrayLength      // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].size(version)
	}
	return sz
}

// encode DescribeLogDirsResult35; Versions: 0-1
func (t DescribeLogDirsResult35) encode(e *protocol.Encoder, version int16) {
	e.PutInt16(t.ErrorCode) // ErrorCode
	e.PutString(t.LogDir)   // LogDir
	// Topics
	len2 := len(t.Topics)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Topics[i].encode(e, version)
	}
}

// decode DescribeLogDirsResult35; Versions: 0-1
func (t *DescribeLogDirsResult35) decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ErrorCode, err = d.Int16()
	if err != nil {
		return err
	}
	t.LogDir, err = d.String()
	if err != nil {
		return err
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]DescribeLogDirsTopic35, n)
		for i := 0; i < n; i++ {
			var item DescribeLogDirsTopic35
			if err := (&item).decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type DescribeLogDirsTopic35 struct {
	Name       string                       // The topic name. Versions: 0+
	Partitions []DescribeLogDirsPartition35 // Versions: 0+
}

// size of DescribeLogDirsTopic35; Versions: 0-1
func (t DescribeLogDirsTopic35) size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].size(version)
	}
	return sz
}

// encode DescribeLogDirsTopic35; Versions: 0-1
func (t DescribeLogDirsTopic35) encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].encode(e, version)
	}
}

// decode DescribeLogDirsTopic35; Versions: 0-1
func (t *DescribeLogDirsTopic35) decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]DescribeLogDirsPartition35, n)
		for i := 0; i < n; i++ {
			var item DescribeLogDirsPartition35
			if err := (&item).decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type DescribeLogDirsPartition35 struct {
	PartitionIndex int32 // The partition index. Versions: 0+
	PartitionSize  int64 // The size of the log segments in this partition in bytes. Versions: 0+
	OffsetLag      int64 // The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition) Versions: 0+
	IsFutureKey    bool  // True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future. Versions: 0+
}

// size of DescribeLogDirsPartition35; Versions: 0-1
func (t DescribeLogDirsPartition35) size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	sz += sizeof.Int64 // PartitionSize
	sz += sizeof.Int64 // OffsetLag
	sz += sizeof.Bool  // IsFutureKey
	return sz
}

// encode DescribeLogDirsPartition35; Versions: 0-1
func (t DescribeLogDirsPartition35) encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	e.PutInt64(t.PartitionSize)  // PartitionSize
	e.PutInt64(t.OffsetLag)      // OffsetLag
	e.PutBool(t.IsFutureKey)     // IsFutureKey
}

// decode DescribeLogDirsPartition35; Versions: 0-1
func (t *DescribeLogDirsPartition35) decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	t.PartitionSize, err = d.Int64()
	if err != nil {
		return err
	}
	t.OffsetLag, err = d.Int64()
	if err != nil {
		return err
	}
	t.IsFutureKey, err = d.Bool()
	if err != nil {
		return err
	}
	return err
}
