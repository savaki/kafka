// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package kafka

import (
	"time"

	"github.com/savaki/kafka/message"
	"github.com/savaki/kafka/message/sizeof"
)

const magic = 2 // as per https://kafka.apache.org/documentation/#recordheader

// Header represents the optional Message header
type Header interface {
	Get(key string) (string, bool)
	Range(fn func(key, value string))
}

// MapHeader provides a map implementation of Header
type MapHeader map[string]string

// Get implements Header
func (m MapHeader) Get(key string) (string, bool) {
	v, ok := m[key]
	return v, ok
}

// Range implements Header
func (m MapHeader) Range(fn func(key, value string)) {
	for k, v := range m {
		fn(k, v)
	}
}

// Message implementation
type Message struct {
	Topic     string
	Partition int32
	Offset    int64
	Key       []byte
	Value     []byte
	Timestamp time.Time
	Header    Header
}

func (m Message) Size(version int16) int32 {
	var sz int32
	return sz
}

// RecordBatch defines the storage format for Kafka as per
// https://kafka.apache.org/documentation/#recordbatch
type RecordBatch struct {
	BaseOffset           int64
	BatchLength          int32
	PartitionLeaderEpoch int32
	Magic                int8
	CRC                  int32
	Attributes           int16
	LastOffsetDelta      int32
	FirstTimestamp       int64
	MaxTimestamp         int64
	ProducerId           int64
	ProducerEpoch        int16
	BaseSequence         int32
	Records              []Message
}

func (r RecordBatch) Size(version int16) int32 {
	var sz int32

	sz += sizeof.Int64 // BaseOffset
	sz += sizeof.Int32 // BatchLength
	sz += sizeof.Int32 // PartitionLeaderEpoch
	sz += sizeof.Int8  // Magic
	sz += sizeof.Int32 // CRC
	sz += sizeof.Int16 // Attributes
	sz += sizeof.Int32 // LastOffsetDelta
	sz += sizeof.Int64 // FirstTimestamp
	sz += sizeof.Int64 // MaxTimestamp
	sz += sizeof.Int64 // ProducerId
	sz += sizeof.Int16 // ProducerEpoch
	sz += sizeof.Int32 // BaseSequence

	for _, msg := range r.Records {
		sz += sizeofMessage(msg, version, r.BaseOffset, r.FirstTimestamp)
	}
	return sz
}

func (r RecordBatch) Encode(encoder *message.Encoder, version int16) {
	encoder.PutInt64(r.BaseOffset)
	encoder.PutInt32(r.BatchLength)
	encoder.PutInt32(r.PartitionLeaderEpoch)
	encoder.PutInt8(magic)
	encoder.PutInt32(r.CRC)
	encoder.PutInt16(r.Attributes)
	encoder.PutInt32(r.LastOffsetDelta)
	encoder.PutInt64(r.FirstTimestamp)
	encoder.PutInt64(r.MaxTimestamp)
	encoder.PutInt64(r.ProducerId)
	encoder.PutInt16(r.ProducerEpoch)
	encoder.PutInt32(r.BaseSequence)

	for _, m := range r.Records {
		encodeMessage(m, encoder, version, r.FirstTimestamp)
	}
}

// encodeMessage as per https://kafka.apache.org/documentation/#record
func encodeMessage(m Message, encoder *message.Encoder, version int16, firstTimestamp int64) {
	encoder.PutVarInt(int64(m.Size(version)))              // length
	encoder.PutInt8(0)                                     // attributes
	encoder.PutVarInt(m.Timestamp.Unix() - firstTimestamp) // timestampDelta
	encoder.PutVarInt(0)                                   // offsetDelta
	encoder.PutVarBytes(m.Key)
	encoder.PutVarBytes(m.Value)
	m.Header.Range(encoder.PutRecordHeader)
}

func sizeofMessage(m Message, version int16, baseOffset, firstTimestamp int64) int32 {
	var sz int32
	sz += sizeof.Int8                                        // attributes
	sz += sizeof.VarInt(m.Timestamp.Unix() - firstTimestamp) // timestampDelta
	sz += sizeof.VarInt(m.Offset - baseOffset)               // offsetDelta
	sz += sizeof.VarInt(int64(len(m.Key)))                   // keyLength
	sz += sizeof.Bytes(m.Key)                                // key
	sz += sizeof.VarInt(int64(len(m.Value)))                 // valueLength
	sz += sizeof.Bytes(m.Value)                              // value
	if version >= magic && m.Header != nil {
		m.Header.Range(func(key, value string) {
			sz += sizeof.VarString(key)
			sz += sizeof.VarString(value)
		})
	}
	return sz
}
