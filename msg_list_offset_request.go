// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package kafka

import (
	"github.com/savaki/kafka/protocol"
	"github.com/savaki/kafka/sizeof"
)

// ListOffsetRequest; ApiKey: 2, Versions: 0-5
type ListOffsetRequest struct {
	ReplicaId      int32              // The broker ID of the requestor, or -1 if this request is being made by a normal consumer. Versions: 0+
	IsolationLevel int8               // This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records Versions: 2+
	Topics         []ListOffsetTopic2 // Each topic in the request. Versions: 0+
}

// size of ListOffsetRequest; Versions: 0-5
func (t ListOffsetRequest) size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // ReplicaId
	if version >= 2 {
		sz += sizeof.Int8 // IsolationLevel
	}
	sz += sizeof.ArrayLength // Topics
	for i := len(t.Topics) - 1; i >= 0; i-- {
		sz += t.Topics[i].size(version)
	}
	return sz
}

// encode ListOffsetRequest; Versions: 0-5
func (t ListOffsetRequest) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.ReplicaId) // ReplicaId
	if version >= 2 {
		e.PutInt8(t.IsolationLevel) // IsolationLevel
	}
	// Topics
	len2 := len(t.Topics)
	e.PutArrayLength(len2)
	for i := 0; i < len2; i++ {
		t.Topics[i].Encode(e, version)
	}
}

// decode ListOffsetRequest; Versions: 0-5
func (t *ListOffsetRequest) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.ReplicaId, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 2 {
		t.IsolationLevel, err = d.Int8()
		if err != nil {
			return err
		}
	}
	// Topics
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Topics = make([]ListOffsetTopic2, n)
		for i := 0; i < n; i++ {
			var item ListOffsetTopic2
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Topics[i] = item
		}
	}
	return err
}

type ListOffsetTopic2 struct {
	Name       string                 // The topic name. Versions: 0+
	Partitions []ListOffsetPartition2 // Each partition in the request. Versions: 0+
}

// size of ListOffsetTopic2; Versions: 0-5
func (t ListOffsetTopic2) size(version int16) int32 {
	var sz int32
	sz += sizeof.String(t.Name) // Name
	sz += sizeof.ArrayLength    // Partitions
	for i := len(t.Partitions) - 1; i >= 0; i-- {
		sz += t.Partitions[i].size(version)
	}
	return sz
}

// encode ListOffsetTopic2; Versions: 0-5
func (t ListOffsetTopic2) Encode(e *protocol.Encoder, version int16) {
	e.PutString(t.Name) // Name
	// Partitions
	len1 := len(t.Partitions)
	e.PutArrayLength(len1)
	for i := 0; i < len1; i++ {
		t.Partitions[i].Encode(e, version)
	}
}

// decode ListOffsetTopic2; Versions: 0-5
func (t *ListOffsetTopic2) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.Name, err = d.String()
	if err != nil {
		return err
	}
	// Partitions
	if n, err := d.ArrayLength(); err != nil {
		return err
	} else if n >= 0 {
		t.Partitions = make([]ListOffsetPartition2, n)
		for i := 0; i < n; i++ {
			var item ListOffsetPartition2
			if err := (&item).Decode(d, version); err != nil {
				return err
			}
			t.Partitions[i] = item
		}
	}
	return err
}

type ListOffsetPartition2 struct {
	PartitionIndex     int32 // The partition index. Versions: 0+
	CurrentLeaderEpoch int32 // The current leader epoch. Versions: 4+
	Timestamp          int64 // The current timestamp. Versions: 0+
	MaxNumOffsets      int32 // The maximum number of offsets to report. Versions: 0-0
}

// size of ListOffsetPartition2; Versions: 0-5
func (t ListOffsetPartition2) size(version int16) int32 {
	var sz int32
	sz += sizeof.Int32 // PartitionIndex
	if version >= 4 {
		sz += sizeof.Int32 // CurrentLeaderEpoch
	}
	sz += sizeof.Int64 // Timestamp
	if version >= 0 && version <= 0 {
		sz += sizeof.Int32 // MaxNumOffsets
	}
	return sz
}

// encode ListOffsetPartition2; Versions: 0-5
func (t ListOffsetPartition2) Encode(e *protocol.Encoder, version int16) {
	e.PutInt32(t.PartitionIndex) // PartitionIndex
	if version >= 4 {
		e.PutInt32(t.CurrentLeaderEpoch) // CurrentLeaderEpoch
	}
	e.PutInt64(t.Timestamp) // Timestamp
	if version >= 0 && version <= 0 {
		e.PutInt32(t.MaxNumOffsets) // MaxNumOffsets
	}
}

// decode ListOffsetPartition2; Versions: 0-5
func (t *ListOffsetPartition2) Decode(d *protocol.Decoder, version int16) error {
	var err error
	t.PartitionIndex, err = d.Int32()
	if err != nil {
		return err
	}
	if version >= 4 {
		t.CurrentLeaderEpoch, err = d.Int32()
		if err != nil {
			return err
		}
	}
	t.Timestamp, err = d.Int64()
	if err != nil {
		return err
	}
	if version >= 0 && version <= 0 {
		t.MaxNumOffsets, err = d.Int32()
		if err != nil {
			return err
		}
	}
	return err
}
